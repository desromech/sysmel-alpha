// Create and set the basic types. Some of these types are used everywhere by the
// compiler, so their declaration must be the first thing done.
Compiler compilationTarget
    tupleTypeTrait: trait TupleType;
    functionTypeTrait: trait FunctionType;
    structureTypeTrait: trait StructureType;
    unionTypeTrait: trait UnionType;
    classTypeTrait: trait ClassType;

    apsgNodeType: type _APSGNodeType;
    compilerObjectType: type _CompilerObjectType;
    dynamicObjectType: type _DynamicObject;
    metaType: type _MetaType;
    incompleteType: type _IncompleteType;

    literalArrayType: type _LiteralArray;
    literalSymbolType: type _LiteralSymbol;
    literalStringType: type _LiteralString;
    literalIntegerType: type _LiteralInteger;
    literalFractionType: type _LiteralFraction;
    literalFloatType: type _LiteralFloat;

    voidType: type Void;
    booleanType: type Boolean;
    charType: type Char;

    // Integer types
    int8Type: type Int8;
    uint8Type: type UInt8;

    int16Type: type Int16;
    uint16Type: type UInt16;

    int32Type: type Int32;
    uint32Type: type UInt32;

    int64Type: type Int64;
    uint64Type: type UInt64;

    // Floating point types
    float32Type: type Float32;
    float64Type: type Float64;

    yourself.

// The return macro is used extensively by the language.
macro selector: #return: doOn: {
    evaluation: $$Pharo {
        evaluateMessage: message inEnvironment: anEnvironment
        	| result convertedResult |
        	result := message arguments first evaluateInEnvironment: anEnvironment.
        	convertedResult := result coercedWithRule: message coercionRule intoType: message coercionType at: message.
        	SYMLValueReturnException new
        		value: convertedResult;
        		signal
    }.

    semanticAnalysis: $$Pharo {
        semanticAnalyzeMessage: message inEnvironment: environment at: aPosition
        	| expectedReturnType returnValue returnValueType coercionRule |
        	message arguments size ~= 1 ifTrue: [
        		self error: '#return: meta-method requires at least one argument.' at: aPosition
        	].

        	"Get the expected return type."
        	expectedReturnType := environment returnType.

        	"Get the return value"
        	returnValue := message arguments first semanticAnalysisInEnvironment: environment.
        	returnValue hasIncompleteSemanticAnalysis ifTrue: [
        		^ message copy
        			arguments: { returnValue };
        			metaMethod: self;
        			hasIncompleteSemanticAnalysis: true;
        			yourself
        	].

        	returnValueType := returnValue evaluateTypeInEnvironment: environment.

        	"Check the type of the return value."
        	coercionRule := returnValueType node: returnValue coercedImplicitlyInto: expectedReturnType at: aPosition.
        	^ message copy
        		arguments: { returnValue };
        		metaMethod: self;
        		coercionType: expectedReturnType;
        		coercionRule: coercionRule;
        		valueType: environment compilationTarget voidType;
        		yourself
    }.

    codeGeneration: $$Pharo {
        generateMessage: messageNode ssaCodeWith: builder
        	| value valueNode valueType returnType rawValue |
        	valueNode := messageNode arguments first.
        	valueType := valueNode type.

        	returnType := messageNode coercionType.
        	rawValue := valueNode generateSSACodeWith: builder.

        	^ returnType isVoidType ifTrue: [
        		builder returnVoid
        	] ifFalse: [
        		value := messageNode coercionRule convertSSAValue: rawValue to: returnType with: builder at: messageNode.
        		builder return: value
        	]
    }.
}.

// A generic type
trait Type
definition: {
    meta message isType -> Boolean := {
        return: true
    }.

    meta message isCompilerObjectType -> Boolean := {
        return: false
    }.

    meta message isLiteralType -> Boolean := {
        return: false
    }.

    meta message isPrimitiveType -> Boolean := {
        return: false
    }.

    meta message isOpaqueType -> Boolean := {
        return: false
    }.

    meta message isBooleanType -> Boolean := {
        return: false
    }.

    meta message isNumericalType -> Boolean := {
        return: false
    }.

    meta message isFractionalType -> Boolean := {
        return: false
    }.

    meta message isFloatingPointType -> Boolean := {
        return: false
    }.

    meta message isPointerType -> Boolean := {
        return: false
    }.

    meta message isReferenceType -> Boolean := {
        return: false
    }.

    meta message isTupleType -> Boolean := {
        return: false
    }.

    meta message isFunctionType -> Boolean := {
        return: false
    }.

    meta message isConstantType -> Boolean := {
        return: false
    }.

    meta message isVolatileType -> Boolean := {
        return: false
    }.

    meta message size -> _LiteralInteger := {
        return: 0
    }.

    meta message alignment -> _LiteralInteger := {
        return: 1
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: self
    }.

    meta message valueType -> _CompilerObjectType := {
        return: self
    }.

    meta message asReceiverType -> _CompilerObjectType := {
        return: self
    }.

    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        self error: "Cannot generate default value of {1}" format: (self,self)
    }.
}.

// Meta type
_MetaType uses: Type type.

// A literal type
trait LiteralType
    uses: Type;
definition: {
    meta message isLiteralType -> Boolean := {
        return: true
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: value
    }.
}.

// A primitive type
trait PrimitiveType
    uses: Type;
definition: {
    meta message isPrimitiveType -> Boolean := {
        return: true
    }.

    meta message alignment -> _LiteralInteger := {
        return: self size
    }.

}.

// An opaque type
trait OpaqueType
    uses: Type;
definition: {
    meta message isOpaqueType -> Boolean := {
        return: true
    }
}.

// A numerical type
trait NumericalType uses: Type;
definition: {
    meta message isNumericalType -> Boolean := {
        return: true
    }
}.

// An integer type
trait IntegerType uses: NumericalType;
definition: {
    meta message isIntegerType -> Boolean := {
        return: true
    }.

    meta message isSigned -> Boolean := {
        return: false
    }.

    meta message isUnsigned -> Boolean := {
        return: false
    }.
}.

trait SignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned -> Boolean := {
        return: true
    }.

    meta message isUnsigned -> Boolean := {
        return: false
    }.
}.

trait UnsignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned -> Boolean := {
        return: false
    }.

    meta message isUnsigned -> Boolean := {
        return: true
    }.
}.

trait PrimitiveIntegerType uses: (PrimitiveType, IntegerType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: 0 type: self ssaType)
    }.
}.

trait PrimitiveUnsignedIntegerType uses: (PrimitiveIntegerType, UnsignedIntegerType).
trait PrimitiveSignedIntegerType uses: (PrimitiveIntegerType, SignedIntegerType).

// A boolean type
trait BooleanType uses: Type;
definition: {
    meta message isBooleanType -> Boolean := {
        return: true
    }.
}.

// A fraction type
trait FractionalType uses: NumericalType;
definition: {
    meta message isFractionalType -> Boolean := {
        return: true
    }
}.

// A floating point type
trait FloatingPointType uses: NumericalType;
definition: {
    meta message isFloatingPointType -> Boolean := {
        return: true
    }
}.

// Primitive floating point
trait PrimitiveFloatingPointType uses: (PrimitiveType, FloatingPointType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: 0.0 type: self ssaType)
    }.
}.

// Pointer type
trait PointerType
    uses: Type;
definition: {
    meta message isPointerType -> Boolean := {
        return: true
    }
}.

// Reference type
trait ReferenceType
    uses: Type;
definition: {
    meta message isReferenceType -> Boolean := {
        return: true
    }
}.

// Type composition

// Pointer type
template PointerTypeTemplate(P: Type)
    := type uses: PointerType;
definition: {
    meta message pointed -> _CompilerObjectType := {
        return: P
    }.

    meta message alignment -> _LiteralInteger := {
        return: Compiler compilationTarget pointerAlignment
    }.

    meta message size -> _LiteralInteger := {
        return: Compiler compilationTarget pointerSize
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: P ssaType)
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: P cleanType pointer
    }.
}.

Type extend: {
    meta message pointer -> _CompilerObjectType := {
        return: PointerTypeTemplate(self)
    }
}.

// Reference type
template ReferenceTypeTemplate(R: Type)
    := type uses: ReferenceType;
definition: {
    meta message referenced -> _CompilerObjectType := {
        return: R
    }.

    meta message alignment -> _LiteralInteger := {
        return: Compiler compilationTarget pointerAlignment
    }.

    meta message size -> _LiteralInteger := {
        return: Compiler compilationTarget pointerSize
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: R ssaType)
    }.

    meta message valueType -> _CompilerObjectType := {
        return: R
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: R cleanType ref
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: R cvariadicCoercionType
    }.

    // Reference evaluation
    SelfType conversionTo: R cleanType doOn: {
        evaluation: $$Pharo {
            value: value environment: environment
                self halt.
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                targetType isFunctionType ifTrue: [
                    ^ sourceValue
                ].

                ^ builder load: sourceValue
        }.
    }.
}.

Type extend: {
    meta message ref -> _CompilerObjectType := {
        return: ReferenceTypeTemplate(self)
    }
}.

// Constant type type
template ConstantTypeTemplate(D: Type)
    := type uses: D;
definition: {
    meta message isConstantType -> Boolean := {
        return: true
    }.

    meta message undecoratedType -> _CompilerObjectType := {
        return: D
    }.

    meta message const -> _CompilerObjectType := {
        return: self
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: D ssaType
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: D
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: D cvariadicCoercionType
    }.
}.

Type extend: {
    meta message const -> _CompilerObjectType := {
        return: ConstantTypeTemplate(self)
    }
}.


// Tuple type
TupleType uses: Type;
definition: {
    meta message isTupleType -> Boolean := {
        return: true
    }
}.

// Function type
FunctionType uses: Type;
definition: {
    meta message isFunctionType -> Boolean := {
        return: true
    }.

    macro selector: #applyWithArguments: doOn: {
        semanticAnalysis: $$Pharo {
            node: node environment: environment at: aPosition
                | function argumentsTuple functionType argumentsType functionCoercionRule argument coercionType coercionTypes coercionRules |
                function := node receiver.
                argumentsTuple := node arguments first semanticAnalysisInEnvironment: environment.

                functionType := function evaluateCleanValueTypeInEnvironment: environment.
                argumentsType := argumentsTuple evaluateCleanValueTypeInEnvironment: environment.

                "Check the receiver type"
            	functionType isFunctionType ifFalse: [
            		self error: 'Expected a function type instead of {1}.' format: { functionType asString }
            	].

                functionCoercionRule := function type node: function coercedImplicitlyInto: functionType at: node.

            	"Check the arguments type"
            	argumentsType isTupleType ifFalse: [
            		self error: 'Expected a tuple for the function application arguments.'
            	].

            	argumentsType types size < functionType arguments size ifTrue: [
            		self error: 'Fewer arguments than the required ones for function application.'
            	].

            	(argumentsType types size > functionType arguments size and: [functionType variadic not]) ifTrue: [
            		self error: 'More arguments than the required ones for function application.'
            	].

                coercionRules := Array new: argumentsType types size.
                coercionTypes := Array new: argumentsType types size.
            	argumentsType types doWithIndex: [:argumentType :index |
                    argument := argumentsTuple elements at: index.

                    index > functionType arguments size ifTrue: [
                        coercionType := argumentType cvariadicCoercionType.
                    ] ifFalse: [
                        coercionType := functionType arguments at: index.
                    ].

                    coercionTypes at: index put: coercionType.
                    coercionRules at: index put: (argumentType node: argument coercedImplicitlyInto: coercionType at: argument).
            	].

                ^ node copy
                    metaMethod: self;
                    receiver: function;
                    arguments: {argumentsTuple};
                    coercionRule: {functionCoercionRule . coercionRules};
                    coercionType: {functionType . coercionTypes};
                    valueType: functionType returnType;
                    yourself
        }.

        codeGeneration: $$Pharo {
            node: messageNode builder: builder
            | function rawFunctionType functionType argumentsTuple expectedArgumentTypes functionType argumentValues argumentType coercionRules coercionTypes |

			"Get the function"
			rawFunctionType := messageNode receiver type.
			functionType := messageNode coercionType first.
            function := messageNode coercionRule first
                convertSSAValue: (messageNode receiver generateSSACodeWith: builder)
                to: functionType
                with: builder at: messageNode.

            "Convert the arguments"
            argumentsTuple := messageNode arguments first.
            expectedArgumentTypes := functionType arguments.

            coercionRules := messageNode coercionRule second.
            coercionTypes := messageNode coercionType second.
            argumentValues := argumentsTuple elements collectWithIndex: [:argumentNode :index |
                argumentType := argumentNode type.
                (coercionRules at: index) convertSSAValue: (argumentNode generateSSACodeWith: builder)
                    to: (coercionTypes at: index)
                    with: builder at: messageNode.

            ].

            "Call the function"
            ^ builder call: function arguments: argumentValues
        }
    }.
}.

// Structure type
StructureType uses: Type;
definition: {
    meta message asReceiverType -> _CompilerObjectType := {
        return: self ref
    }.
}.

UnionType uses: StructureType.
ClassType uses: StructureType.

// Definition of some types
_LiteralArray uses: LiteralType.
_LiteralSymbol uses: LiteralType.
_LiteralString uses: LiteralType.

_LiteralInteger uses: (LiteralType, IntegerType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Int32
    }.

}.

_LiteralFraction uses: (LiteralType, FractionalType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Float64
    }.
}.

_LiteralFloat uses: (LiteralType, FloatingPointType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Float64
    }.
}.

_CompilerObjectType uses: Type.
_APSGNodeType uses: Type.

Boolean uses: (BooleanType, PrimitiveType).
Void uses: OpaqueType;
definition: {
    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaVoidType
    }.
}.

// Int8
Int8 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 1
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt8
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

}.

UInt8 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 1
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt8
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.
}.

// Int16
Int16 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 2
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt16
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.
}.

UInt16 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 2
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt16
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

}.

// Int32
Int32 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.
}.

UInt32 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.
}.

// Int64
Int64 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.
}.

UInt64 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.
}.

Float32 uses: PrimitiveFloatingPointType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaFloat32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.
}.

Float64 uses: PrimitiveFloatingPointType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaFloat64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.
}.

Char uses: UInt8.

// Primitive type implicit conversions
_LiteralInteger conversionTo: PrimitiveIntegerType doOn: {
    evaluation: $$Pharo {
        value: value into: targetType at: coercionPosition
            self halt.
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ SLVMConstant type: targetType ssaType value: sourceValue
    }.
}.

LiteralType conversionTo: _CompilerObjectType doOn: {
    evaluation: $$Pharo {
        value: value environment: environment
            ^ value
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            self halt.
    }.
}.

_APSGNodeType conversionTo: _CompilerObjectType doOn: {
    evaluation: $$Pharo {
        value: value environment: environment
            ^ value
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            self halt.
    }.
}.

_LiteralString conversionTo: Char const pointer doOn: {
    evaluation: $$Pharo {
        value: value environment: environment
            self halt
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ builder constCString: sourceValue
    }.
}.
