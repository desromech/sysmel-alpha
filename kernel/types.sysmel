// Create and set the basic types. Some of these types are used everywhere by the
// compiler, so their declaration must be the first thing done.
Compiler compilationTarget
    tupleTypeTrait: trait TupleType;
    functionTypeTrait: trait FunctionType;

    apsgNodeType: type _APSGNodeType;
    compilerObjectType: type _CompilerObjectType;
    dynamicObjectType: type _DynamicObject;
    metaType: type _MetaType;
    incompleteType: type _IncompleteType;

    literalSymbolType: type _LiteralSymbol;
    literalIntegerType: type _LiteralInteger;
    literalFractionType: type _LiteralFraction;
    literalFloatType: type _LiteralFloat;

    voidType: type Void;
    booleanType: type Boolean;
    charType: type Char;

    // Integer types
    int8Type: type Int8;
    uint8Type: type UInt8;

    int16Type: type Int16;
    uint16Type: type UInt16;

    int32Type: type Int32;
    uint32Type: type UInt32;

    int64Type: type Int64;
    uint64Type: type UInt64;

    // Floating point types
    float32Type: type Float32;
    float64Type: type Float64;

    yourself.

// A generic type
trait Type
definition: {
    meta message isType -> Boolean := {
        return: true
    }.

    meta message isCompilerObjectType -> Boolean := {
        return: false
    }.

    meta message isLiteralType -> Boolean := {
        return: false
    }.

    meta message isPrimitiveType -> Boolean := {
        return: false
    }.

    meta message isOpaqueType -> Boolean := {
        return: false
    }.

    meta message isNumericalType -> Boolean := {
        return: false
    }.

    meta message isFractionalType -> Boolean := {
        return: false
    }.

    meta message isFloatingPointType -> Boolean := {
        return: false
    }.

    meta message isPointerType -> Boolean := {
        return: false
    }.

    meta message isTupleType -> Boolean := {
        return: false
    }.

    meta message isFunctionType -> Boolean := {
        return: false
    }.

    meta message isConstant -> Boolean := {
        return: false
    }.

    meta message size -> _LiteralInteger := {
        return: 0
    }.

    meta message alignment -> _LiteralInteger := {
        return: 1
    }.
}.

// A literal type
trait LiteralType
    uses: Type;
definition: {
    meta message isLiteralType -> Boolean := {
        return: true
    }.
}.

// A primitive type
trait PrimitiveType
    uses: Type;
definition: {
    meta message isPrimitiveType -> Boolean := {
        return: true
    }.

    meta message alignment -> _LiteralInteger := {
        return: self size
    }.

}.

// An opaque type
trait OpaqueType
    uses: Type;
definition: {
    meta message isOpaqueType -> Boolean := {
        return: true
    }
}.

// A numerical type
trait NumericalType uses: Type;
definition: {
    meta message isNumericalType -> Boolean := {
        return: true
    }
}.

// An integer type
trait IntegerType uses: NumericalType;
definition: {
    meta message isIntegerType -> Boolean := {
        return: true
    }.

    meta message isUnsigned -> Boolean := {
        return: false
    }.
}.

trait UnsignedIntegerType uses: IntegerType;
definition: {
    meta message isIntegerType -> Boolean := {
        return: true
    }.

    meta message isUnsigned -> Boolean := {
        return: true
    }.
}.


// A floating point type
trait FractionalType uses: NumericalType;
definition: {
    meta message isFractionalType -> Boolean := {
        return: true
    }
}.

// A floating point type
trait FloatingPointType uses: NumericalType;
definition: {
    meta message isFloatingPointType -> Boolean := {
        return: true
    }
}.

// Pointer type
trait PointerType
    uses: Type;
definition: {
    meta message isPointerType -> Boolean := {
        return: true
    }
}.

// Type composition

// Pointer type
template PointerTypeTemplate(P: Type)
    := type uses: PointerType;
definition: {
    meta message pointed -> _CompilerObjectType := {
        return: P
    }
}.

Type extend: {
    meta message pointer -> _CompilerObjectType := {
        return: PointerTypeTemplate(self)
    }
}.

// Constant type type
template ConstantTypeTemplate(D: Type)
    := type uses: D;
definition: {
    meta message isConstant -> Boolean := {
        return: true
    }.

    meta message undecoratedType -> _CompilerObjectType := {
        return: D
    }.

    meta message const -> _CompilerObjectType := {
        return: self
    }.
}.

Type extend: {
    meta message const -> _CompilerObjectType := {
        return: ConstantTypeTemplate(self)
    }
}.


// Tuple type
TupleType uses: Type;
definition: {
    meta message isTupleType -> Boolean := {
        return: true
    }
}.

// Function type
FunctionType uses: Type;
definition: {
    meta message isFunctionType -> Boolean := {
        return: true
    }
}.

// Definition of some types
_LiteralSymbol uses: LiteralType.
_LiteralInteger uses: (LiteralType, IntegerType).
_LiteralFraction uses: (LiteralType, FractionalType).
_LiteralFloat uses: (LiteralType, FloatingPointType).

_CompilerObjectType uses: Type.
_APSGNodeType uses: Type.

Boolean uses: PrimitiveType.
Void uses: OpaqueType.

Int8 uses: (PrimitiveType, IntegerType);
definition: {
    meta message size -> _LiteralInteger := {
        return: 1
    }.
}.

UInt8 uses: (Int8, UnsignedIntegerType).

Int16 uses: (PrimitiveType, IntegerType).
UInt16 uses: (Int16, UnsignedIntegerType).

Int32 uses: (PrimitiveType, IntegerType).
UInt32 uses: (Int32, UnsignedIntegerType).

Int64 uses: (PrimitiveType, IntegerType).
UInt64 uses: (Int64, UnsignedIntegerType).

Float32 uses: (PrimitiveType, FloatingPointType).
Float64 uses: (PrimitiveType, FloatingPointType).

Char uses: UInt8.
