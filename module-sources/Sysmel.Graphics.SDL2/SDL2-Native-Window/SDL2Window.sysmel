namespace Stdn definition: {
namespace Graphics definition: {
namespace GUI definition: {

useNamespace: Stdn Graphics Core.
useNamespace: SDL2.

class SDL2WindowSystem.

class SDL2Window superclass: Window; definition: {
    public field handle type: SDL_Window pointer.
    public field windowSystem type: SDL2WindowSystem pointer.
    protected field currentCursor type: Cursor sharedPointer.
    protected field renderingDevice type: RenderingDevicePtr.

    override method initialize => Void := {
        currentCursor := SystemCursor arrow upCastFor: Cursor.
    }.

    override method finalize => Void := {
        handle ifNotNil: {
            self close.
        }.
    }.

    override method extent => UInt32x2 := {
        let w mutable type: Int32.
        let h mutable type: Int32.
        SDL_GetWindowSize(handle, w address, h address).
        Int32x2(w, h) castTo: UInt32x2
    }.

    override method close => Void := {
        handle ifNotNil: {
            ## Remove myself from the window dictionary before actually destroying the window.
            windowSystem ifNotNil: {
                windowSystem _ windowDestroyed: self address.
                windowSystem := nil.
            }.

            SDL_DestroyWindow(handle).

            handle := nil.
        }.
    }.

    override method renderingDevice => RenderingDevice sharedPointer := {
        renderingDevice ifNil: {
            renderingDevice := RenderingDriverRegistry defaultDriver _ getMainDevice
        }.

        renderingDevice
    }.

    override method renderingDevice: (theRenderingDevice: RenderingDevice sharedPointer) ::=> Void := {
        renderingDevice := theRenderingDevice
    }.

    override method createSwapChain: (swapChainCreationInfo: SwapChainCreationInfo const ref) for: (renderingQueue: CommandQueuePtr const ref) ::=> SwapChainPtr := {
        let adaptedCreationInfo mutable := swapChainCreationInfo.

        adaptedCreationInfo extent = UInt32x2 zeros ifTrue: {
            adaptedCreationInfo extent: self extent.
        }.

        ## Get the rendering device.
        self renderingDevice _ isSoftRenderingDevice ifTrue: {
            let result := SDL2SoftwareRendererSwapChain for: self.
            (result _ initializeWith: adaptedCreationInfo for: renderingQueue on: (renderingDevice getPointer castTo: SoftRenderingDevice pointer) _) ifFalse: {
                return: SwapChainPtr nil
            }.

            return: (result upCastFor: SwapChain).
        }.

        ## Get the native window handle.
        let windowInfo mutable type: SDL_SysWMinfo.
        windowInfo version setCurrent.
        SDL_GetWindowWMInfo(handle, windowInfo address).

        ## Setup the swap chain creation.
        windowInfo subsystem selectCase: #{
        SDL_SYSWM_WINDOWS : {
            adaptedCreationInfo
                windowSystemName: "win32" asMutableString;
                window: windowInfo info win window.
        }.
        SDL_SYSWM_X11 : {
            adaptedCreationInfo
                windowSystemName: "xlib" asMutableString;
                display: windowInfo info x11 display;
                window: windowInfo info x11 window.
        }.
        SDL_SYSWM_COCOA : {
            adaptedCreationInfo
                windowSystemName: "cocoa" asMutableString;
                window: windowInfo info cocoa window.
        }.
        _ : {
            Stdn stderr << "Unsupported window system"; nl.
            return: SwapChainPtr nil
        }.
        }.

        renderingDevice _ createSwapChain: adaptedCreationInfo for: renderingQueue
    }.

    override method createDefaultDrawingSurface => Surface sharedPointer := {
        self renderingDevice _ isSoftRenderingDevice ifTrue: {
            return: ((SDL2SoftwareRendererSurface for: self) upCastFor: Surface).
        }.

        (WindowSwapChainSurface for: (self asSharedPointer upCastFor: Window)) upCastFor: Surface
    }.

    override method grabMouseCapture => Void := {
        SDL_CaptureMouse(true)
    }.

    override method releaseMouseCapture => Void := {
        SDL_CaptureMouse(false)
    }.

    override method setCursor: (cursor: Cursor sharedPointer const ref) ::=> Void := {
        currentCursor == cursor ifTrue: {
            return: void
        }.

        currentCursor := cursor.
        self applyCurrentCursor.
    }.

    method applyCurrentCursor => Void := {
        currentCursor isNil || currentCursor _ isFullyTransparent ifTrue: {
            SDL_ShowCursor(SDL_DISABLE).
        } ifFalse: {
            SDL_ShowCursor(SDL_ENABLE).
            let convertedCursor := windowSystem _ getConvertedCursorFor: currentCursor.
            SDL_SetCursor(convertedCursor).
        }
    }.

}.

}. ## End of namespace GUI
}. ## End of namespace Graphics
}. ## End of namespace Stdn
