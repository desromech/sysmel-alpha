namespace Stdn definition: {
namespace Graphics definition: {
namespace GUI definition: {

useNamespace: SDL2.
useNamespace: Stdn Graphics Core.
class SDL2Window.

function convertSystemCursorName(name: SystemCursorName) => SDL_SystemCursor := {
    name selectCase: #{
    SystemCursorName Arrow : SDL_SYSTEM_CURSOR_ARROW.
    SystemCursorName IBeam : SDL_SYSTEM_CURSOR_IBEAM.
    SystemCursorName Wait : SDL_SYSTEM_CURSOR_WAIT.
    SystemCursorName CrossHair : SDL_SYSTEM_CURSOR_CROSSHAIR.
    SystemCursorName WaitArrow : SDL_SYSTEM_CURSOR_WAITARROW.
    SystemCursorName SizeNorthWestSouthEast : SDL_SYSTEM_CURSOR_SIZENWSE.
    SystemCursorName SizeNorthEastSouthWest : SDL_SYSTEM_CURSOR_SIZENESW.
    SystemCursorName SizeWestEast : SDL_SYSTEM_CURSOR_SIZEWE.
    SystemCursorName SizeNorthSouth : SDL_SYSTEM_CURSOR_SIZENS.
    SystemCursorName SizeAll : SDL_SYSTEM_CURSOR_SIZEALL.
    SystemCursorName No : SDL_SYSTEM_CURSOR_NO.
    SystemCursorName Hand : SDL_SYSTEM_CURSOR_HAND.
    _ : SDL_SYSTEM_CURSOR_ARROW.
    }.
}.

class SDL2WindowSystem superclass: WindowSystem; definition: {

    private field aliveWindowCount type: UInt32.
    private field isQuitRequested type: Boolean8.
    private field windowIDDictionary type: Stdn Collections Dictionary(UInt32, SDL2Window sharedPointer).
    private field lastMousePosition type: Int32x2.
    private field lastKeyModifiers type: KeyModifiers.
    private field allocatedSystemCursors type: (SDL_Cursor pointer array: SystemCursorName Count value).

    override method finalize => Void := {
        0 until: SystemCursorName Count value do: {:i :: Void |
            let cursor := allocatedSystemCursors[i].
            cursor ifNotNil: {
                SDL_FreeCursor(cursor)
            }
        }.

        SDL_Quit().
    }.

    override method isQuitting => Boolean8
        := isQuitRequested || aliveWindowCount == 0.

    method nextWaitEventTimeout => Int32
        := 32.

    method currentMousePosition => Int32x2
        := lastMousePosition.

    method currentKeyModifiers => KeyModifiers
        := lastKeyModifiers.

    override method createWindow: (creationInfo: WindowCreationInfo const ref) ::=> Window sharedPointer := {
        let position mutable := Int32x2(SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED).
        creationInfo position isPresent ifTrue: {
            position := creationInfo position _
        }.

        let extent := creationInfo extent.
        let flags mutable type: Int32 := 0.
        creationInfo hidden ifTrue: {
            flags := flags | SDL_WINDOW_HIDDEN
        } ifFalse: {
            flags := flags | SDL_WINDOW_SHOWN
        }.

        creationInfo borderless ifTrue: {
            flags := flags | SDL_WINDOW_BORDERLESS
        }.

        creationInfo fullscreen ifTrue: {
            flags := flags | SDL_WINDOW_FULLSCREEN
        }.

        let windowHandle := SDL_CreateWindow(creationInfo title asCString, position x, position y, extent x, extent y, 0).
        windowHandle ifNil: {
            return: Window sharedPointer nil.
        }.

        aliveWindowCount := aliveWindowCount + 1.
        let result := SDL2Window sharedNew.
        result _
            handle: windowHandle;
            windowSystem: self address;
            yourself.


        windowIDDictionary at: SDL_GetWindowID(windowHandle) put: result.
        result upCastFor: Window.
    }.

    override method pollAndPumpEvents => Void := {
        let event mutable type: SDL_Event.
        while: SDL_PollEvent(event address) do: {
            self pumpSDLEvent: event
        }
    }.

    override method waitForNextEventOrTimeout => Void := {
        let event mutable type: SDL_Event.
        if: SDL_WaitEventTimeout(event address, self nextWaitEventTimeout) then: {
            self pumpSDLEvent: event
        }.
    }.

    method windowDestroyed: (windowWrapper: SDL2Window pointer) ::=> Void := {
        let handle := windowWrapper _ handle.
        handle ifNotNil: {
            let id := SDL_GetWindowID(handle).
            windowIDDictionary removeKey: id
        }.

        aliveWindowCount := aliveWindowCount - 1.
    }.

    method pumpSDLEvent: (event: SDL_Event) ::=> Void := {
        event type selectCase: #{
        SDL_EventType SDL_WINDOWEVENT : { self processWindowEvent: event window. }.
        SDL_EventType SDL_KEYDOWN : { self processKeyDown: event key }.
        SDL_EventType SDL_KEYUP  : { self processKeyUp: event key }.
        SDL_EventType SDL_TEXTEDITING : { self processTextEditing: event edit }.
        SDL_EventType SDL_TEXTINPUT  : { self processTextInput: event text }.
        SDL_EventType SDL_MOUSEMOTION  : { self processMouseMotion: event motion }.
        SDL_EventType SDL_MOUSEBUTTONUP  : { self processMouseButtonUp: event button }.
        SDL_EventType SDL_MOUSEBUTTONDOWN  : { self processMouseButtonDown: event button }.
        SDL_EventType SDL_MOUSEWHEEL  : { self processMouseWheel: event wheel }.
        _ : {}
        }.
    }.

    method findWrapperForWindowID: (id: UInt32) ::=> Window sharedPointer := {
        let wrapper mutable := (windowIDDictionary at: id ifAbsent: { :: (SDL2Window sharedPointer) |
            SDL2Window sharedPointer nil
        }).

        wrapper upCastFor: Window.
    }.

    method processWindowEvent: (event: SDL_WindowEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        event event selectCase: #{
            SDL_WINDOWEVENT_CLOSE : {
                let convertedEvent mutable type: WindowCloseRequestEvent.
                wrapper _ deliverEvent: convertedEvent.
            }.
            SDL_WINDOWEVENT_EXPOSED : {
                let convertedEvent mutable type: ExposeEvent.
                wrapper _ deliverEvent: convertedEvent.
            }.
            _ : {}
        }
    }.

    method processKeyDown: (event: SDL_KeyboardEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        let convertedEvent mutable := KeyPressedEvent newValue
            symbol: (event keysym sym castTo: KeySymbol);
            modifiers: (event keysym mod castTo: KeyModifiers);
            isRepeat: (event repeat ~= 0);
            yourself.

        lastKeyModifiers := convertedEvent modifiers.

        wrapper _ deliverEvent: convertedEvent.
    }.

    method processKeyUp: (event: SDL_KeyboardEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        let convertedEvent mutable := KeyReleasedEvent newValue
            symbol: (event keysym sym castTo: KeySymbol);
            modifiers: (event keysym mod castTo: KeyModifiers);
            isRepeat: (event repeat ~= 0);
            yourself.

        lastKeyModifiers := convertedEvent modifiers.

        wrapper _ deliverEvent: convertedEvent.
    }.

    method processTextEditing: (event: SDL_TextEditingEvent const ref) ::=> Void := {
    }.

    method processTextInput: (event: SDL_TextInputEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        let convertedEvent mutable := TextInputEvent newValue.
        convertedEvent text := Stdn String fromCString: event text[0] address.
        wrapper _ deliverEvent: convertedEvent.
    }.

    method processMouseMotion: (event: SDL_MouseMotionEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        let convertedEvent mutable := MouseMoveEvent newValue
            mouseId: event which;
            position: Int32x2(event x, event y);
            modifiers: self currentKeyModifiers;
            buttonState: (event state castTo: MouseButtonMask);
            delta: Int32x2(event xrel, event yrel);
            yourself.

        lastMousePosition := convertedEvent position.

        wrapper _ deliverEvent: convertedEvent.
    }.

    method processMouseButtonDown: (event: SDL_MouseButtonEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        let convertedEvent mutable := MouseButtonPressedEvent newValue
            mouseId: event which;
            position: Int32x2(event x, event y);
            modifiers: self currentKeyModifiers;
            button: (event button castTo: MouseButton);
            yourself.

        lastMousePosition := convertedEvent position.

        wrapper _ deliverEvent: convertedEvent.
    }.

    method processMouseButtonUp: (event: SDL_MouseButtonEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        let convertedEvent mutable := MouseButtonReleasedEvent newValue
            mouseId: event which;
            position: Int32x2(event x, event y);
            modifiers: self currentKeyModifiers;
            button: (event button castTo: MouseButton);
            yourself.

        lastMousePosition := convertedEvent position.

        wrapper _ deliverEvent: convertedEvent.
    }.

    method processMouseWheel: (event: SDL_MouseWheelEvent const ref) ::=> Void := {
        let wrapper mutable := self findWrapperForWindowID: event windowID.
        wrapper ifNil: {return: void}.

        let convertedEvent mutable := MouseWheelEvent newValue
            mouseId: event which;
            position: self currentMousePosition;
            modifiers: self currentKeyModifiers;
            scrollDelta: Int32x2(event x, event y);
            isFlipped: event direction == SDL_MOUSEWHEEL_FLIPPED;
            yourself.

        wrapper _ deliverEvent: convertedEvent.
    }.

    override method broadcastEvent: (event: Event ref) ::=> Void := {
        windowIDDictionary valuesDo: {:(SDL2Window sharedPointer ref) window :: Void |
            window _ deliverEvent: event
        }
    }.

    method getConvertedCursorFor: (cursor: Cursor sharedPointer) ::=> SDL_Cursor pointer := {
        self getSystemCursor: cursor _ systemCursorName
    }.

    method getSystemCursor: (systemCursorName: SystemCursorName) ::=> SDL_Cursor pointer := {
        systemCursorName >= SystemCursorName Count ifTrue: {
            return: (self getSystemCursor: SystemCursorName Arrow)
        }.

        let result ref := allocatedSystemCursors[systemCursorName value].
        result ifNil: {
            let convertedName := convertSystemCursorName(systemCursorName).
            result := SDL_CreateSystemCursor(convertedName)
        }.

        result
    }.
}.

function createSDL2WindowSystem() => WindowSystem sharedPointer := {
    SDL_SetHint("SDL_HINT_NO_SIGNAL_HANDLERS", "1").
    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK | SDL_INIT_GAMECONTROLLER | SDL_INIT_AUDIO) ~= 0 ifTrue: {
        Stdn stdout << "Failed to initialize SDL2"; nl.
        return: WindowSystem sharedPointer nil
    }.

    SDL2WindowSystem sharedNew upCastFor: WindowSystem.
}.

function createWindowSystem() => WindowSystem sharedPointer
    := createSDL2WindowSystem().

}. ## End of namespace GUI
}. ## End of namespace Graphics
}. ## End of namespace Stdn
