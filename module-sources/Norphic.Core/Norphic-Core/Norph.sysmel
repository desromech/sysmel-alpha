namespace Norphic definition: {

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Math Geometry.

class Sizer.
class SizerElement.

compileTime constant EventHandlerFunctionType := (NorphEvent ref) => Void.
compileTime constant NorphSceneNode := Stdn Graphics Scene2D Node.
compileTime constant NorphSceneNodePtr := Stdn Graphics Scene2D NodePtr.
compileTime constant NorphSceneBuilder := Stdn Graphics Scene2D Builder.

#**
 * I am a norph, my name comes from Native (M)orph in honor to the old
 * Smalltalk morph.
 *#
class Norph superclass: NorphEventHandler; definition: {
    compileTime constant Subnorphs := Stdn Collections Vector(Norph sharedPointer).
    protected field bounds type: RectangleF32.
    protected field color type: Float32x4.

    protected field owner type: Norph weakPointer.
    protected field subnorphs type: Subnorphs.
    protected field eventSubscriptions type: Stdn Collections Vector(NorphEventSubscription sharedPointer).

    private field isDirtyInThisFrame type: Boolean8.
    private field isUpdatingLayout type: Boolean8.

    public field sizer type: Sizer sharedPointer.
    public field autolayout type: Boolean8.

    inline method extent => Float32x2
        := bounds extent.

    virtual method extent: (newExtent: Float32x2) ::=> Void := {
        self bounds: (RectangleF32 min: self position extent: newExtent)
    }.

    virtual method isClipped => Boolean8
        := false.

    const inline method position => Float32x2
        := bounds min.

    const virtual method rootLocalPosition => Float32x2 := {
        let result mutable := self position.
        self owner ifNotNil: {:o :: Void |
            result := result + o _ rootLocalPosition
        }.
        result
    }.

    virtual method position: (newPosition: Float32x2) ::=> Void := {
        self bounds: (RectangleF32 min: newPosition extent: self extent)
    }.

    virtual method movedInto: (newPosition: Float32x2) ::=> Void := {
        bounds := RectangleF32 min: newPosition extent: bounds extent.
        self positionChanged.
    }.

    virtual method extentChangedInto: (newExtent: Float32x2) ::=> Void := {
        bounds := RectangleF32 min: bounds min extent: newExtent.
        self extentChanged.
    }.

    virtual method bounds => RectangleF32
        := bounds.

    virtual method bounds: (theNewBounds: RectangleF32 const ref) ::=> Void := {
        bounds = theNewBounds ifTrue: {
            return: void.
        }.

        bounds extent = theNewBounds extent ifTrue: {
            bounds := theNewBounds.
            self positionChanged.
        } ifFalse: {
            bounds min = theNewBounds min ifTrue: {
                bounds := theNewBounds.
                self extentChanged.
            } ifFalse: {
                bounds := theNewBounds.
                self boundsChanged.
            }
        }
    }.

    inline method localBounds => RectangleF32
        := RectangleF32 min: Float32x2 zeros extent: self extent.

    override method initialize => Void := {
        bounds := self defaultBounds.
        color := self defaultColor.
    }.

    override method finalize => Void := {
        self destroy
    }.

    virtual method defaultExtent => Float32x2
        := Float32x2(50, 40).

    virtual method defaultBounds => RectangleF32
        := RectangleF32 min: Float32x2 zeros extent: self defaultExtent.

    virtual method defaultColor => Float32x4
        := Float32x4(0.25f, 0.8f, 0.25f, 1.0f).

    virtual method minimalContentExtent => Float32x2
        := Float32x2 zeros.

    virtual method minimalExtent => Float32x2 := {
        let result mutable := self minimalContentExtent.
        sizer ifNotNil: {
            result := result max: sizer _ minimalExtent
        }.

        result.
    }.

    virtual method color => Float32x4
        := color.

    virtual method color: (theNewColor: Float32x4 const ref) ::=> Void := {
        color := theNewColor.
        self changed.
    }.

    virtual method buildFullSceneGraphWith: (builder: NorphSceneBuilder ref) ::=> NorphSceneNodePtr := {
        let content := self buildContentSceneGraphWith: builder.
        let clippedContent mutable := content.
        self isClipped ifTrue: {
            clippedContent := (builder clipRectangle: self localBounds node: content) upCastFor: NorphSceneNode
        }.

        (builder translate: bounds min node: clippedContent) upCastFor: NorphSceneNode
    }.

    virtual method buildContentSceneGraphWith: (builder: NorphSceneBuilder ref) ::=> NorphSceneNodePtr := {
        let myNode := self buildSceneGraphWith: builder.
        let myPostChildrenNode := self buildPostChildrenSceneGraphWith: builder.
        self validSubnorphs ifEmpty: {
            return: myNode _ -- myPostChildrenNode
        }.

        let result := builder container.
        result _ add: myNode.

        self validSubnorphs do: {:child :: Void |
            result _ add: (child _ buildFullSceneGraphWith: builder)
        }.

        result _ add: myPostChildrenNode.

        result upCastFor: NorphSceneNode
    }.

    virtual method buildSceneGraphWith: (builder: NorphSceneBuilder ref) ::=> NorphSceneNodePtr
        := (builder fillRectangle: self localBounds color: self color) upCastFor: NorphSceneNode.

    virtual method buildPostChildrenSceneGraphWith: (builder: NorphSceneBuilder ref) ::=> NorphSceneNodePtr
        := NorphSceneNodePtr nil.

    virtual method childChanged ::=> Void := {
        self changed
    }.

    virtual method childBoundsChanged ::=> Void := {
        autolayout ifTrue: {
            self updateLayout
        }
    }.

    virtual method changed ::=> Void := {
        isDirtyInThisFrame ifTrue: {
            return: void
        }.

        self owner ifNotNil: { :theOwner :: Void |
            theOwner _ childChanged.
        }.
    }.

    virtual method invalidateLayout => Void := {
        ## TODO: Delay this layout revalidation.
        autolayout ifTrue: {
            self updateLayout.
        }.
    }.

    virtual method extentChanged ::=> Void := {
        self changed.
        self invalidateLayout.

        self owner ifNotNil: { :theOwner :: Void |
            theOwner _ childBoundsChanged.
        }.
    }.

    virtual method positionChanged ::=> Void := {
        self owner ifNotNil: { :theOwner :: Void |
            theOwner _ childBoundsChanged.
        }.
    }.

    virtual method boundsChanged ::=> Void := {
        self changed.

        autolayout ifTrue: {
            self updateLayout.
        }.

        self owner ifNotNil: { :theOwner :: Void |
            theOwner _ childBoundsChanged.
        }.
    }.

    virtual method fit => Void := {
        self
            extent: self minimalExtent;
            updateLayout
    }.

    virtual method doUpdateLayout => Void := {
        sizer ifNotNil: {
            sizer _ applyIntoBounds: self localBounds
        }
    }.

    virtual method updateLayout => Void := {
        isUpdatingLayout ifTrue: { return: void }.
        isUpdatingLayout := true.
        try: {
            self doUpdateLayout
        } finally: {
            isUpdatingLayout := false.
        }
    }.

    virtual method destroy ::=> Void := {
        self owner ifNotNil: { :o :: Void |
            o _ removeSubnorph: self asSharedPointer
        }.
    }.

    virtual method validSubnorphs => Subnorphs const ref
        := subnorphs.

    virtual method addedToOwner: (newOwner: Norph ref) ::=> Void := {
        owner := newOwner asWeakPointer.
    }.

    virtual method removedFromOwner: (oldOwner: Norph ref) ::=> Void := {
        owner reset
    }.

    virtual method removeSubnorph: (childSubnorph: Norph sharedPointer const ref) ::=> Void := {
        childSubnorph ifNil: { return: void }.

        subnorphs remove: childSubnorph.
        childSubnorph _ removedFromOwner: self.
        self changed.
    }.

    virtual method addSubnorph: (newSubnorph: Norph sharedPointer const ref) ::=> Void := {
        newSubnorph ifNil: { return: void }.

        subnorphs add: newSubnorph.
        newSubnorph _ addedToOwner: self.
        self changed.
    }.

    const virtual method globalPosition => Float32x2 := {
        self owner ifNotNil: {:owner :: Void |
            return: bounds min + owner _ globalPosition
        }.

        bounds min
    }.

    const virtual method keyboardFocusNorph => Norph pointer := {
        self owner ifNotNil: {:owner :: Void |
            return: owner _ keyboardFocusNorph
        }.

        nil
    }.

    const virtual method mouseFocusNorph => Norph pointer := {
        self owner ifNotNil: {:owner :: Void |
            return: owner _ mouseFocusNorph
        }.

        nil
    }.

    const virtual method mouseCaptureNorph => Norph pointer := {
        self owner ifNotNil: {:owner :: Void |
            return: owner _ mouseCaptureNorph
        }.

        nil
    }.

    const virtual method rootNorph => RootNorph pointer := {
        self owner ifNotNil: {:owner :: Void |
            return: owner _ rootNorph
        }.

        nil
    }.

    method grabMouseCapture => Void := {
        self rootNorph ifNotNil: {:root :: Void |
            root _ setMouseCaptureNorph: self address
        }
    }.

    method releaseMouseCapture => Void := {
        self hasMouseCapture ifFalse: {
            return: void
        }.

        self rootNorph ifNotNil: {:root :: Void |
            root _ setMouseCaptureNorph: nil
        }
    }.

    const inline method owner => Norph sharedPointer
        := owner lock.

    virtual method handlesKeyboardEvents => Boolean8
        := false.

    virtual method handlesTextInputEvents => Boolean8
        := false.

    virtual method canHaveKeyboardFocus => Boolean8
        := self handlesKeyboardEvents.

    virtual method canReceiveKeyboardEvents => Boolean8
        := self handlesKeyboardEvents && (self canHaveKeyboardFocus ifTrue: {
            self hasKeyboardFocus
        } ifFalse: {
            self owner ifNotNil: { :o :: Boolean8 |
                o _ canReceiveKeyboardEvents
            } ifNil: {
                false
            }
        }).

    method acquireKeyboardFocus => Void := {
        self rootNorph ifNotNil: {:root :: Void |
            root _ setNewKeyboardFocus: self address
        }
    }.

    inline method theme => Theme sharedPointer const ref
        := ThemeRegistry uniqueInstance defaultTheme.

    inline method asSizerElement => SizerElement sharedPointer
        := (SizerNorphElement for: self) upCastFor: SizerElement.

    const inline method hasMouseFocus => Boolean8
        := self mouseFocusNorph == self address.

    const inline method hasMouseCapture => Boolean8
        := self mouseCaptureNorph == self address.

    virtual method handlesMouseEvents => Boolean8
        := true.

    virtual method currentMouseCursor => Cursor sharedPointer := {
        self owner ifNotNil: {:owner :: Void |
            return: owner _ currentMouseCursor
        }.

        SystemCursor arrow upCastFor: Cursor.
    }.

    virtual method currentCursorChanged => Void := {
        self hasMouseFocus ifTrue: {
            self rootNorph _ currentActiveMouseCursorChanged.
        }
    }.

    override method onMouseButtonReleasedEvent: (event: NorphMouseButtonReleasedEvent ref) ::=> Void := {
        event isLeftButton && event wasHandled not && self canHaveKeyboardFocus ifTrue: {
            self acquireKeyboardFocus.
            event wasHandled: true.
        }.
    }.

    virtual method dispatchMouseEventToChildren: (event: NorphMouseEvent ref) ::=> Void := {
        let mousePosition := event position.
        self validSubnorphs reverseDo: {:child :: Void |
            let childBounds := child _ bounds.
            child _ handlesMouseEvents && (childBounds includesPoint: event position) ifTrue: {
                event position: mousePosition - childBounds min.
                try: {
                    child _ dispatchMouseEvent: event
                } finally: {
                    event position: mousePosition
                }.

                event wasHandled ifTrue: {
                    return: void
                }
            }
        }.
    }.

    virtual method dispatchMouseEvent: (event: NorphMouseEvent ref) ::=> Void := {
        self dispatchMouseEventToChildren: event.

        event targetNorph ifNil: {
            event targetNorph: self asSharedPointer.

            self rootNorph ifNotNil: {:rootNorph :: Void |
                rootNorph _ mouseEventHasFoundItsTarget: event
            }.
        }.

        self handlesMouseEvents ifTrue: {
            self processEvent: event.
        }.
    }.

    virtual method dispatchKeyboardEventFromParent: (event: NorphKeyboardEvent ref) ::=> Void := {
        self
            dispatchKeyboardEventToChildren: event;
            dispatchKeyboardHereEvent: event.
    }.

    virtual method dispatchKeyboardEventToChildren: (event: NorphKeyboardEvent ref) ::=> Void := {
        self validSubnorphs do: {:each :: Void |
            each _ canHaveKeyboardFocus ifFalse: {
                each _ dispatchKeyboardEventFromParent: event.
                event wasHandled ifTrue: {return: void}.
            }.
        }.
    }.

    virtual method dispatchKeyboardHereEvent: (event: NorphKeyboardEvent ref) ::=> Void := {
        event wasHandled ifTrue: {return: void}.
        self handlesKeyboardEvents ifTrue: {
            self processEvent: event.
        }.
    }.

    virtual method dispatchKeyboardEvent: (event: NorphKeyboardEvent ref) ::=> Void := {
        self dispatchKeyboardEventFromParent: event.

        self hasKeyboardFocus ifTrue: {
            self owner ifNotNil: {:parent :: Void |
                parent _ dispatchPropagatedKeyboardEvent: event
            }.
        }.
    }.

    virtual method dispatchPropagatedKeyboardEvent: (event: NorphKeyboardEvent ref) ::=> Void := {
        self dispatchKeyboardHereEvent: event.

        self owner ifNotNil: {:parent :: Void |
            parent _ dispatchPropagatedKeyboardEvent: event
        }.
    }.

    virtual method dispatchTextInputEventFromParent: (event: NorphTextInputEvent ref) ::=> Void := {
        self
            dispatchTextInputEventToChildren: event;
            dispatchTextInputHereEvent: event.
    }.

    virtual method dispatchTextInputEventToChildren: (event: NorphTextInputEvent ref) ::=> Void := {
        self validSubnorphs do: {:each :: Void |
            each _ canHaveKeyboardFocus ifFalse: {
                each _ dispatchTextInputEventFromParent: event.
                event wasHandled ifTrue: {return: void}.
            }.
        }.
    }.

    virtual method dispatchTextInputHereEvent: (event: NorphTextInputEvent ref) ::=> Void := {
        event wasHandled ifTrue: {return: void}.
        self handlesTextInputEvents ifTrue: {
            self processEvent: event.
        }.
    }.

    virtual method dispatchTextInputEvent: (event: NorphTextInputEvent ref) ::=> Void := {
        self dispatchTextInputEventFromParent: event.

        self hasKeyboardFocus ifTrue: {
            self owner ifNotNil: {:parent :: Void |
                parent _ dispatchPropagatedTextInputEvent: event
            }.
        }.
    }.

    virtual method dispatchPropagatedTextInputEvent: (event: NorphTextInputEvent ref) ::=> Void := {
        self dispatchTextInputHereEvent: event.

        self owner ifNotNil: {:parent :: Void |
            parent _ dispatchPropagatedTextInputEvent: event
        }.
    }.

    const inline method hasKeyboardFocus => Boolean8
        := self keyboardFocusNorph == self address.

    method addEventSubscription: (subscription: NorphEventSubscription sharedPointer const ref) ::=> Void := {
        eventSubscriptions add: subscription
    }.

    method registerEventHandler: (eventHandler: EventHandlerFunctionType nativeBlockClosure) forClassInfo: (eventClassInfo: Stdn Reflection TypeInformation const pointer) ::=> Void := {
        let subscription := NorphEventFunctionSubscription sharedNew.
        subscription _
            handlingFunction: eventHandler;
            expectedEventTypeInfo: eventClassInfo.

        self addEventSubscription: (subscription upCastFor: NorphEventSubscription)
    }.

    compileTime if: Compiler hasRuntimeTypeInformation && Compiler hasGarbageCollectionSupport then: {
        method registerEventHandler: (eventHandler: EventHandlerFunctionType gcBlockClosure) forClassInfo: (eventClassInfo: Stdn Reflection TypeInformation const pointer) ::=> Void := {
            let subscription := NorphEventFunctionSubscription sharedNew.
            subscription _
                handlingFunction: eventHandler;
                expectedEventTypeInfo: eventClassInfo.

            self addEventSubscription: (subscription upCastFor: NorphEventSubscription)
        }.
    }.

    macro method when: aClass do: aBlock
        := ``(`,self registerEventHandler: `,aBlock forClassInfo: (`,aClass asTypeInformation)
    ).

    method raiseEvent: (event: NorphEvent sharedPointer) ::=> Void := {
        self processEvent: event _.

        eventSubscriptions do: {:each :: Void |
            (each _ handlesEvent: event _) ifTrue: {
                each _ handleEvent: event _
            }.
        }.
    }.

    method raiseActivatedEvent => Void := {
        self raiseEvent: (NorphActivatedEvent sharedNew upCastFor: NorphEvent).
    }.

    virtual method ownedPopupCreated: (popup: PopupNorph sharedPointer const ref) ::=> Void := {

    }.

    virtual method ownedPopupKilled: (popup: PopupNorph sharedPointer const ref) ::=> Void := {

    }.

    const virtual method isPopupNorph => Boolean8
        := false.
}.

compileTime constant NorphPtr := Norph sharedPointer.

}. ## End of namespace Norphic
