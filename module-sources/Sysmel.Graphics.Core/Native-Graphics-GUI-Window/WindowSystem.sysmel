namespace Stdn definition: {
namespace Graphics definition: {
namespace GUI definition: {

class Window.
class WindowCreationInfo.

#**
 * I represent an interface into a window system window.
 *#
class WindowSystem superclass: Object; definition: {
    public field targetFrameRate type: Stdn Chrono Time.

    meta definition: {
        global MainWindowSystem mutable type: WindowSystemRef.

        method activeWindowSystem: (aWindowSystem: WindowSystemRef const ref) ::=> Void
            := MainWindowSystem := aWindowSystem.

        method validActiveWindowSystem => WindowSystemRef
            := MainWindowSystem.
    }.

    virtual method createWindow: (description: WindowCreationInfo const ref) ::=> Window sharedPointer
        := Window sharedPointer nil.

    virtual method createWindowWithTitle: (title: Stdn String const ref) extent: (extent: Int32x2) ::=> Window sharedPointer := {
        let creationInfo mutable type: WindowCreationInfo.
        creationInfo
            title: title;
            extent: extent.

        self createWindow: creationInfo.
    }.

    virtual method createWindowWithTitle: (title: Stdn String const ref) position: (position: Int32x2) extent: (extent: Int32x2) ::=> Window sharedPointer := {
        let creationInfo mutable type: WindowCreationInfo.
        creationInfo
            title: title;
            position: position;
            extent: extent.

        self createWindow: creationInfo.
    }.

    ## Do we have to finish the main loop?
    virtual method isQuitting => Boolean8
        := false.

    ## Run the default main loop.
    virtual method runMainLoop => Int32 := {
        compileTime if: Compiler compilationTarget isWebAssembly then: {
            Emscripten emscripten_set_main_loop_arg(windowSystemMainLoopCallback address, self address, targetFrameRate castTo: Int32, 1).
        } else: {
            let oldTicks mutable := Stdn Chrono now().
            let accumulatedTicks mutable type: Stdn Chrono Time.
            let mainLoopStartTicks := Stdn Chrono now().

            until: self isQuitting do: {
                let frameStartTicks := Stdn Chrono now().
                self pollAndPumpEvents.

                let ticksPerFrame := Stdn Chrono TicksPerSecond / targetFrameRate.

                let deltaTicks := frameStartTicks - oldTicks.
                accumulatedTicks := accumulatedTicks + deltaTicks.

                let deterministicFrameCount := accumulatedTicks / ticksPerFrame max: 0.
                accumulatedTicks := accumulatedTicks - deterministicFrameCount*ticksPerFrame.

                ## Send the tick events
                {
                    let event mutable type: TickEvent.
                    event
                        ticks: frameStartTicks - mainLoopStartTicks;
                        deterministicDelta: ticksPerFrame;
                        deterministicRemainingDelta: accumulatedTicks;
                        deterministicFrameCount: (deterministicFrameCount castTo: UInt32);
                        delta: deltaTicks.
                    self broadcastEvent: event.
                }.

                targetFrameRate > 0 ifTrue: {
                    let targetNextFrameTime := frameStartTicks + ticksPerFrame.
                    Stdn Chrono sleepUntil(targetNextFrameTime)
                } ifFalse: {
                    self waitForNextEventOrTimeout.
                }.

                oldTicks := frameStartTicks.
            }.
        }.

        return: 0
    }.

    #**
     * A single iteration of the main loop.
     *#
    virtual method mainLoopIteration => Void := {
        {
            let event mutable type: TickEvent.
            self broadcastEvent: event.
        }.
        self pollAndPumpEvents.
    }.

    #**
     * Poll for events non-blockingly and then pump the events into the actual windows.
     *#
    virtual method pollAndPumpEvents => Void := {

    }.

    #**
     * Wait and pump the next, or until something times out.
     *#
    virtual method waitForNextEventOrTimeout => Void := {

    }.

    #**
     * Broadcast and event into all of the windows.
     *#
    virtual method broadcastEvent: (event: Event ref) ::=> Void := {

    }.
}.

compileTime if: Compiler compilationTarget isWebAssembly then: {
function windowSystemMainLoopCallback(windowSystemPointer: Void pointer) => Void := {
    (windowSystemPointer reinterpretCastTo: WindowSystem pointer) _ mainLoopIteration
}.
}.

compileTime constant WindowSystemRef := WindowSystem sharedPointer.
compileTime constant WindowSystemWeakRef := WindowSystem weakPointer.

## The main global window system. This one is used by the Smalltalk style IDE tools.

}. ## End of namespace GUI
}. ## End of namespace Graphics
}. ## End of namespace Stdn
