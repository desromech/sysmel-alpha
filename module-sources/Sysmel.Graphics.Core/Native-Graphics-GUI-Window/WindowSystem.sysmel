namespace Stdn definition: {
namespace Graphics definition: {
namespace GUI definition: {

class Window.
class WindowCreationInfo.

#**
 * I represent an interface into a window system window.
 *#
class WindowSystem superclass: Object; definition: {
    public field targetFrameRate type: Stdn Chrono Time.

    virtual method createWindow: (description: WindowCreationInfo const ref) ::=> Window sharedPointer
        := Window sharedPointer nil.

    virtual method createWindowWithTitle: (title: Stdn String const ref) extent: (extent: Int32x2) ::=> Window sharedPointer := {
        let creationInfo mutable type: WindowCreationInfo.
        creationInfo
            title: title;
            extent: extent.

        self createWindow: creationInfo.
    }.

    virtual method createWindowWithTitle: (title: Stdn String const ref) position: (position: Int32x2) extent: (extent: Int32x2) ::=> Window sharedPointer := {
        let creationInfo mutable type: WindowCreationInfo.
        creationInfo
            title: title;
            position: position;
            extent: extent.

        self createWindow: creationInfo.
    }.

    ## Do we have to finish the main loop?
    virtual method isQuitting => Boolean8
        := false.

    ## Run the default main loop.
    virtual method runMainLoop => Int32 := {
        let oldTicks mutable := Stdn Chrono now().
        let accumulatedTicks mutable type: Stdn Chrono Time.
        let mainLoopStartTicks := Stdn Chrono now().

        until: self isQuitting do: {
            let frameStartTicks := Stdn Chrono now().
            self pollAndPumpEvents.

            let ticksPerFrame := Stdn Chrono TicksPerSecond / targetFrameRate.

            let deltaTicks := frameStartTicks - oldTicks.
            accumulatedTicks := accumulatedTicks + deltaTicks.

            let deterministicFrameCount := accumulatedTicks / ticksPerFrame.
            accumulatedTicks := deterministicFrameCount - deterministicFrameCount*ticksPerFrame.

            ## Send the tick events
            {
                let event mutable type: TickEvent.
                event
                    ticks: frameStartTicks - mainLoopStartTicks;
                    deterministicDelta: ticksPerFrame;
                    deterministicRemainingDelta: accumulatedTicks;
                    deterministicFrameCount: (deterministicFrameCount castTo: UInt32);
                    delta: deltaTicks.
                self broadcastEvent: event.
            }.

            targetFrameRate > 0 ifTrue: {
                let targetNextFrameTime := frameStartTicks + ticksPerFrame.
                Stdn Chrono sleepUntil(targetNextFrameTime)
            } ifFalse: {
                self waitForNextEventOrTimeout.
            }.

            oldTicks := frameStartTicks.
        }.

        return: 0
    }.

    #**
     * Poll for events non-blockingly and then pump the events into the actual windows.
     *#
    virtual method pollAndPumpEvents => Void := {

    }.

    #**
     * Wait and pump the next, or until something times out.
     *#
    virtual method waitForNextEventOrTimeout => Void := {

    }.

    #**
     * Broadcast and event into all of the windows.
     *#
    virtual method broadcastEvent: (event: Event ref) ::=> Void := {

    }.
}.


}. ## End of namespace GUI
}. ## End of namespace Graphics
}. ## End of namespace Stdn
