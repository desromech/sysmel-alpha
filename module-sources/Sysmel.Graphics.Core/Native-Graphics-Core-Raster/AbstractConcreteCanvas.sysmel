namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math LinearAlgebra.
useNamespace: Stdn Math Geometry.

#**
 * I am a canvas that provides the bare minimum boiler plater facilities.
 *#
class AbstractConcreteCanvas superclass: Canvas; definition: {
    protected field transform type: AffinePostTransform2dF32.
    protected field currentFontFaceWithSize type: FontFaceWithSize sharedPointer.

    protected field currentClipRectangle type: RectangleF32.

    protected field currentStartPosition type: Float32x2.
    protected field currentStartColor type: Float32x4.

    protected field currentEndPosition type: Float32x2.
    protected field currentEndColor type: Float32x4.
    protected field currentGradientVector type: Float32x2.

    protected field blendingMode type: BlendingMode.

    method resetCanvasState => Void := {
        blendingMode := BlendingMode AlphaOver.
        currentClipRectangle := RectangleF32 fullSpace.
        transform setIdentity.
    }.

    override method transform => AffinePostTransform2dF32
        := transform.

    override method transform: (aTransform: AffinePostTransform2dF32) ::=> Void := {
        transform := aTransform
    }.

    override method blendingMode: (newMode: BlendingMode) ::=> Void := {
        blendingMode := newMode
    }.

    inline method isFullyTransparent => Boolean8
        := currentStartColor a <= 0.0f && currentEndColor a <= 0.0f.

    override method color: (srgbColor: UInt8x4) ::=> Void := {
        self color: Stdn Math Color decodeSRGBUnorm8(srgbColor)
    }.

    override method color: (linearColor: Float32x4) ::=> Void := {
        self linearGradientStart: linearColor position: Float32x2 zeros end: linearColor position: Float32x2 zeros.
    }.

    override method linearGradientStart: (startColor: UInt8x4) position: (startPosition: Float32x2) end: (endColor: UInt8x4) position: (endPosition: Float32x2) ::=> Void := {
        self linearGradientStart: Stdn Math Color decodeSRGBUnorm8(startColor)
            position: startPosition end: Stdn Math Color decodeSRGBUnorm8(endColor) position: endPosition
    }.

    ## This sets the current active color. The color is in the linear RGB space.
    override method linearGradientStart: (startColor: Float32x4) position: (startPosition: Float32x2) end: (endColor: Float32x4) position: (endPosition: Float32x2) ::=> Void := {
        currentStartColor := startColor.
        currentEndColor := endColor.
        currentStartPosition := transform transformPoint: startPosition.
        currentEndPosition := transform transformPoint: endPosition.

        let v := endPosition - startPosition.
        let l2 := v length2.
        (l2 closeTo: 0.0) ifTrue: {
            currentGradientVector := 0.0f.
        } ifFalse: {
            currentGradientVector := v / l2.
        }.
    }.

    const inline method evaluatePaintColorAt: (position: Float32x2) ::=> Float32x4 := {
        let alpha := (position - currentStartPosition) dot: currentGradientVector.
        currentStartColor interpolateTo: currentEndColor at: (alpha clampMin: 0.0f max: 1.0f)
    }.

    ## Sets the current font face with size.
    override method fontFaceWithSize: (font: FontFaceWithSize sharedPointer const ref) ::=> Void := {
        currentFontFaceWithSize := font.
    }.

    override method drawCharacterWithState: (state: TextDrawingState) ::=> TextDrawingState := {
        currentFontFaceWithSize ifNil: {
            return: state.
        }.

        let newState mutable := currentFontFaceWithSize _ computeNewDrawingState: state.
        newState isVisibleCharacter ifTrue: {
            ## Get the glyph for the character
            let glyph := currentFontFaceWithSize _ getOrCreateGlyphForCodePoint: newState character.
            glyph ifNil: {
                return: newState
            }.

            ## Convert the glyph into a form. We can always do this operation with fonts.
            self drawGlyph: glyph _ at: newState previousPosition.
        }.

        return: newState.
    }.

    abstract method doSetClipRectangle: (aRectangle: RectangleF32) ::=> Void.
    
    override method currentClipRectangle => RectangleF32 := {
        currentClipRectangle
    }.

    override method applyClipRectangle: (aRectangle: RectangleF32) ::=> Void := {
        currentClipRectangle := currentClipRectangle intersectionWith: aRectangle.
        self doSetClipRectangle: currentClipRectangle.
    }.

    override method restoreClipRectangle: (aRectangle: RectangleF32) ::=> Void := {
        currentClipRectangle := aRectangle.
        self doSetClipRectangle: currentClipRectangle.
    }.

}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
