namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math LinearAlgebra.
useNamespace: Stdn Math Geometry.

class FontFaceWithSize.

#**
 * I am an abstract rendering canvas interface. I could be implemented through
 * CPU based software rendering, or I could be implemented through a hardware based accelerator.
 *#
class Canvas superclass: Object; definition: {
    public field transform type: AffinePostTransform2dF32.

    ## This method clears the whole surface with the active color.
    abstract method clear ::=> Void.

    ## This method sets a white color.
    virtual method white ::=> Void := {
        self color: Float32x4 ones
    }.

    ## This method sets a black color.
    virtual method black ::=> Void := {
        self color: Float32x4(0.0f, 0.0f, 0.0f, 1.0f)
    }.

    ## This method sets a transparent color.
    virtual method transparent ::=> Void := {
        self color: Float32x4 zeros
    }.

    ## This sets the current blending mode.
    abstract method blendingMode: (mode: BlendingMode) ::=> Void.

    ## This sets the current active color. The color is in the sRGB space.
    abstract method color: (srgbColor: UInt8x4) ::=> Void.

    ## This sets the current active color. The color is in the linear RGB space.
    abstract method color: (linearColor: Float32x4) ::=> Void.

    ## This sets the current active color. The color is in the sRGB space.
    virtual method linearGradientStart: (startColor: UInt8x4) position: (startPosition: Float32x2)
        end: (endColor: UInt8x4) position: (endPosition: Float32x2) ::=> Void := {
            self color: startColor
    }.

    ## This sets the current active color. The color is in the linear RGB space.
    virtual method linearGradientStart: (startColor: Float32x4) position: (startPosition: Float32x2)
        end: (endColor: Float32x4) position: (endPosition: Float32x2) ::=> Void := {
            self color: startColor
    }.

    ## Fill a triangle.
    abstract method fillTriangle: (p1: Float32x2) color: (c1: Float32x4) tc: (tc1: Float32x2)
        p2: (p2: Float32x2) color: (c2: Float32x4) tc: (tc2: Float32x2)
        p3: (p3: Float32x2) color: (c3: Float32x4) tc: (tc3: Float32x2) ::=> Void.

    inline method fillTriangle: (p1: Float32x2) color: (c1: Float32x4) p2: (p2: Float32x2) color: (c2: Float32x4) p3: (p3: Float32x2) color: (c3: Float32x4)::=> Void := {
        self fillTriangle: p1 color: c1 tc: Float32x2 zeros
            p2: p2 color: c2 tc: Float32x2 zeros
            p3: p3 color: c3 tc: Float32x2 zeros
    }.

    inline method fillTriangle: (p1: Float32x2) p2: (p2: Float32x2) p3: (p3: Float32x2) ::=> Void := {
        self fillTriangle: p1 color: Float32x4 ones tc: Float32x2 zeros
            p2: p2 color: Float32x4 ones tc: Float32x2 zeros
            p3: p3 color: Float32x4 ones tc: Float32x2 zeros
    }.

    ## Fill a rectangle with a horizontal gradient.
    inline method fillRectangle: (rectangle: RectangleF32) verticalGradientStart: (startColor: Float32x4) end: (endColor: Float32x4) ::=> Void := {
        self
            linearGradientStart: startColor position: rectangle min end: endColor position: Float32x2(rectangle min x, rectangle max y);
            fillRectangle: rectangle
    }.

    ## Fill a rectangle with a horizontal gradient.
    inline method fillRectangle: (rectangle: RectangleF32) horizontalGradientStart: (startColor: Float32x4) end: (endColor: Float32x4) ::=> Void := {
        self
            linearGradientStart: startColor position: rectangle min end: endColor position: Float32x2(rectangle max x, rectangle min y);
            fillRectangle: rectangle
    }.

    ## Draw the rectangle lines.
    abstract method drawSegmentStart: (startPoint: Float32x2) end: (endPoint: Float32x2) ::=> Void.

    ## Fill a rectangle.
    abstract method fillRectangle: (rectangle: RectangleF32) ::=> Void.

    ## Draw the rectangle lines.
    virtual method drawRectangle: (rectangle: RectangleF32) ::=> Void := {
        rectangle isEmpty ifTrue: {
            return: void.
        }.

        let inclusiveRectangle := RectangleF32 min: rectangle min max: ((rectangle max - 1) max: rectangle min).

        self
            drawSegmentStart: inclusiveRectangle bottomLeft end: inclusiveRectangle bottomRight;
            drawSegmentStart: inclusiveRectangle bottomRight end: inclusiveRectangle topRight;
            drawSegmentStart: inclusiveRectangle topRight end: inclusiveRectangle topLeft;
            drawSegmentStart: inclusiveRectangle topLeft end: inclusiveRectangle bottomLeft.
    }.

    ## Copy the pixels of a texture without any transformation.
    abstract method copyTexture: (textureView: TextureView sharedPointer const ref) at: (targetPosition: Float32x2) ::=> Void.

    ## Sets the current font face with size.
    abstract method fontFaceWithSize: (font: FontFaceWithSize sharedPointer const ref) ::=> Void.

    ## Draws a character with the font face and size. This returns the position for drawing the next character.
    virtual method drawCharacter: (character: Char32) withState: (state: TextDrawingState) ::=> TextDrawingState
        := state.

    ## Draw an UTF-8 encoded string. Allow overriding for optiomization reasons.
    virtual method drawUTF8String: (encodedString: Char8 const pointer) size: (encodedStringSize: UIntPointer) withState: (state: TextDrawingState) ::=> TextDrawingState := {
        let currentState mutable := state.

        ## TODO: Properly decode the utf8 encoded string by using a stream and an iterator.
        0 until: encodedStringSize do: {:(UIntPointer)i :: Void |
            currentState := self drawCharacter: encodedString[i] withState: currentState.
        }.

        currentState
    }.

    inline method drawUTF8String: (encodedString: Char8 const pointer) size: (encodedStringSize: UIntPointer) at: (position: Float32x2) ::=> TextDrawingState
        := self drawUTF8String: encodedString size: encodedStringSize
            withState: (TextDrawingState position: position).

    inline method drawUTF8String: (string: Stdn String const ref) at: (position: Float32x2) ::=> TextDrawingState
        := self drawUTF8String: string data size: string size at: position.

    inline method drawUTF8String: (encodedString: Char8 const pointer) at: (position: Float32x2) ::=> TextDrawingState
        := self drawUTF8String: encodedString size: Stdn cstrlen(encodedString) at: position.
}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
