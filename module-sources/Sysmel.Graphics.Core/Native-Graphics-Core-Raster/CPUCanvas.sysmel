namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math Geometry.

class CPUSurface.

#**
 * I am a software based rendering CPU canvas that draws into CPUSurface.
 *#
class CPUCanvas superclass: Canvas; definition: {
    protected field targetSurface type: CPUSurface pointer.

    protected field currentStartPosition type: Float32x2.
    protected field currentStartColor type: Float32x4.

    protected field currentEndPosition type: Float32x2.
    protected field currentEndColor type: Float32x4.
    protected field currentGradientVector type: Float32x2.

    protected field currentFontFaceWithSize type: FontFaceWithSize sharedPointer.
    protected field blendingMode type: BlendingMode.

    method initializeWithSurface: (theTargetSurface: CPUSurface pointer) ::=> Void := {
        blendingMode := BlendingMode AlphaOver.
        targetSurface := theTargetSurface.
        transform setIdentity.
    }.

    override method finalize => Void := {
        targetSurface ifNotNil: {
            targetSurface _ endDrawing
        }
    }.

    override method blendingMode: (newMode: BlendingMode) ::=> Void := {
        blendingMode := newMode
    }.

    override method clear ::=> Void := {
        targetSurface _ pixelsBlitter setAllPixelsToColor: currentStartColor
    }.

    override method color: (srgbColor: UInt8x4) ::=> Void := {
        self color: Stdn Math Color decodeSRGBUnorm8(srgbColor)
    }.

    override method color: (linearColor: Float32x4) ::=> Void := {
        self linearGradientStart: linearColor position: Float32x2 zeros end: linearColor position: Float32x2 zeros.
    }.

    override method linearGradientStart: (startColor: UInt8x4) position: (startPosition: Float32x2) end: (endColor: UInt8x4) position: (endPosition: Float32x2) ::=> Void := {
        self linearGradientStart: Stdn Math Color decodeSRGBUnorm8(startColor)
            position: startPosition end: Stdn Math Color decodeSRGBUnorm8(endColor) position: endPosition
    }.

    ## This sets the current active color. The color is in the linear RGB space.
    override method linearGradientStart: (startColor: Float32x4) position: (startPosition: Float32x2) end: (endColor: Float32x4) position: (endPosition: Float32x2) ::=> Void := {
        currentStartColor := startColor.
        currentEndColor := endColor.
        currentStartPosition := transform transformPoint: startPosition.
        currentEndPosition := transform transformPoint: endPosition.

        let v := endPosition - startPosition.
        let l2 := v length2.
        (l2 closeTo: 0.0) ifTrue: {
            currentGradientVector := 0.0f.
        } ifFalse: {
            currentGradientVector := v / l2.
        }.
    }.

    const inline method evaluatePaintColorAt: (position: Float32x2) ::=> Float32x4 := {
        let alpha := (position - currentStartPosition) dot: currentGradientVector.
        currentStartColor interpolateTo: currentEndColor at: (alpha clampMin: 0.0f max: 1.0f)
    }.

    override method fillTriangle: (p1: Float32x2) color: (c1: Float32x4) tc: (tc1: Float32x2)
        p2: (p2: Float32x2) color: (c2: Float32x4) tc: (tc2: Float32x2)
        p3: (p3: Float32x2) color: (c3: Float32x4) tc: (tc3: Float32x2) ::=> Void := {

        let tp1 := transform transformPoint: p1.
        let tp2 := transform transformPoint: p2.
        let tp3 := transform transformPoint: p3.

        let mc1 := c1 * (self evaluatePaintColorAt: p1).
        let mc2 := c2 * (self evaluatePaintColorAt: p2).
        let mc3 := c3 * (self evaluatePaintColorAt: p3).

        targetSurface _ pixelsBlitter
            blendTriangle: tp1 p2: tp2 p3: tp3 pixelsWith: {:(Float32x2)p :(Float32x3)barycentricCoordinates :(Float32x4)originalDestPixelValue :: Float32x4 |
            let interpolatedColor := mc1*barycentricCoordinates x + mc2*barycentricCoordinates y + mc3*barycentricCoordinates z.
            interpolatedColor
        }
    }.

    override method fillRectangle: (rectangle: RectangleF32) ::=> Void := {
        transform isTranslationOnly ifTrue: {
            let transformedRectangle := rectangle translatedBy: transform translation.
            let convertedRectangle := RectangleI32 min: (transformedRectangle min floor castTo: Int32x2) max: (transformedRectangle max floor castTo: Int32x2).

            targetSurface _ pixelsBlitter
                blendRectangle: convertedRectangle pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
                self evaluatePaintColorAt: (destPixelCoordinate castTo: Float32x2)
            }

        } ifFalse: {
            self
                fillTriangle: rectangle bottomLeft p2: rectangle bottomRight p3: rectangle topRight;
                fillTriangle: rectangle topRight p2: rectangle topLeft p3: rectangle bottomLeft
        }.
    }.

    ## Draw the rectangle lines.
    override method drawSegmentStart: (startPoint: Float32x2) end: (endPoint: Float32x2) ::=> Void := {
        let transformedStartPoint := transform transformPoint: startPoint.
        let transformedEndPoint := transform transformPoint: endPoint.
        targetSurface _ pixelsBlitter
            blendSegmentStart: (transformedStartPoint floor castTo: Int32x2) end: (transformedEndPoint floor castTo: Int32x2) pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
            self evaluatePaintColorAt: (destPixelCoordinate castTo: Float32x2)
        }
    }.

    override method copyTexture: (textureView: TextureView sharedPointer const ref) at: (targetPosition: Float32x2) ::=> Void := {
        let cpuTextureView := textureView getPointer castTo: CPUTextureView pointer.

        let sourceBlitter := cpuTextureView _ pixelsBlitter.
        targetSurface _ pixelsBlitter
            compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentStartColor at: (targetPosition floor castTo: Int32x2)
    }.

    ## Sets the current font face with size.
    override method fontFaceWithSize: (font: FontFaceWithSize sharedPointer const ref) ::=> Void := {
        currentFontFaceWithSize := font.
    }.

    ## Draws a character with the font face and size. This returns the position for drawing the next character.
    override method drawCharacter: (character: Char32) withState: (state: TextDrawingState) ::=> TextDrawingState := {
        let newState mutable := state.

        currentFontFaceWithSize ifNil: {
            return: newState.
        }.

        ## Apply the kerning.
        newState previousCharacter ~= 0 ifTrue: {
            let kerningDelta := currentFontFaceWithSize _ getKerningForCharacter: newState previousCharacter with: character.
            ## Stdn stdout << "kerningDelta " << kerningDelta; nl.
            newState currentPosition: newState currentPosition + kerningDelta.
        }.
        newState previousCharacter: character.

        ## Get the glyph for the character
        let glyph := currentFontFaceWithSize _ getOrCreateGlyphForCodePoint: character.
        glyph ifNil: {
            return: newState
        }.

        ## Convert the glyph into a form. We can always do this operation with fonts.
        let form := glyph _ asForm.
        form ifNotNil: {
            let sourceBlitter := form _ makeBlitter.
            let drawPosition := transform transformPoint: newState currentPosition + glyph _ drawOrigin.
            targetSurface _ pixelsBlitter
                compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentStartColor
                at: (drawPosition floor castTo: Int32x2).
        }.

        newState currentPosition: newState currentPosition + glyph _ horizontalAdvance.
        return: newState.
    }.
}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
