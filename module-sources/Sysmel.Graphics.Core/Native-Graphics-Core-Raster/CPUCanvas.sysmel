namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math Geometry.

class CPUSurface.

#**
 * I am a software based rendering CPU canvas that draws into CPUSurface.
 *#
class CPUCanvas superclass: Canvas; definition: {
    protected field targetSurface type: CPUSurface pointer.
    protected field currentColor type: Float32x4.
    protected field currentFontFaceWithSize type: FontFaceWithSize sharedPointer.
    protected field blendingMode type: BlendingMode.

    method initializeWithSurface: (theTargetSurface: CPUSurface pointer) ::=> Void := {
        blendingMode := BlendingMode AlphaOver.
        targetSurface := theTargetSurface.
    }.

    override method finalize => Void := {
        targetSurface ifNotNil: {
            targetSurface _ endDrawing
        }
    }.

    override method clear ::=> Void := {
        targetSurface _ pixelsBlitter setAllPixelsToColor: currentColor
    }.

    override method color: (srgbColor: UInt8x4) ::=> Void := {
        ## TODO: Perform the sRGB -> linear conversion.
        self color: (srgbColor castTo: Float32x4) / 255.0f
    }.

    override method color: (linearColor: Float32x4) ::=> Void := {
        currentColor := linearColor.
    }.

    override method fillTriangle: (p1: Float32x2) color: (c1: Float32x4) tc: (tc1: Float32x2)
        p2: (p2: Float32x2) color: (c2: Float32x4) tc: (tc2: Float32x2)
        p3: (p3: Float32x2) color: (c3: Float32x4) tc: (tc3: Float32x2) ::=> Void := {

        targetSurface _ pixelsBlitter
            blendTriangle: p1 p2: p2 p3: p3 pixelsWith: {:(Float32x2)p :(Float32x3)barycentricCoordinates :(Float32x4)originalDestPixelValue :: Float32x4 |
            let interpolatedColor := c1*barycentricCoordinates x + c2*barycentricCoordinates y + c3*barycentricCoordinates z.
            interpolatedColor * currentColor
        }
    }.

    override method fillRectangle: (rectangle: RectangleF32) ::=> Void := {
        let convertedRectangle := RectangleI32 min: (rectangle min floor castTo: Int32x2) max: (rectangle max floor castTo: Int32x2).

        targetSurface _ pixelsBlitter
            blendRectangle: convertedRectangle pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
            currentColor
        }
    }.

    ## Draw the rectangle lines.
    override method drawSegmentStart: (startPoint: Float32x2) end: (endPoint: Float32x2) ::=> Void := {
        targetSurface _ pixelsBlitter
            blendSegmentStart: (startPoint floor castTo: Int32x2) end: (endPoint floor castTo: Int32x2) pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
            currentColor
        }
    }.

    override method copyTexture: (textureView: TextureView sharedPointer const ref) at: (targetPosition: Float32x2) ::=> Void := {
        ## Fixme: use a normal downcast here.
        let cpuTextureView := textureView getPointer reinterpretCastTo: CPUTextureView pointer.

        let sourceBlitter := cpuTextureView _ pixelsBlitter.
        targetSurface _ pixelsBlitter
            compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentColor at: (targetPosition floor castTo: Int32x2)
    }.

    ## Sets the current font face with size.
    override method fontFaceWithSize: (font: FontFaceWithSize sharedPointer const ref) ::=> Void := {
        currentFontFaceWithSize := font.
    }.

    ## Draws a character with the font face and size. This returns the position for drawing the next character.
    override method drawCharacter: (character: Char32) withState: (state: TextDrawingState) ::=> TextDrawingState := {
        let newState mutable := state.

        currentFontFaceWithSize ifNil: {
            return: newState.
        }.

        ## Apply the kerning.
        newState previousCharacter ~= 0 ifTrue: {
            let kerningDelta := currentFontFaceWithSize _ getKerningForCharacter: newState previousCharacter with: character.
            ## Stdn stdout << "kerningDelta " << kerningDelta; nl.
            newState currentPosition: newState currentPosition + kerningDelta.
        }.
        newState previousCharacter: character.

        ## Get the glyph for the character
        let glyph := currentFontFaceWithSize _ getOrCreateGlyphForCodePoint: character.
        glyph ifNil: {
            return: newState
        }.

        ## Convert the glyph into a form. We can always do this operation with fonts.
        let form := glyph _ asForm.
        form ifNotNil: {
            let sourceBlitter := form _ makeBlitter.
            targetSurface _ pixelsBlitter
                compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentColor
                at: ((newState currentPosition + glyph _ drawOrigin) floor castTo: Int32x2).
        }.

        newState currentPosition: newState currentPosition + glyph _ horizontalAdvance.
        return: newState.
    }.
}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
