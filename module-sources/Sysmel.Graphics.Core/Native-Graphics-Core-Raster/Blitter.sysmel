namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math Geometry.

class UnsafePixelIterator definition: {
    public field pixels type: UInt8 pointer.
    public field pitch type: Int32.
    public field bytesPerPixel type: UInt32.
    public field pixelFormat type: PixelFormat.

    inline method advanceColumn => Void := {
        pixels := pixels + bytesPerPixel
    }.

    inline method advanceColumns: (deltaX: Int32) ::=> Void := {
        pixels := pixels + (deltaX*bytesPerPixel)
    }.

    inline method advanceRow => Void := {
        pixels := pixels + pitch
    }.

    inline method advanceRows: (deltaY: Int32) ::=> Void := {
        pixels := pixels + (deltaY*pitch)
    }.

    inline method advanceRows: (deltaY: Int32) columns: (deltaX: Int32) ::=> Void := {
        pixels := pixels + (deltaY*pitch + deltaX*bytesPerPixel)
    }.

    inline method advanceCoordinates: (coords: Int32x2) ::=> Void := {
        self advanceRows: coords y columns: coords x
    }.

    method storePixelUNorm8x4: (rawNewValue: UInt8x4) ::=> Void := {
        let newValue := pixelFormat swizzleStoringUnorm8x4: rawNewValue.

        bytesPerPixel selectCase: #{
        1 : {
            pixels _ := newValue r.
        }.
        2 : {
            (pixels reinterpretCastTo: UInt8x2 pointer) _  := newValue rg.
        }.
        3 : {
            pixels[0] := newValue r.
            pixels[1] := newValue g.
            pixels[2] := newValue b.
        }.
        4 : {
            (pixels reinterpretCastTo: UInt8x4 pointer) _  := newValue.
        }.
        }.
    }.

    method storePixelFloat32x4: (newValue: Float32x4) ::=> Void := {
        bytesPerPixel <= 4 ifTrue: {
            let convertedPixelValue := (pixelFormat encodeColorSpace: (newValue clampMin: 0.0f max: 1.0f)) * 255.0f castTo: UInt8x4.
            self storePixelUNorm8x4: convertedPixelValue.
            return: nil.
        }.
    }.

    method loadPixelUNorm8x4 => UInt8x4 := {
        let result mutable := UInt8x4 zeros.
        bytesPerPixel selectCase: #{
        1 : {
            result := UInt8x4(pixels[0], 0, 0, 255).
        }.
        2 : {
            result := UInt8x4(pixels[0], pixels[1], 0, 255).
        }.
        3 : {
            result := UInt8x4(pixels[0], pixels[1], pixels[2], 255).
        }.
        4 : {
            result := (pixels reinterpretCastTo: UInt8x4 pointer) _.
        }.
        }.

        pixelFormat swizzleLoadedUnorm8x4: result.
    }.

    method loadPixelFloat32x4 => Float32x4 := {
        bytesPerPixel <= 4 ifTrue: {
            return: (pixelFormat decodeColorSpace: (self loadPixelUNorm8x4 castTo: Float32x4) / 255.0f)
        }.

        return: Float32x4 zeros.
    }.
}.

#**
 * I am a 2D CPU based blitter for pixels. I encapsulate pixel accessing and
 * conversion operations, and I provide basic CPU based rasterization primitives.
 *#
class Blitter definition: {
    ## Hold a copy of the surface components.

    public field extent type: UInt32x2.
    public field pitch type: Int32.
    public field pixelFormat type: PixelFormat.
    public field pixels type: UInt8 pointer.

    const inline method bounds => RectangleI32
        := RectangleI32 extent: (extent castTo: Int32x2).

    field bytesPerPixel type: UInt32.

    compileTime constant UNorm8RenderBlockType := ((UInt32x2) => UInt8x4) nativeBlockClosure.
    compileTime constant Float32RenderBlockType := ((UInt32x2) => Float32x4) nativeBlockClosure.
    compileTime constant Float32BlendRenderBlockType := ((UInt32x2 -- Float32x4) => Float32x4) nativeBlockClosure.
    compileTime constant Float32BlendTriangleBlockType := ((Float32x2 -- Float32x3 -- Float32x4) => Float32x4) nativeBlockClosure.
    compileTime constant Float32BlendCopyBlockType := ((Int32x2 -- Float32x4 -- Float32x4) => Float32x4) nativeBlockClosure.
    compileTime constant Float32NormalizedRenderBlockType := ((Float32x2) => Float32x4) nativeBlockClosure.


    method initializeCachedState => Void := {
        bytesPerPixel := pixelFormat bytesPerPixel.
    }.

    const inline method makeUnsafePixelIterator => UnsafePixelIterator
        := UnsafePixelIterator basicNewValue
            pixels: pixels;
            pitch: pitch;
            bytesPerPixel: bytesPerPixel;
            pixelFormat: pixelFormat;
            yourself.

    const inline method makeUnsafePixelIteratorAt: (coordinates: Int32x2) ::=> UnsafePixelIterator
        := self makeUnsafePixelIterator advanceCoordinates: coordinates; yourself.


    const inline method setRectangle: (rectangle: RectangleI32) pixelsWith: (renderBlock: UNorm8RenderBlockType) ::=> Void := {
        let clippedRectangle := rectangle intersectionWith: self bounds.
        clippedRectangle isEmpty ifTrue: {
            Stdn stdout << "Empty clipped rectangle"; nl.
            return: void
        }.

        let destRow mutable := self makeUnsafePixelIteratorAt: clippedRectangle min.
        clippedRectangle min y until: clippedRectangle max y do: {:(Int32)y :: Void |
            let destPixel mutable := destRow.
            clippedRectangle min x until: clippedRectangle max x do: {:(Int32)x :: Void |
                destPixel storePixelUNorm8x4: renderBlock(Int32x2(x, y) castTo: UInt32x2).
                destPixel advanceColumn
            }.

            destRow advanceRow
        }
    }.

    const inline method setPixelsWith: (renderBlock: UNorm8RenderBlockType) ::=> Void := {
        self setRectangle: self bounds pixelsWith: renderBlock
    }.

    const inline method setRectangle: (rectangle: RectangleI32) pixelsWith: (renderBlock: Float32RenderBlockType) ::=> Void := {
        let clippedRectangle := rectangle intersectionWith: self bounds.
        clippedRectangle isEmpty ifTrue: {
            return: void
        }.

        let destRow mutable := self makeUnsafePixelIteratorAt: clippedRectangle min.
        clippedRectangle min y until: clippedRectangle max y do: {:(Int32)y :: Void |
            let destPixel mutable := destRow.
            clippedRectangle min x until: clippedRectangle max x do: {:(Int32)x :: Void |
                destPixel storePixelFloat32x4: renderBlock(Int32x2(x, y) castTo: UInt32x2).
                destPixel advanceColumn
            }.

            destRow advanceRow
        }
    }.

    const inline method blendRectangle: (rectangle: RectangleI32) pixelsWith: (renderBlock: Float32BlendRenderBlockType) ::=> Void := {
        let clippedRectangle := rectangle intersectionWith: self bounds.
        clippedRectangle isEmpty ifTrue: {
            return: void
        }.

        let destRow mutable := self makeUnsafePixelIteratorAt: clippedRectangle min.
        clippedRectangle min y until: clippedRectangle max y do: {:(Int32)y :: Void |
            let destPixel mutable := destRow.
            clippedRectangle min x until: clippedRectangle max x do: {:(Int32)x :: Void |
                destPixel storePixelFloat32x4: renderBlock(Int32x2(x, y) castTo: UInt32x2, destPixel loadPixelFloat32x4).
                destPixel advanceColumn
            }.

            destRow advanceRow
        }
    }.

    const inline method blendVerticalSegmentStart: (startPoint: Int32x2) end: (endPoint: Int32x2) pixelsWith: (renderBlock: Float32BlendRenderBlockType) ::=> Void := {
        let w := extent x castTo: Int32.
        0 <= startPoint x && startPoint x < w ifFalse: {
            return: void
        }.

        let x := startPoint x.
        let dy := startPoint y <= endPoint y ifTrue: 1 ifFalse: -1.
        let y mutable := startPoint y.

        let destPixel mutable := self makeUnsafePixelIteratorAt: Int32x2(x, y).
        let h := extent y castTo: Int32.
        while: y ~= endPoint y do: {
            0 <= y && y < h ifTrue: {
                destPixel storePixelFloat32x4: renderBlock(Int32x2(x, y) castTo: UInt32x2, destPixel loadPixelFloat32x4).
            }.
            destPixel advanceRows: dy.
            y := y + dy
        }.
    }.

    const inline method blendHorizontalSegmentStart: (startPoint: Int32x2) end: (endPoint: Int32x2) pixelsWith: (renderBlock: Float32BlendRenderBlockType) ::=> Void := {
        let h := extent x castTo: Int32.
        0 <= startPoint y && startPoint y < h ifFalse: {
            return: void
        }.

        let y := startPoint y.
        let dx := startPoint x <= endPoint x ifTrue: 1 ifFalse: -1.
        let x mutable := startPoint x.
        let destPixel mutable := self makeUnsafePixelIteratorAt: Int32x2(x, y).
        let w := extent x castTo: Int32.
        while: x ~= endPoint x do: {
            0 <= x && x < w ifTrue: {
                destPixel storePixelFloat32x4: renderBlock(Int32x2(x, y) castTo: UInt32x2, destPixel loadPixelFloat32x4).
            }.
            destPixel advanceColumns: dx.
            x := x + dx
        }.
    }.

    const inline method blendSegmentStart: (startPoint: Int32x2) end: (endPoint: Int32x2) pixelsWith: (renderBlock: Float32BlendRenderBlockType) ::=> Void := {
        ## Vertical line
        startPoint x == endPoint x ifTrue: {
            self blendVerticalSegmentStart: startPoint end: endPoint pixelsWith: renderBlock.
            return: void
        }.

        ## Horizontal line
        startPoint y == endPoint y ifTrue: {
            self blendHorizontalSegmentStart: startPoint end: endPoint pixelsWith: renderBlock.
            return: void
        }.

        ## TODO: Add proper clipping support for the segment.
        ## Bresenham algorithm from: https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm [April 2th, 2020]
        let delta := endPoint - startPoint.
        let d := Int32x2(delta x abs, delta y abs negated).
        let step := delta sign.

        let currentPoint mutable := startPoint.
        let currentError mutable := d x + d y.
        let destPixel mutable := self makeUnsafePixelIteratorAt: currentPoint.
        let myBounds := self bounds.
        while: currentPoint x ~= endPoint x || currentPoint y ~= endPoint y do: {
            (myBounds includesPoint: currentPoint) ifTrue: {
                destPixel storePixelFloat32x4: renderBlock(currentPoint castTo: UInt32x2, destPixel loadPixelFloat32x4).
            }.

            let e2 := currentError * 2.
            e2 >= d y ifTrue: {
                currentError := currentError + d y.
                currentPoint := Int32x2(currentPoint x + step x, currentPoint y).
                destPixel advanceColumns: step x.
            }.
            e2 <= d x ifTrue: {
                currentError := currentError + d x.
                currentPoint := Int32x2(currentPoint x, currentPoint y + step y).
                destPixel advanceRows: step y.
            }.
        }.
    }.

    const inline method blendSegmentStart: (startPoint: Float32x2) end: (endPoint: Float32x2) pixelsWith: (renderBlock: Float32BlendRenderBlockType) ::=> Void := {
        self blendSegmentStart: (startPoint floor castTo: Int32x2) end: (endPoint castTo: Int32x2) pixelsWith: renderBlock
    }.

    const inline method blendTriangle: (p1: Float32x2) p2: (p2: Float32x2) p3: (p3: Float32x2) pixelsWith: (renderBlock: Float32BlendTriangleBlockType) ::=> Void := {
        let rectangle := RectangleF32 min: (p1 min: (p2 min: p3))
            max: (p1 max: (p2 max: p3)).

        let clippedRectangle := rectangle intersectionWith: (RectangleF32 extent: (extent castTo: Float32x2)).
        clippedRectangle isEmpty ifTrue: {
            return: void
        }.

        let triangleArea := p2 - p1 cross: p3 - p1.
        triangleArea = 0.0f ifTrue: {
            return: void
        }.

        let den := 1.0f / triangleArea.

        ## FIXME: optimize properly this rendering loop.

        let fractionalOffset := clippedRectangle min fract.
        let clippedRectangleI := RectangleI32 min: (clippedRectangle min floor castTo: Int32x2) max: (clippedRectangle max floor castTo: Int32x2).
        let destRow mutable := self makeUnsafePixelIteratorAt: clippedRectangleI min.
        clippedRectangleI min y until: clippedRectangleI max y do: {:(Int32)y :: Void |
            let destPixel mutable := destRow.
            clippedRectangleI min x until: clippedRectangleI max x do: {:(Int32)x :: Void |
                let p := Float32x2(x, y).## + fractionalOffset.

                let w3 := (p2 - p1 cross: p - p1)*den.
                let w1 := (p3 - p2 cross: p - p2)*den.
                let w2 := (p1 - p3 cross: p - p3)*den.
                let barycentricCoordinates := Float32x3(w1, w2, w3).

                w1 >= 0 && w2 >= 0 && w3 >= 0 ifTrue: {
                    destPixel storePixelFloat32x4: renderBlock(p, Float32x3(w1, w2, w3), destPixel loadPixelFloat32x4).
                }.
                destPixel advanceColumn
            }.

            destRow advanceRow
        }
    }.

    const inline method setPixelsWith: (renderBlock: Float32RenderBlockType) ::=> Void := {
        self setRectangle: self bounds pixelsWith: renderBlock
    }.

    ## This one is used for generating procedural textures
    const inline method setPixelsWith: (renderBlock: Float32NormalizedRenderBlockType) ::=> Void := {
        self setPixelsWith: {:(UInt32x2)pixelCoord :: Float32x4 |
            let normalizedCoord := (pixelCoord castTo: Float32x2) / (extent castTo: Float32x2).
            renderBlock(normalizedCoord)
        }
    }.

    const inline method setAllPixelsToColor: (color: UInt8x4) ::=> Void := {
        self setPixelsWith: {:(UInt32x2)pixelCoord :: UInt8x4 |
            color
        }
    }.

    const inline method setAllPixelsToColor: (color: Float32x4) ::=> Void := {
        self setPixelsWith: {:(UInt32x2)pixelCoord :: Float32x4 |
            color
        }
    }.

    const inline method copyPixelsFrom: (sourceBlitter: Blitter const ref) at: (source: RectangleI32)
        into: (destinationPosition: Int32x2) ::=> Void := {

        ## Clip the source rectangle.
        let clippedSourceRectangle := source intersectionWith: sourceBlitter bounds.
        clippedSourceRectangle isEmpty ifTrue: {
            return: void
        }.

        ## Compute the destination rectangle.
        let destinationRectangle := RectangleI32 min: destinationPosition max: destinationPosition + clippedSourceRectangle extent.
        let clippedDestinationRectangle := destinationRectangle intersectionWith: self bounds.
        clippedDestinationRectangle isEmpty ifTrue: {
            return: void
        }.

        let sourceClippedLocation := clippedSourceRectangle min + (clippedDestinationRectangle min - destinationPosition).
        ##let copyExtent := clippedDestinationRectangle extent.

        let sourceRow mutable := sourceBlitter makeUnsafePixelIteratorAt: sourceClippedLocation.
        let destRow mutable := self makeUnsafePixelIteratorAt: clippedDestinationRectangle min.
        clippedDestinationRectangle min y until: clippedDestinationRectangle max y do: {:(Int32)y :: Void |
            let sourcePixel mutable := sourceRow.
            let destPixel mutable := destRow.
            clippedDestinationRectangle min x until: clippedDestinationRectangle max x do: {:(Int32)x :: Void |
                destPixel storePixelUNorm8x4: sourcePixel loadPixelUNorm8x4.

                sourcePixel advanceColumn.
                destPixel advanceColumn.
            }.

            sourceRow advanceRow.
            destRow advanceRow.
        }
    }.

    const inline method copyPixelsFrom: (sourceBlitter: Blitter const ref) into: (targetPosition: Int32x2) ::=> Void := {
        self copyPixelsFrom: sourceBlitter at: sourceBlitter bounds into: targetPosition.
    }.

    const inline method blendPixelsFrom: (sourceBlitter: Blitter const ref) at: (sourceRectangleMin: Int32x2) to: (sourceRectangleMax: Int32x2)
        at: (destinationPosition: Int32x2) with: (blendFunction: Float32BlendCopyBlockType)::=> Void := {

        ## Clip the source rectangle.
        let clippedSourceRectangleMin := sourceRectangleMin max: Int32x2(0, 0).
        let clippedSourceRectangleMax := sourceRectangleMax min: (sourceBlitter extent castTo: Int32x2).

        (clippedSourceRectangleMin x == clippedSourceRectangleMax x || clippedSourceRectangleMin y == clippedSourceRectangleMax y) ifTrue: {
            return: nil
        }.

        let sourceCopyExtent := clippedSourceRectangleMax - clippedSourceRectangleMin.

        ## Compute the destination rectangle.
        let destinationMin := destinationPosition.
        let destinationMax := destinationMin + sourceCopyExtent.
        let clippedDestinationMin := destinationMin max: Int32x2(0, 0).
        let clippedDestinationMax := destinationMax min: (extent castTo: Int32x2).

        (clippedDestinationMin x == clippedDestinationMax x || clippedDestinationMin y == clippedDestinationMax y) ifTrue: {
            return: nil
        }.

        let sourceClippedLocation := clippedSourceRectangleMin + (clippedDestinationMin - destinationMin).
        let copyExtent := clippedDestinationMax - clippedDestinationMin.

        let sourceRow mutable := sourceBlitter makeUnsafePixelIteratorAt: sourceClippedLocation.
        let destRow mutable := self makeUnsafePixelIteratorAt: clippedDestinationMin.
        clippedDestinationMin y until: clippedDestinationMax y do: {:(Int32)y :: Void |
            let sourcePixel mutable := sourceRow.
            let destPixel mutable := destRow.
            clippedDestinationMin x until: clippedDestinationMax x do: {:(Int32)x :: Void |
                let currentDestColor := destPixel loadPixelFloat32x4.
                let currentSourceColor := sourcePixel loadPixelFloat32x4.
                let computedDestColor := blendFunction(Int32x2(x, y), currentDestColor, currentSourceColor).

                destPixel storePixelFloat32x4: computedDestColor.

                sourcePixel advanceColumn.
                destPixel advanceColumn.
            }.

            sourceRow advanceRow.
            destRow advanceRow.
        }
    }.

    const inline method blendPixelsFrom: (sourceBlitter: Blitter const ref) at: (targetPosition: Int32x2) with: (blendFunction: Float32BlendCopyBlockType) ::=> Void := {
        self blendPixelsFrom: sourceBlitter at: Int32x2(0, 0) to: (sourceBlitter extent castTo: Int32x2)
            at: targetPosition with: blendFunction.
    }.

    const inline method compositeAlphaBlendPixelsFrom: (sourceBlitter: Blitter const ref) at: (sourceRectangleMin: Int32x2) to: (sourceRectangleMax: Int32x2)
        withColor: (modulationColor: Float32x4)
        at: (destinationPosition: Int32x2) ::=> Void := {

        self blendPixelsFrom: sourceBlitter at: sourceRectangleMin to: sourceRectangleMax
            at: destinationPosition with: {:(Int32x2)pixelCoord :(Float32x4)destColor :(Float32x4)sourceColor :: Float32x4 |
            let newColor := modulationColor * sourceColor.
            Float32x4((destColor rgb * (1.0f - newColor a)) + (newColor rgb * newColor a), destColor a + newColor a).
        }
    }.

    const inline method compositeAlphaBlendPixelsFrom: (sourceBlitter: Blitter const ref) withColor: (modulationColor: Float32x4) at: (targetPosition: Int32x2) ::=> Void := {
        self compositeAlphaBlendPixelsFrom: sourceBlitter at: Int32x2(0, 0) to: (sourceBlitter extent castTo: Int32x2)
            withColor: modulationColor
            at: targetPosition
    }.
}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
