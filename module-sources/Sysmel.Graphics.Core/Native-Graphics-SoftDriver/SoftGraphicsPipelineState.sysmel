namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

class SoftGraphicsPipeline superclass: GraphicsPipelineState; definition: {
	compileTime constant MaxColorAttachmentCount := SoftRenderPassExecutionContext MaxColorAttachmentCount.

	public field description type: GraphicsPipelineStateDescription.

	public field vertexShader type: GPU NativeVertexShaderEntryPointType pointer.
	public field fragmentShader type: GPU NativeFragmentShaderEntryPointType pointer.

	method fetchCachedPipelineState => Void := {
		(description vertexShader getPointer castTo: SoftShaderStageHandle pointer) ifNotNil: {:shaderStage :: Void |
			vertexShader := shaderStage _ entryPointInfo nativeShaderEntryPoint reinterpretCastTo: GPU NativeVertexShaderEntryPointType pointer
		}.

		(description fragmentShader getPointer castTo: SoftShaderStageHandle pointer) ifNotNil: {:shaderStage :: Void |
			fragmentShader := shaderStage _ entryPointInfo nativeShaderEntryPoint reinterpretCastTo: GPU NativeFragmentShaderEntryPointType pointer
		}.

	}.

	const method fillTriangleV1: (v1: GPU NativeVertexShaderIOInterface Outputs ref)
		v2: (v2: GPU NativeVertexShaderIOInterface Outputs ref)
		v3: (v3: GPU NativeVertexShaderIOInterface Outputs ref)
		graphicsRootDescriptorTable: (graphicsRootDescriptorTable: Void const pointer)
		renderPassExecutionContext: (renderPassExecutionContext: SoftRenderPassExecutionContext const ref) ::=> Void := {

		let colorAttachmentCount := (description colorAttachments size min: MaxColorAttachmentCount) min: renderPassExecutionContext colorAttachmentCount.
		let colorAttachmentDescriptions := description colorAttachments asArraySlice elements.

		let hasDepthTesting := description depthTestingEnabled.
		let depthWriteMask := description depthWriteMask.

		let colorRows mutable type: (UnsafePixelIterator array: MaxColorAttachmentCount).
		let colorPixels mutable type: (UnsafePixelIterator array: MaxColorAttachmentCount).
		let depthRow mutable type: UnsafePixelIterator.
		let depthPixel mutable type: UnsafePixelIterator.

		TriangleRasterizer()
			clippingBounds: renderPassExecutionContext clippingBounds;
			viewportExtent: (renderPassExecutionContext extent castTo: Float32x2);
			loopSetupFunction: {:(Int32x2)startPosition :: Void |
				0 until: colorAttachmentCount do: {:i :: Void |
					colorRows[i] := renderPassExecutionContext colorAttachmentBlitters[i] makeUnsafePixelIteratorAt: startPosition
				}.

				hasDepthTesting ifTrue: {
					depthRow := renderPassExecutionContext depthAttachmentBlitter makeUnsafePixelIteratorAt: startPosition.
				}.
			};
			rowSetupFunction: { :: Void |
				0 until: colorAttachmentCount do: {:i :: Void |
					colorPixels[i] := colorRows[i]
				}.

				hasDepthTesting ifTrue: {
					depthPixel := depthRow
				}.
			};
			rowAdvanceFunction: {:(Int32)delta :: Void |
				0 until: colorAttachmentCount do: {:i :: Void |
					colorRows[i] advanceRows: delta
				}.

				hasDepthTesting ifTrue: {
					depthRow advanceRows: delta
				}.
			};
			columnAdvanceFunction: {:(Int32)delta :: Void |
				0 until: colorAttachmentCount do: {:i :: Void |
					colorPixels[i] advanceColumns: delta
				}.

				hasDepthTesting ifTrue: {
					depthPixel advanceColumns: delta
				}.
			};
			pixelRenderFunction: (function (fragCoord: Float32x4, isFrontFacing: Boolean8, flatBarycentric: Float32x3, perspectiveBarycentric: Float32x3) => Void := {
				## Depth testing.
				hasDepthTesting ifTrue: {
					let depth ref := (depthPixel pixels reinterpretCastTo: Float32 pointer) _.
					(description depthFunction compare: fragCoord z with: depth) ifFalse: {
						return: void
					}.
				}.

				## TODO: Stencil testing.

				fragmentShader ifNotNil: {
					let fragment mutable type: GPU NativeFragmentShaderIOInterface.

					## Invoke the fragment shader.
					{
						fragment inputs
							fragCoord: fragCoord;
							isFrontFacing: isFrontFacing.
						0 until: 16 do: {:i :: Void |
							fragment inputs locations[i] := perspectiveBarycentric * (Float32x3x4 rows: (v1 locations[i], v2 locations[i], v3 locations[i])).
						}.

						fragmentShader(graphicsRootDescriptorTable reinterpretCastTo: Void pointer, fragment)
					}.

					## Write the outputs.
					0 until: colorAttachmentCount do: {:i :: Void |
						let attachmentDescription ref := colorAttachmentDescriptions[i].
						let colorMask := attachmentDescription colorMask.
						colorMask isAnySet ifTrue: {
							let fragmentColor := fragment outputs locations[i].
							colorMask isAllSet && attachmentDescription blendingEnabled not ifTrue: {
								colorPixels[i] storePixelFloat32x4: fragmentColor.
							} ifFalse: {
								let destinationColor := colorPixels[i] loadPixelFloat32x4.
								let blendedColor := attachmentDescription blendingEnabled ifTrue: {
									let alternateSource := fragment outputs locations[(i + 1) & 15].
									attachmentDescription blendingEquation evaluateWithSource: fragmentColor destination: destinationColor
										constantFactor: attachmentDescription blendingConstant alternateSource: alternateSource
								} ifFalse: {
									fragmentColor
								}.

								## Apply the color mask.
								let floatMask := colorMask castTo: Float32x4.
								let inverseFloatMask := Float32x4 ones - floatMask.
								let maskedColor := fragmentColor*floatMask + destinationColor*inverseFloatMask.

								## Write the masked color.
								colorPixels[i] storePixelFloat32x4: maskedColor.
							}.
						}.
					}.

					#*let fragmentColor := fragment outputs locations[0].
					let alternateSource := fragmentColor.
					let destinationColor := colorPixel loadPixelFloat32x4.

					let blendedColor := blendingEquation evaluateWithSource: fragmentColor destination: destinationColor
						constantFactor: blendingConstant alternateSource: alternateSource.

					colorPixel storePixelFloat32x4: blendedColor.*#
				}.

				hasDepthTesting && depthWriteMask ifTrue: {
					(depthPixel pixels reinterpretCastTo: Float32 pointer) _ := fragCoord z.
				}.
			});
			rasterizeTriangleNDC: v1 screenPosition p2: v2 screenPosition p3: v3 screenPosition.
	}.

#*	const method drawTriangle: (v1: GPU NativeVertexShaderIOInterface Outputs ref)
		v2: (v2: GPU NativeVertexShaderIOInterface Outputs ref)
		v3: (v3: GPU NativeVertexShaderIOInterface Outputs ref) ::=> Void := {

		fragmentShader ifNil: {
			return: void
		}.

		let colorRow mutable type: UnsafePixelIterator.
		let colorPixel mutable type: UnsafePixelIterator.
		let depthRow mutable type: UnsafePixelIterator.
		let depthPixel mutable type: UnsafePixelIterator.

		TringleRasterizer()
			clippingBounds: colorBufferBlitter clippedBounds;
			viewportExtent: (colorBufferBlitter extent castTo: Float32x2);
			loopSetupFunction: {:(Int32x2)startPosition :: Void |
				colorRow := colorBufferBlitter makeUnsafePixelIteratorAt: startPosition.
				depthRow := depthStencilBufferBlitter makeUnsafePixelIteratorAt: startPosition.
			};
			rowSetupFunction: { :: Void |
				colorPixel := colorRow.
				depthPixel := depthRow.
			};
			rowAdvanceFunction: {:(Int32)delta :: Void |
				colorRow advanceRows: delta.
				depthRow advanceRows: delta.
			};
			columnAdvanceFunction: {:(Int32)delta :: Void |
				colorPixel advanceColumns: delta.
				depthPixel advanceColumns: delta.
			};
			pixelRenderFunction: (function (fragCoord: Float32x4, isFrontFacing: Boolean8, flatBarycentric: Float32x3, perspectiveBarycentric: Float32x3) => Void := {
				let depth ref := (depthPixel pixels reinterpretCastTo: Float32 pointer) _.

				## Depth testing.
				(depthFunction compare: fragCoord z with: depth) ifFalse: {
					return: void
				}.

				## TODO: Stencil testing.
				let fragment mutable type: GPU NativeFragmentShaderIOInterface.
				{
					fragment inputs
						fragCoord: fragCoord;
						isFrontFacing: isFrontFacing.
					0 until: 16 do: {:i :: Void |
						fragment inputs locations[i] := perspectiveBarycentric * (Float32x3x4 rows: (v1 locations[i], v2 locations[i], v3 locations[i])).
					}.

					let shaderFunction := fragmentShader _ nativeShaderEntryPoint reinterpretCastTo: GPU NativeFragmentShaderEntryPointType pointer.
					shaderFunction(descriptorSetTable address, fragment)
				}.

				depth := fragCoord z.

				let fragmentColor := fragment outputs locations[0].
				let alternateSource := fragmentColor.
				let destinationColor := colorPixel loadPixelFloat32x4.

				let blendedColor := blendingEquation evaluateWithSource: fragmentColor destination: destinationColor
			        constantFactor: blendingConstant alternateSource: alternateSource.

				colorPixel storePixelFloat32x4: blendedColor.
			});
			rasterizeTriangleNDC: v1 screenPosition p2: v2 screenPosition p3: v3 screenPosition.
	}.

	const inline method invokeVertexShaderOn: (vertex: GPU NativeVertexShaderIOInterface ref) ::=> Void := {
		let shaderFunction := vertexShader _ nativeShaderEntryPoint reinterpretCastTo: GPU NativeVertexShaderEntryPointType pointer.
		shaderFunction(descriptorSetTable address, vertex)
	}.

	const method drawTriangleIndices: (i1: UInt32) i2: (i2: UInt32) i3: (i3: UInt32) instanceID: (instanceID: UInt32) ::=> Void := {
		let v1 mutable type: GPU NativeVertexShaderIOInterface.
		let v2 mutable type: GPU NativeVertexShaderIOInterface.
		let v3 mutable type: GPU NativeVertexShaderIOInterface.

		v1 inputs
			vertexID: (i1 castTo: Int32);
			instanceID: (instanceID castTo: Int32).
		v2 inputs
			vertexID: (i2 castTo: Int32);
			instanceID: (instanceID castTo: Int32).
		v3 inputs
			vertexID: (i3 castTo: Int32);
			instanceID: (instanceID castTo: Int32).
		vertexBinding ifNotNil: {
			vertexBinding _
				fetchVertex: i1 instanceID: instanceID into: v1 inputs;
				fetchVertex: i2 instanceID: instanceID into: v2 inputs;
				fetchVertex: i3 instanceID: instanceID into: v3 inputs.
		}.

		self
			invokeVertexShaderOn: v1;
			invokeVertexShaderOn: v2;
			invokeVertexShaderOn: v3;
			drawTriangle: v1 outputs v2: v2 outputs v3: v3 outputs.
	}.

*#
}.


}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
