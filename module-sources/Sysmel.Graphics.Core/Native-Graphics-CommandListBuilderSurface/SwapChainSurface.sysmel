namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math Geometry.

#**
 * I am a 2D rendering that takes care automatically of handling the underlying swap chain in a window.
 * I work by delegating my job into an actual SwapChainSurface
 *#
class SwapChainSurface superclass: Surface; definition: {
    protected field extent type: UInt32x2.
    protected field renderingQueue type: CommandQueuePtr.
    protected field swapChain type: SwapChainPtr.

    protected field device type: RenderingDevicePtr.
    protected field renderPasses type: Stdn Collections Vector(RenderPassPtr).
    protected field commandListAllocators type: Stdn Collections Vector(CommandListAllocatorPtr).
    protected field stateTrackers type: Stdn Collections Vector(StateTrackerPtr).

    protected field surfaces type: Stdn Collections Vector(StateTracker2DSurface sharedPointer).

    const method extent => UInt32x2
        := extent.

    const method swapChain => SwapChainPtr const ref
        := swapChain.

    meta definition: {
        method for: (swapChain: SwapChainPtr const ref) on: (theRenderingQueue: CommandQueuePtr const ref) on: (theDevice: RenderingDevicePtr const ref) withExtent: (anExtent: UInt32x2) ::=> SwapChainSurface sharedPointer := {
            let result := SwapChainSurface sharedNew.
            result _ initializeWithSwapChain: swapChain on: theRenderingQueue on: theDevice extent: anExtent.
            result
        }.
    }.

    method initializeWithSwapChain: (theSwapChain: SwapChainPtr const ref) on: (theRenderingQueue: CommandQueuePtr const ref) on: (theDevice: RenderingDevicePtr const ref) extent: (theExtent: UInt32x2) ::=> Void := {
        swapChain := theSwapChain.
        renderingQueue := theRenderingQueue.
        device := theDevice.
        extent := theExtent.

        let bufferCount := swapChain _ getFramebufferCount.
        commandListAllocators reserve: bufferCount.
        stateTrackers reserve: bufferCount.
        renderPasses reserve: bufferCount.
        surfaces reserve: bufferCount.
        0 until: bufferCount do: {:i :: Void |

            {
                let commandListAllocator := device _ createCommandAllocatorOfType: CommandListType Direct for: renderingQueue.
                let commandList := device _ createCommandListOfType: CommandListType Direct for: commandListAllocator.
                commandList _ close.

                commandListAllocators add: commandListAllocator.

                let stateTracker := GenericStateTracker sharedNew.
                stateTracker _
                    commandList: commandList;
                    shaderCache: device _ getDefaultShaderCache;
                    pipelineStateCache: device _ getDefaultPipelineStateCache.
                stateTrackers add: (stateTracker upCastFor: StateTracker)
            }.

            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: swapChain _ colorBufferFormat;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    clearValue: Float32x4(0, 0, 1, 1);
                    yourself
            ).

            let renderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: nil.
            renderPasses add: renderPass.

            let surface := StateTracker2DSurface sharedNew.
            surface _
                extent: extent;
                renderingDevice: device.
            surfaces add: surface.
        }.
    }.

    override method beginDrawingWithCanvas => Canvas uniquePointer := {
        let surface ref := surfaces[swapChain _ getCurrentBackBufferIndex].
        let result mutable := SwapChainSurfaceCanvas uniqueNew.
        result _ ownedCanvas: surface _ beginDrawingWithCanvas.
        result _ ownedCanvas ifNil: {
            return: Canvas uniquePointer nil
        }.

        result _
            ownerSurface: self address;
            delegatedCanvas: result _ ownedCanvas getPointer.

        Canvas uniquePointer for: result release
    }.

    method endDrawing => Void := {
        Stdn stdout << "SwapChainSurface endDrawing"; nl.
        let backBuffer := swapChain _ getCurrentBackBuffer.
        let backBufferIndex := swapChain _ getCurrentBackBufferIndex.

        let allocator ref := commandListAllocators[backBufferIndex].
        let renderPass ref := renderPasses[backBufferIndex].
        let stateTracker ref := stateTrackers[backBufferIndex].
        let surface ref := surfaces[backBufferIndex].

        allocator _ resetAllocator.
    	stateTracker _
            resetFor: allocator;
            beginRenderPass: renderPass on: backBuffer contentOnBundle: false;
    		setViewport: (RectangleI32 min: Int32x2 zeros max: (extent castTo: Int32x2));
    		setScissor: (RectangleI32 min: Int32x2 zeros max: (extent castTo: Int32x2)).

        surface _ emitDrawingCommandsOnto: stateTracker.

        stateTracker _
            endRenderPass;
            close.

        renderingQueue _
    		submitCommandList: (stateTracker upCastFor: CommandList);
    		waitForIdle.

        swapChain _ swapBuffers.
    }.
}.

compileTime constant SwapChainSurfaceRef := SwapChainSurface sharedPointer.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
