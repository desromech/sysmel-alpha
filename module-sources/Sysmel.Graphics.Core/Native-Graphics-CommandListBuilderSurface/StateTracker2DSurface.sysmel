namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Graphics CanvasMesh2D.

#**
 * I am a 2D rendering surface that uses a state tracker for its internal rendering job.
 *#
class StateTracker2DSurface superclass: MeshListBuilderSurface; definition: {
    public field onwedStateTracker type: StateTrackerPtr.

    protected field shaderSignature type: ShaderSignaturePtr.

    protected field sampler type: SamplerPtr.
    protected field samplingStateBinding type: ShaderResourceBindingsPtr.

    protected field transformationStateBuffer type: BufferPtr.
    protected field transformationStateBinding type: ShaderResourceBindingsPtr.

    protected field vertexBuffer type: BufferPtr.
    protected field vertexLayout type: VertexLayoutPtr.
    protected field vertexBinding type: VertexBindingPtr.
    protected field indexBuffer type: BufferPtr.

    protected field texturingBindings type: Stdn Collections Vector(ShaderResourceBindingsPtr).
    protected field nextAvailableTexturingBindings type: UIntPointer.

    method submitVertices => Boolean8 := {
        let requiredCapacity := meshBuilder vertices size * MeshVertex instanceSize.
        vertexBuffer isNil || requiredCapacity > vertexBuffer _ size ifTrue: {
            self createVertexBufferWithCapacity: requiredCapacity.
            vertexBuffer ifNil: {
                return: false.
            }
        }.

        requiredCapacity > 0 ifTrue: {
            vertexBuffer _ uploadAt: 0 size: requiredCapacity data: meshBuilder vertices data
        }.

        true
    }.

    method createVertexBufferWithCapacity: (requiredCapacity: UIntPointer) ::=> Void := {
        let newCapacity := (requiredCapacity asLargerPowerOfTwo max: 16) * MeshVertex instanceSize.
        vertexBuffer := renderingDevice _ createBuffer: (BufferDescription()
            size: newCapacity;
            heapType: MemoryHeapType DeviceLocal;
            usageModes: BufferUsageMode Array | BufferUsageMode CopyDestinationBuffer;
            mainUsageMode: BufferUsageMode Array;
            mappingFlags: BufferMappingFlags DynamicStorage;
            stride: MeshVertex instanceSize;
            yourself
        ) initialData: nil.

        vertexLayout ifNil: {
            let attributes mutable := VertexAttributeDescription array (
                VertexAttributeDescription()
                    location: 0;
                    format: PixelFormat R32G32_Float;
                    offset: 0;
                    yourself,
                VertexAttributeDescription()
                    location: 2;
                    format: PixelFormat R32G32_Float;
                    offset: 8;
                    yourself,
                VertexAttributeDescription()
                    location: 1;
                    format: PixelFormat R32G32B32A32_Float;
                    offset: 16;
                    yourself
            ).

            let strides mutable := UInt32 array(MeshVertex instanceSize).

            vertexLayout := renderingDevice _ createVertexLayout.
            vertexLayout _ addVertexBuffers: strides withAttributes: attributes.

            vertexBinding := renderingDevice _ createVertexBindingFor: vertexLayout.
        }.

        let vertexBuffers mutable := BufferPtr array (vertexBuffer).
        vertexBinding _ bindVertexBuffers: vertexBuffers.
    }.

    method submitIndices => Boolean8 := {
        let requiredCapacity := meshBuilder indices size * 2.
        indexBuffer isNil || requiredCapacity > indexBuffer _ size ifTrue: {
            self createIndexBufferWithCapacity: requiredCapacity.
            indexBuffer ifNil: {
                return: false.
            }
        }.

        requiredCapacity > 0 ifTrue: {
            indexBuffer _ uploadAt: 0 size: requiredCapacity data: meshBuilder indices data
        }.

        true
    }.

    method createIndexBufferWithCapacity: (requiredCapacity: UIntPointer) ::=> Void := {
        let newCapacity := (requiredCapacity asLargerPowerOfTwo max: 16) * 2.
        indexBuffer := renderingDevice _ createBuffer: (BufferDescription()
            size: newCapacity;
            heapType: MemoryHeapType DeviceLocal;
            usageModes: BufferUsageMode ElementArray | BufferUsageMode CopyDestinationBuffer;
            mainUsageMode: BufferUsageMode ElementArray;
            mappingFlags: BufferMappingFlags DynamicStorage;
            stride: MeshVertex instanceSize;
            yourself
        ) initialData: nil.
    }.

    method submitMatrices => Boolean8 := {
        transformationStateBuffer ifNil: {
            shaderSignature := renderingDevice _ createShaderSignatureBuilder _
                ## Sampling state
                beginBindingBank;
                addBankElementWithType: ShaderBindingType Sampler;

    			## Transformation state
    			beginBindingBank;
    			addBankElementWithType: ShaderBindingType UniformBuffer;

    			## Texturing state
    			beginBindingBank;
                addBankElementWithType: ShaderBindingType SampledImage;
    			build.

            sampler := renderingDevice _ createSampler: (SamplerDescription()
                filter: TextureFilter MinLinear | TextureFilter MagLinear | TextureFilter MipmapLinear;
                addressU: TextureAddressMode Wrap;
                addressV: TextureAddressMode Wrap;
                addressW: TextureAddressMode Wrap;
                maxLod: 10000.0f;
                yourself).

            samplingStateBinding := shaderSignature _ createShaderResourceBindings: 0.
            samplingStateBinding _ bindOn: 0 sampler: sampler.

            transformationStateBuffer := renderingDevice _ createBuffer: (BufferDescription()
                size: 256;
                heapType: MemoryHeapType DeviceLocal;
                usageModes: BufferUsageMode Uniform | BufferUsageMode CopyDestinationBuffer;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                stride: 0;
                yourself
            ) initialData: nil.

            transformationStateBinding := shaderSignature _ createShaderResourceBindings: 1.
            transformationStateBinding _ bindOn: 0 uniformBuffer: transformationStateBuffer.
        }.

        {
            let transformationState mutable := TransformationState()
                projectionMatrix: (Float32x4x4 reverseDepthOrthoLeft: 0 right: extent x
                    bottom: extent y top: 0
                    near: -100.0f far: 100.0f
                    invertedY: renderingDevice _ shouldInvertProjectionY);
                yourself.
            transformationStateBuffer _ uploadAt: 0 size: TransformationState instanceSize data: transformationState address
        }.

        true.
    }.


    override method beginDrawingWithCanvas => Canvas uniquePointer := {
        self beginDrawing ifFalse: {
            return: Canvas uniquePointer nil
        }.

        let result := MeshListBuilderCanvas nativeNew _
            initializeWithSurface: self address;
            address.

        Canvas uniquePointer for: result.
    }.


    override method endDrawing => Void := {
        super endDrawing.

        self emitDrawingCommandsOnto: onwedStateTracker.
    }.

    method getOrCreateTextureBindingFor: (textureView: TextureViewPtr) ::=> ShaderResourceBindingsPtr := {
        nextAvailableTexturingBindings >= texturingBindings size ifTrue: {
            texturingBindings add: (shaderSignature _ createShaderResourceBindings: 2)
        }.

        let result := texturingBindings[nextAvailableTexturingBindings].
        result _ bindOn: 0 sampledTextureView: textureView.
        nextAvailableTexturingBindings := nextAvailableTexturingBindings + 1.
        result
    }.

    method emitDrawingCommandsOnto: (stateTracker: StateTrackerPtr const ref) ::=> Void := {
        stateTracker ifNil: { return: void }.

        self submitVertices && self submitIndices && self submitMatrices ifFalse: {
            return: void
        }.

        stateTracker _
            useShaderSignature: shaderSignature;
            useGraphicShaderBindings: samplingStateBinding;
            useGraphicShaderBindings: transformationStateBinding;
            vertexShader: SimpleShader vertex shaderEntryPointInfo address;
            fragmentShader: SimpleShader coloredFragment shaderEntryPointInfo address;
            useVertexBinding: vertexBinding;
            useIndexBuffer: indexBuffer.

        nextAvailableTexturingBindings := 0.
        let lastTextureView mutable := TextureViewPtr nil.
        meshBuilder submeshes do: {:each :: Void |
            each textureView ~= lastTextureView ifTrue: {
                each textureView ifNil: {
                    stateTracker _ fragmentShader: SimpleShader coloredFragment shaderEntryPointInfo address.
                } ifNotNil: {
                    let binding := self getOrCreateTextureBindingFor: each textureView.
                    binding ifNil: {
                        stateTracker _ fragmentShader: SimpleShader coloredFragment shaderEntryPointInfo address.
                    } ifNotNil: {
                        stateTracker _ fragmentShader: SimpleShader texturedFragment shaderEntryPointInfo address.
                        stateTracker _ useGraphicShaderBindings: binding
                    }
                }.

                lastTextureView := each textureView
            }.

            stateTracker _
                primitiveTopology: each primitiveTopology;
                drawElements: each indexCount instanceCount: 1 firstIndex: each firstIndex baseVertex: 0baseInstance: 0.
        }.
    }.
}.

compileTime constant StateTracker2DSurfaceRef := StateTracker2DSurface sharedPointer.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
