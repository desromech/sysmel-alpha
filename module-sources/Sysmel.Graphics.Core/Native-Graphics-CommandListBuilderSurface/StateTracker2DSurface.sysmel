namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Graphics CanvasMesh2D.

#**
 * I am a 2D rendering surface that uses a state tracker for its internal rendering job.
 *#
class StateTracker2DSurface superclass: MeshListBuilderSurface; definition: {
    public field onwedStateTracker type: StateTrackerPtr.

    protected field shaderSignature type: ShaderSignaturePtr.

    protected field cameraStateBuffer type: BufferPtr.
    protected field cameraStateBinding type: ShaderResourceBindingsPtr.

    protected field drawingStateBuffer type: BufferPtr.
    protected field drawingStateBinding type: ShaderResourceBindingsPtr.

    protected field vertexBuffer type: BufferPtr.
    protected field vertexLayout type: VertexLayoutPtr.
    protected field vertexBinding type: VertexBindingPtr.
    protected field indexBuffer type: BufferPtr.

    method submitVertices => Boolean8 := {
        let requiredCapacity := meshBuilder vertices size * MeshVertex instanceSize.
        vertexBuffer isNil || requiredCapacity > vertexBuffer _ size ifTrue: {
            self createVertexBufferWithCapacity: requiredCapacity.
            vertexBuffer ifNil: {
                return: false.
            }
        }.

        requiredCapacity > 0 ifTrue: {
            vertexBuffer _ uploadAt: 0 size: requiredCapacity data: meshBuilder vertices data
        }.

        true
    }.

    method createVertexBufferWithCapacity: (requiredCapacity: UIntPointer) ::=> Void := {
        let newCapacity := (requiredCapacity asLargerPowerOfTwo max: 16) * MeshVertex instanceSize.
        vertexBuffer := renderingDevice _ createBuffer: (BufferDescription()
            size: newCapacity;
            heapType: MemoryHeapType DeviceLocal;
            usageModes: BufferUsageMode Array | BufferUsageMode CopyDestinationBuffer;
            mainUsageMode: BufferUsageMode Array;
            mappingFlags: BufferMappingFlags DynamicStorage;
            stride: MeshVertex instanceSize;
            yourself
        ) initialData: nil.

        vertexLayout ifNil: {
            let attributes mutable := VertexAttributeDescription array (
                VertexAttributeDescription()
                    location: 0;
                    format: PixelFormat R32G32_Float;
                    offset: 0;
                    yourself,
                VertexAttributeDescription()
                    location: 2;
                    format: PixelFormat R32G32_Float;
                    offset: 8;
                    yourself,
                VertexAttributeDescription()
                    location: 1;
                    format: PixelFormat R32G32B32A32_Float;
                    offset: 16;
                    yourself
            ).

            let strides mutable := UInt32 array(MeshVertex instanceSize).

            vertexLayout := renderingDevice _ createVertexLayout.
            vertexLayout _ addVertexBuffers: strides withAttributes: attributes.

            vertexBinding := renderingDevice _ createVertexBindingFor: vertexLayout.
        }.

        let vertexBuffers mutable := BufferPtr array (vertexBuffer).
        vertexBinding _ bindVertexBuffers: vertexBuffers.
    }.

    method submitIndices => Boolean8 := {
        let requiredCapacity := meshBuilder indices size * 2.
        indexBuffer isNil || requiredCapacity > indexBuffer _ size ifTrue: {
            self createIndexBufferWithCapacity: requiredCapacity.
            indexBuffer ifNil: {
                return: false.
            }
        }.

        requiredCapacity > 0 ifTrue: {
            indexBuffer _ uploadAt: 0 size: requiredCapacity data: meshBuilder indices data
        }.

        true
    }.

    method createIndexBufferWithCapacity: (requiredCapacity: UIntPointer) ::=> Void := {
        let newCapacity := (requiredCapacity asLargerPowerOfTwo max: 16) * 2.
        indexBuffer := renderingDevice _ createBuffer: (BufferDescription()
            size: newCapacity;
            heapType: MemoryHeapType DeviceLocal;
            usageModes: BufferUsageMode ElementArray | BufferUsageMode CopyDestinationBuffer;
            mainUsageMode: BufferUsageMode ElementArray;
            mappingFlags: BufferMappingFlags DynamicStorage;
            stride: MeshVertex instanceSize;
            yourself
        ) initialData: nil.
    }.

    method submitMatrices => Boolean8 := {
        cameraStateBuffer ifNil: {
            shaderSignature := renderingDevice _ createShaderSignatureBuilder _
                ## Sampling state
                beginBindingBank;
                addBankElementWithType: ShaderBindingType Sampler;

    			## Camera state
    			beginBindingBank;
    			addBankElementWithType: ShaderBindingType UniformBuffer;

    			## Drawing state
    			beginBindingBank;
    			addBankElementWithType: ShaderBindingType UniformBuffer;
                addBankElementWithType: ShaderBindingType SampledImage;
    			build.

            cameraStateBuffer := renderingDevice _ createBuffer: (BufferDescription()
                size: 256;
                heapType: MemoryHeapType DeviceLocal;
                usageModes: BufferUsageMode Uniform | BufferUsageMode CopyDestinationBuffer;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                stride: 0;
                yourself
            ) initialData: nil.

            cameraStateBinding := shaderSignature _ createShaderResourceBindings: 1.
            cameraStateBinding _ bindOn: 0 uniformBuffer: cameraStateBuffer.

            drawingStateBuffer := renderingDevice _ createBuffer: (BufferDescription()
                size: 256;
                heapType: MemoryHeapType DeviceLocal;
                usageModes: BufferUsageMode Uniform | BufferUsageMode CopyDestinationBuffer;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                stride: 0;
                yourself
            ) initialData: nil.

            drawingStateBinding := shaderSignature _ createShaderResourceBindings: 2.
            drawingStateBinding _ bindOn: 0 uniformBuffer: drawingStateBuffer.
        }.

        {
            let cameraState mutable := CameraState()
                projectionMatrix: (Float32x4x4 reverseDepthOrthoLeft: 0 right: extent x
                    bottom: extent y top: 0
                    near: -100.0f far: 100.0f
                    invertedY: renderingDevice _ shouldInvertProjectionY);
                viewMatrix: Float32x4x4 identity;
                yourself.
            cameraStateBuffer _ uploadAt: 0 size: CameraState instanceSize data: cameraState address
        }.

        {
            let drawingState mutable := DrawingState()
                modelMatrix: Float32x4x4 identity;
                yourself.
            drawingStateBuffer _ uploadAt: 0 size: DrawingState instanceSize data: drawingState address
        }.

        true.
    }.


    override method beginDrawingWithCanvas => Canvas uniquePointer := {
        self beginDrawing ifFalse: {
            return: Canvas uniquePointer nil
        }.

        let result := MeshListBuilderCanvas nativeNew _
            initializeWithSurface: self address;
            address.

        Canvas uniquePointer for: result.
    }.


    override method endDrawing => Void := {
        super endDrawing.

        self emitDrawingCommandsOnto: onwedStateTracker.
    }.

    method emitDrawingCommandsOnto: (stateTracker: StateTrackerPtr const ref) ::=> Void := {
        stateTracker ifNil: { return: void }.

        Stdn stdout << self address << " StateTracker2DRenderingSurface endDrawing"; nl.
        Stdn stdout << "mesh " << meshBuilder vertices size << " " << meshBuilder indices size << " " << meshBuilder submeshes size; nl.

        self submitVertices && self submitIndices && self submitMatrices ifFalse: {
            return: void
        }.

        Stdn stdout << "surface buffers submitted"; nl.

        stateTracker _
            useShaderSignature: shaderSignature;
            useGraphicShaderBindings: cameraStateBinding;
            useGraphicShaderBindings: drawingStateBinding;
            vertexShader: SimpleShader vertex shaderEntryPointInfo address;
            fragmentShader: SimpleShader coloredFragment shaderEntryPointInfo address;
            useVertexBinding: vertexBinding;
            useIndexBuffer: indexBuffer.

        meshBuilder submeshes do: {:each :: Void |
            stateTracker _
                primitiveTopology: each primitiveTopology;
                drawElements: each indexCount instanceCount: 1 firstIndex: each firstIndex baseVertex: 0baseInstance: 0.
        }.
    }.
}.

compileTime constant StateTracker2DSurfaceRef := StateTracker2DSurface sharedPointer.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
