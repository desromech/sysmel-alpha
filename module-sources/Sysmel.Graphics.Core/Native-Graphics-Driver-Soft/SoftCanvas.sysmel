namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math Geometry.

class SoftSurface.

#**
 * I am a software based rendering CPU canvas that draws into SoftSurface.
 *#
class SoftCanvas superclass: Canvas; definition: {
    protected field targetSurface type: SoftSurface pointer.
    protected field currentClipRectangle type: RectangleF32.

    protected field currentStartPosition type: Float32x2.
    protected field currentStartColor type: Float32x4.

    protected field currentEndPosition type: Float32x2.
    protected field currentEndColor type: Float32x4.
    protected field currentGradientVector type: Float32x2.

    protected field blendingMode type: BlendingMode.

    method initializeWithSurface: (theTargetSurface: SoftSurface pointer) ::=> Void := {
        blendingMode := BlendingMode AlphaOver.
        targetSurface := theTargetSurface.
        currentClipRectangle := RectangleF32 fullSpace.
        transform setIdentity.
    }.

    override method finalize => Void := {
        targetSurface ifNotNil: {
            targetSurface _ endDrawing
        }
    }.

    override method blendingMode: (newMode: BlendingMode) ::=> Void := {
        blendingMode := newMode
    }.

    override method clear ::=> Void := {
        targetSurface _ pixelsBlitter setAllPixelsToColor: currentStartColor
    }.

    inline method isFullyTransparent => Boolean8
        := currentStartColor a <= 0.0f && currentEndColor a <= 0.0f.

    override method color: (srgbColor: UInt8x4) ::=> Void := {
        self color: Stdn Math Color decodeSRGBUnorm8(srgbColor)
    }.

    override method color: (linearColor: Float32x4) ::=> Void := {
        self linearGradientStart: linearColor position: Float32x2 zeros end: linearColor position: Float32x2 zeros.
    }.

    override method linearGradientStart: (startColor: UInt8x4) position: (startPosition: Float32x2) end: (endColor: UInt8x4) position: (endPosition: Float32x2) ::=> Void := {
        self linearGradientStart: Stdn Math Color decodeSRGBUnorm8(startColor)
            position: startPosition end: Stdn Math Color decodeSRGBUnorm8(endColor) position: endPosition
    }.

    ## This sets the current active color. The color is in the linear RGB space.
    override method linearGradientStart: (startColor: Float32x4) position: (startPosition: Float32x2) end: (endColor: Float32x4) position: (endPosition: Float32x2) ::=> Void := {
        currentStartColor := startColor.
        currentEndColor := endColor.
        currentStartPosition := transform transformPoint: startPosition.
        currentEndPosition := transform transformPoint: endPosition.

        let v := endPosition - startPosition.
        let l2 := v length2.
        (l2 closeTo: 0.0) ifTrue: {
            currentGradientVector := 0.0f.
        } ifFalse: {
            currentGradientVector := v / l2.
        }.
    }.

    const inline method evaluatePaintColorAt: (position: Float32x2) ::=> Float32x4 := {
        let alpha := (position - currentStartPosition) dot: currentGradientVector.
        currentStartColor interpolateTo: currentEndColor at: (alpha clampMin: 0.0f max: 1.0f)
    }.

    override method fillTriangle: (p1: Float32x2) color: (c1: Float32x4) tc: (tc1: Float32x2)
        p2: (p2: Float32x2) color: (c2: Float32x4) tc: (tc2: Float32x2)
        p3: (p3: Float32x2) color: (c3: Float32x4) tc: (tc3: Float32x2) ::=> Void := {

        self isFullyTransparent ifTrue: {
            return: void.
        }.

        let tp1 := transform transformPoint: p1.
        let tp2 := transform transformPoint: p2.
        let tp3 := transform transformPoint: p3.

        let mc1 := c1 * (self evaluatePaintColorAt: p1).
        let mc2 := c2 * (self evaluatePaintColorAt: p2).
        let mc3 := c3 * (self evaluatePaintColorAt: p3).

        targetSurface _ pixelsBlitter
            blendTriangle: tp1 p2: tp2 p3: tp3 pixelsWith: {:(Float32x2)p :(Float32x3)barycentricCoordinates :(Float32x4)originalDestPixelValue :: Float32x4 |
            let interpolatedColor := mc1*barycentricCoordinates x + mc2*barycentricCoordinates y + mc3*barycentricCoordinates z.
            interpolatedColor
        }
    }.

    override method fillRectangle: (rectangle: RectangleF32) ::=> Void := {
        self isFullyTransparent ifTrue: {
            return: void.
        }.

        transform isTranslationOnly ifTrue: {
            let transformedRectangle := rectangle translatedBy: transform translation.
            let convertedRectangle := RectangleI32 min: (transformedRectangle min floor castTo: Int32x2) max: (transformedRectangle max floor castTo: Int32x2).

            targetSurface _ pixelsBlitter
                blendRectangle: convertedRectangle pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
                self evaluatePaintColorAt: (destPixelCoordinate castTo: Float32x2)
            }

        } ifFalse: {
            self
                fillTriangle: rectangle bottomLeft p2: rectangle bottomRight p3: rectangle topRight;
                fillTriangle: rectangle topRight p2: rectangle topLeft p3: rectangle bottomLeft
        }.
    }.

    ## Draw the rectangle lines.
    override method drawSegmentStart: (startPoint: Float32x2) end: (endPoint: Float32x2) ::=> Void := {
        self isFullyTransparent ifTrue: {
            return: void.
        }.

        let transformedStartPoint := transform transformPoint: startPoint.
        let transformedEndPoint := transform transformPoint: endPoint.
        targetSurface _ pixelsBlitter
            blendSegmentStart: (transformedStartPoint floor castTo: Int32x2) end: (transformedEndPoint floor castTo: Int32x2) pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
            self evaluatePaintColorAt: (destPixelCoordinate castTo: Float32x2)
        }
    }.

    override method copyTexture: (textureView: TextureView sharedPointer const ref) at: (targetPosition: Float32x2) ::=> Void := {
        let cpuTextureView := textureView getPointer castTo: SoftTextureView pointer.

        let sourceBlitter := cpuTextureView _ pixelsBlitter.
        targetSurface _ pixelsBlitter
            copyPixelsFrom: sourceBlitter into: (targetPosition floor castTo: Int32x2)
    }.

    override method blendTexture: (textureView: TextureView sharedPointer const ref) at: (targetPosition: Float32x2) ::=> Void := {
        let cpuTextureView := textureView getPointer castTo: SoftTextureView pointer.

        let sourceBlitter := cpuTextureView _ pixelsBlitter.
        targetSurface _ pixelsBlitter
            compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentStartColor at: (targetPosition floor castTo: Int32x2)
    }.

    ## Sets the current font face with size.
    override method fontFaceWithSize: (font: FontFaceWithSize sharedPointer const ref) ::=> Void := {
        currentFontFaceWithSize := font.
    }.

    override method drawGlyph: (glyph: Glyph ref) at: (aPosition: Float32x2) ::=> Void := {
        let form := glyph asForm.
        form ifNotNil: {
            let sourceBlitter := form _ makeBlitter.
            let drawPosition := transform transformPoint: aPosition + glyph drawOrigin.
            targetSurface _ pixelsBlitter
                compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentStartColor
                at: (drawPosition floor castTo: Int32x2).
        }.
    }.

    inline method doSetClipRectangle: (aRectangle: RectangleF32) ::=> Void := {
        let blitter ref := targetSurface _ pixelsBlitter.
        let convertedClipRectangle := (aRectangle intersectionWith: blitter bounds asRectangleF32) asRectangleI32.
        blitter applyClippingRectangle: convertedClipRectangle
    }.

    override method currentClipRectangle => RectangleF32 := {
        currentClipRectangle
    }.

    override method applyClipRectangle: (aRectangle: RectangleF32) ::=> Void := {
        currentClipRectangle := currentClipRectangle intersectionWith: aRectangle.
        self doSetClipRectangle: currentClipRectangle.
    }.

    override method restoreClipRectangle: (aRectangle: RectangleF32) ::=> Void := {
        currentClipRectangle := aRectangle.
        self doSetClipRectangle: currentClipRectangle.
    }.
}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
