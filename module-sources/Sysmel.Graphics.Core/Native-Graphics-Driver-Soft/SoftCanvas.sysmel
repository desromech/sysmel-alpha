namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

useNamespace: Stdn Math Geometry.

class SoftSurface.

#**
 * I am a software based rendering CPU canvas that draws into SoftSurface.
 *#
class SoftCanvas superclass: AbstractConcreteCanvas; definition: {
    protected field targetSurface type: SoftSurface pointer.

    method initializeWithSurface: (theTargetSurface: SoftSurface pointer) ::=> Void := {
        targetSurface := theTargetSurface.
        self resetCanvasState.
    }.

    override method finalize => Void := {
        targetSurface ifNotNil: {
            targetSurface _ endDrawing
        }
    }.

    override method clear ::=> Void := {
        targetSurface _ pixelsBlitter setAllPixelsToColor: currentStartColor
    }.

    override method fillTriangle: (p1: Float32x2) color: (c1: Float32x4) tc: (tc1: Float32x2)
        p2: (p2: Float32x2) color: (c2: Float32x4) tc: (tc2: Float32x2)
        p3: (p3: Float32x2) color: (c3: Float32x4) tc: (tc3: Float32x2) ::=> Void := {

        self isFullyTransparent ifTrue: {
            return: void.
        }.

        let tp1 := transform transformPoint: p1.
        let tp2 := transform transformPoint: p2.
        let tp3 := transform transformPoint: p3.

        let mc1 := c1 * (self evaluatePaintColorAt: p1).
        let mc2 := c2 * (self evaluatePaintColorAt: p2).
        let mc3 := c3 * (self evaluatePaintColorAt: p3).

        targetSurface _ pixelsBlitter
            blendTriangle: tp1 p2: tp2 p3: tp3 pixelsWith: {:(Float32x2)p :(Float32x3)barycentricCoordinates :(Float32x4)originalDestPixelValue :: Float32x4 |
            let interpolatedColor := mc1*barycentricCoordinates x + mc2*barycentricCoordinates y + mc3*barycentricCoordinates z.
            interpolatedColor
        }
    }.

    override method fillRectangle: (rectangle: RectangleF32) ::=> Void := {
        self isFullyTransparent ifTrue: {
            return: void.
        }.

        transform isTranslationOnly ifTrue: {
            let transformedRectangle := rectangle translatedBy: transform translation.
            let convertedRectangle := RectangleI32 min: (transformedRectangle min floor castTo: Int32x2) max: (transformedRectangle max floor castTo: Int32x2).

            targetSurface _ pixelsBlitter
                blendRectangle: convertedRectangle pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
                self evaluatePaintColorAt: (destPixelCoordinate castTo: Float32x2)
            }

        } ifFalse: {
            self
                fillTriangle: rectangle bottomLeft p2: rectangle bottomRight p3: rectangle topRight;
                fillTriangle: rectangle topRight p2: rectangle topLeft p3: rectangle bottomLeft
        }.
    }.

    ## Draw the rectangle lines.
    override method drawSegmentStart: (startPoint: Float32x2) end: (endPoint: Float32x2) ::=> Void := {
        self isFullyTransparent ifTrue: {
            return: void.
        }.

        let transformedStartPoint := transform transformPoint: startPoint.
        let transformedEndPoint := transform transformPoint: endPoint.
        targetSurface _ pixelsBlitter
            blendSegmentStart: (transformedStartPoint floor castTo: Int32x2) end: (transformedEndPoint floor castTo: Int32x2) pixelsWith: {:(UInt32x2)destPixelCoordinate :(Float32x4)originalDestPixelValue :: Float32x4 |
            self evaluatePaintColorAt: (destPixelCoordinate castTo: Float32x2)
        }
    }.

    override method copyTexture: (textureView: TextureView sharedPointer const ref) at: (targetPosition: Float32x2) ::=> Void := {
        let cpuTextureView := textureView getPointer castTo: SoftTextureView pointer.

        let sourceBlitter := cpuTextureView _ pixelsBlitter.
        targetSurface _ pixelsBlitter
            copyPixelsFrom: sourceBlitter into: (targetPosition floor castTo: Int32x2)
    }.

    override method blendTexture: (textureView: TextureView sharedPointer const ref) at: (targetPosition: Float32x2) ::=> Void := {
        let cpuTextureView := textureView getPointer castTo: SoftTextureView pointer.

        let sourceBlitter := cpuTextureView _ pixelsBlitter.
        targetSurface _ pixelsBlitter
            compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentStartColor at: (targetPosition floor castTo: Int32x2)
    }.

    override method drawGlyph: (glyph: Glyph ref) at: (aPosition: Float32x2) ::=> Void := {
        let form := glyph asForm.
        form ifNotNil: {
            let sourceBlitter := form _ makeBlitter.
            let drawPosition := transform transformPoint: aPosition + glyph drawOrigin.
            targetSurface _ pixelsBlitter
                compositeAlphaBlendPixelsFrom: sourceBlitter withColor: currentStartColor
                at: (drawPosition floor castTo: Int32x2).
        }.
    }.

    override method doSetClipRectangle: (aRectangle: RectangleF32) ::=> Void := {
        let blitter ref := targetSurface _ pixelsBlitter.
        let convertedClipRectangle := (aRectangle intersectionWith: blitter bounds asRectangleF32) asRectangleI32.
        blitter applyClippingRectangle: convertedClipRectangle
    }.
}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
