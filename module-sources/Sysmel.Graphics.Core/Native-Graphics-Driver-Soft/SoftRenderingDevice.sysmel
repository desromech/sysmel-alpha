namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {


#**
 * I am a CPU based rendering driver. Since I do not require special graphical support, I am constructed as a singleton.
 *#
class SoftRenderingDevice superclass: RenderingDevice; definition: {
    field defaultCommandQueue type: CommandQueuePtr.

    override method initialize => Void := {
        defaultCommandQueue := SoftCommandQueue sharedNew upCastFor: CommandQueue.
    }.

    override method isSoftRenderingDevice => Boolean8
        := true.

    override method createBuffer: (description: BufferDescription const ref) initialData: (initialData: Void const pointer) ::=> BufferPtr := {
        let buffer := SoftBuffer sharedNew.
        let memory := Stdn zmalloc(description size).
        memory ifNil: {
            return: BufferPtr nil.
        }.

        initialData ifNotNil: {
            Stdn memcpy(memory, initialData, description size).
        }.

        buffer _ initializeWithDescription: description memory: memory.
        buffer upCastFor: Buffer.
    }.

    override method createShaderSignatureBuilder ::=> ShaderSignatureBuilderPtr
        := SoftShaderSignatureBuilder sharedNew upCastFor: ShaderSignatureBuilder.

    override method createShaderLibraryFromModule: (shaderModule: GPU ShaderModuleInfo const ref) ::=> ShaderLibraryHandlePtr
        := ShaderLibraryHandlePtr nil.

    override method createShaderStageFromEntryPoint: (entryPointInfo: GPU ShaderEntryPointInfo const ref) ::=> ShaderStageHandlePtr := {
        let result := SoftShaderStageHandle sharedNew.
        result _ entryPointInfo: entryPointInfo.
        result upCastFor: ShaderStageHandle
    }.

    override method createTexture: (description: TextureDescription const ref) ::=> TexturePtr := {
        let result := SoftLinearTexture sharedNew.
        (result _ initializeWithDescription: description) ifFalse: {
            return: TexturePtr nil
        }.

        result upCastFor: Texture
    }.

    override method createSampler: (description: SamplerDescription const ref) ::=> SamplerPtr := {
        let result := SoftSampler sharedNew.
        (result _ initializeWithDescription: description) ifFalse: {
            return: SamplerPtr nil
        }.

        result upCastFor: Sampler
    }.

    override method createComputePipelineState: (description: ComputePipelineStateDescription const ref) ::=> PipelineStatePtr := {
        PipelineStatePtr nil
    }.

    override method createGraphicsPipelineState: (description: GraphicsPipelineStateDescription const ref) ::=> PipelineStatePtr := {
        let result := SoftGraphicsPipeline sharedNew.
        result _ description := description.
        (result _ fetchCachedPipelineState) ifFalse: {
            return: PipelineStatePtr nil.
        }.

        result upCastFor: PipelineState.
    }.

    override method createVertexLayout => VertexLayout sharedPointer := {
        SoftVertexLayout sharedNew upCastFor: VertexLayout
    }.

    override method createVertexBindingFor: (layout: VertexLayout sharedPointer const ref) ::=> VertexBinding sharedPointer := {
        layout ifNil: {
            return: VertexBinding sharedPointer nil.
        }.

        let softwareLayout := layout downCastFor: SoftVertexLayout.
        let result := SoftVertexBinding sharedNew.
        result _ initializeWithLayout: softwareLayout.
        result upCastFor: VertexBinding
    }.

    override method createCommandAllocatorOfType: (type: CommandListType) for: (queue: CommandQueuePtr const ref) ::=> CommandListAllocatorPtr := {
        let result := SoftCommandListAllocator sharedNew.
        result _
            commandListType: type.
        result upCastFor: CommandListAllocator
    }.

    override method createCommandListOfType: (type: CommandListType) for: (allocator: CommandListAllocatorPtr const ref) initialPipelineState: (initialPipeline: PipelineStatePtr const ref) ::=> CommandListPtr := {
        allocator ifNil: {
            return: CommandListPtr nil
        }.

        let softAllocator := allocator downCastFor: SoftCommandListAllocator.
        softAllocator _ commandListType = type ifFalse: {
            return: CommandListPtr nil
        }.

        let result := SoftCommandList sharedNew.
        result _
            commandListType: type.
        result upCastFor: CommandList
    }.

    override method createFramebuffer: (extent: UInt32x2) colorViews: (colorViews: TextureViewPtr const arraySlice) depthStencilView: (depthStencilView: TextureViewPtr const ref) ::=> FramebufferPtr := {
        let result := SoftFramebuffer sharedNew.

        result _ colorAttachments reserve: colorViews size.
        colorViews do: {:each :: Void |
            result _ colorAttachments add: (each downCastFor: SoftTextureView)
        }.

        result _
            extent: extent;
            depthStencilAttachment: (depthStencilView downCastFor: SoftTextureView).

        result upCastFor: Framebuffer
    }.

    override method createRenderPass: (colorAttachments: RenderPassColorAttachmentDescription const arraySlice) depthStencilAttachment: (depthStencilAttachment: RenderPassDepthStencilAttachmentDescription const pointer) ::=> RenderPassPtr := {
        let result := SoftRenderPass sharedNew.
        result _ colorAttachments addAll: colorAttachments.
        depthStencilAttachment ifNil: {
            result _ hasDepthStencilAttachment: false.
        } ifNotNil: {
            result _
                hasDepthStencilAttachment: true;
                depthStencilAttachment: depthStencilAttachment _.
        }.

        result upCastFor: RenderPass
    }.

    override method getDefaultCommandQueue => CommandQueuePtr := {
        defaultCommandQueue
    }.


    override method createFence => FencePtr := {
        SoftFence sharedNew upCastFor: Fence
    }.

    override method createSwapChain: (swapChainCreationInfo: SwapChainCreationInfo const ref) for: (renderingQueue: CommandQueuePtr const ref) ::=> SwapChainPtr := {
        let result := SoftSwapChain sharedNew.
        (result _ initializeWith: swapChainCreationInfo for: renderingQueue on: self) ifFalse: {
            return: SwapChainPtr nil
        }.

        result upCastFor: SwapChain.
    }.

    override method waitForIdle => Void := {
        defaultCommandQueue _ waitForIdle
    }.

    override method hasTopLeftNdcOrigin => Boolean8
        := true.

    override method hasBottomLeftTextureCoordinates => Boolean8
        := false.
}.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
