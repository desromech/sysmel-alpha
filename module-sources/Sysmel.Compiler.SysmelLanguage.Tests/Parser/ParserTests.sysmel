namespace Sysmel definition: {
namespace Compiler definition: {
namespace SysmelLanguage definition: {
namespace Tests definition: {

useNamespace: Sysmel Compiler Parsing.

class ParserTests superclass: Std Testing TestCase; definition: {
    method parseString: (source: Std ImmutableString) ::=> ASTNodeRef := {
        Parser() parse: (Scanner() scan: (SourceCode new
            content: source asMutableString;
            name: "unit test";
            yourself))
    }.

    method parseStringWithLiteralArrayContent: (source: Std ImmutableString) ::=> ASTNodeRef := {
        Parser() parseLiteralArrayContent: (Scanner() scan: (SourceCode new
            content: source asMutableString;
            name: "unit test";
            yourself))
    }.

    method parseSingleExpression: (source: Std ImmutableString) ::=> ASTNodeRef := {
        let parseResult := self parseString: source.
        self assert: parseResult isExpressionListNode.

        let expresionList := (parseResult downCastFor: ASTExpressionListNode).
        self assert: expresionList expressions size equals: 1.
        return: expresionList expressions first
    }.

    test: testEmpty with: {
        let node := self parseString: "".
        self assert: node isExpressionListNode.
        self assert: (node downCastFor: ASTExpressionListNode) expressions isEmpty.
    }.

    test: testLiteralInteger with: {
        {
            let literal := self parseSingleExpression: "0".
            self assert: literal isIntegerLiteralNode.
            self assert: (literal downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "0".
        }.

        {
            let literal := self parseSingleExpression: "-0".
            self assert: literal isIntegerLiteralNode.
            self assert: (literal downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "-0".
        }.

        {
            let literal := self parseSingleExpression: "42".
            self assert: literal isIntegerLiteralNode.
            self assert: (literal downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "42".
        }.

        {
            let literal := self parseSingleExpression: "-42".
            self assert: literal isIntegerLiteralNode.
            self assert: (literal downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "-42".
        }.

        {
            let literal := self parseSingleExpression: "(-42)".
            self assert: literal isIntegerLiteralNode.
            self assert: (literal downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "-42".
        }.
    }.

    test: testLiteralFloat with: {
        {
            let literal := self parseSingleExpression: "0.0".
            self assert: literal isFloatLiteralNode.
            self assert: (literal downCastFor: ASTFloatLiteralNode) value equals: 0.0.
        }.

        {
            let literal := self parseSingleExpression: "42.5".
            self assert: literal isFloatLiteralNode.
            self assert: (literal downCastFor: ASTFloatLiteralNode) value equals: 42.5.
        }.

        {
            let literal := self parseSingleExpression: "42.5e2".
            self assert: literal isFloatLiteralNode.
            self assert: (literal downCastFor: ASTFloatLiteralNode) value equals: 42.5e2.
        }.

        {
            let literal := self parseSingleExpression: "-1.5e-6".
            self assert: literal isFloatLiteralNode.
            self assert: (literal downCastFor: ASTFloatLiteralNode) value equals: -1.5e-6.
        }.

        {
            let literal := self parseSingleExpression: "42.5e2".
            self assert: literal isFloatLiteralNode.
            self assert: (literal downCastFor: ASTFloatLiteralNode) value equals: 42.5e2.
        }.
    }.

    test: testLiteralString with: {
        {
            let literal := self parseSingleExpression: "\"\"".
            self assert: literal isStringLiteralNode.
            self assert: (literal downCastFor: ASTStringLiteralNode) value asArraySlice equals: "".
        }.

        {
            let literal := self parseSingleExpression: "\"hello\"".
            self assert: literal isStringLiteralNode.
            self assert: (literal downCastFor: ASTStringLiteralNode) value asArraySlice equals: "hello".
        }.

        {
            let literal := self parseSingleExpression: "\"Hello World\\r\\n\"".
            self assert: literal isStringLiteralNode.
            self assert: (literal downCastFor: ASTStringLiteralNode) value asArraySlice equals: "Hello World\r\n".
        }.
    }.

    test: testLiteralCharacter with: {
        {
            let literal := self parseSingleExpression: "'a'".
            self assert: literal isCharacterLiteralNode.
            self assert: (literal downCastFor: ASTCharacterLiteralNode) value equals: 'a'.
        }.

        {
            let literal := self parseSingleExpression: "'\\n'".
            self assert: literal isCharacterLiteralNode.
            self assert: (literal downCastFor: ASTCharacterLiteralNode) value equals: '\n'.
        }.

        {
            let literal := self parseSingleExpression: "'\\r'".
            self assert: literal isCharacterLiteralNode.
            self assert: (literal downCastFor: ASTCharacterLiteralNode) value equals: '\r'.
        }.

        {
            let literal := self parseSingleExpression: "'\\t'".
            self assert: literal isCharacterLiteralNode.
            self assert: (literal downCastFor: ASTCharacterLiteralNode) value equals: '\t'.
        }.
    }.

    test: testLiteralSymbol with: {
        {
            let literal := self parseSingleExpression: "#a".
            self assert: literal isSymbolLiteralNode.
            self assert: (literal downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "a".
        }.

        {
            let literal := self parseSingleExpression: "#test:".
            self assert: literal isSymbolLiteralNode.
            self assert: (literal downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "test:".
        }.

        {
            let literal := self parseSingleExpression: "#<".
            self assert: literal isSymbolLiteralNode.
            self assert: (literal downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "<".
        }.
    }.

    test: testLiteralSymbolString with: {
        {
            let literal := self parseSingleExpression: "#\"\"".
            self assert: literal isSymbolLiteralNode.
            self assert: (literal downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "".
        }.

        {
            let literal := self parseSingleExpression: "#\"hello\"".
            self assert: literal isSymbolLiteralNode.
            self assert: (literal downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "hello".
        }.

        {
            let literal := self parseSingleExpression: "#\"Hello World\\r\\n\"".
            self assert: literal isSymbolLiteralNode.
            self assert: (literal downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "Hello World\r\n".
        }.

        {
            let literal := self parseSingleExpression: "#\"std::string\"".
            self assert: literal isSymbolLiteralNode.
            self assert: (literal downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "std::string".
        }.
    }.

    test: testIdentifierReference with: {
        {
            let node := self parseSingleExpression: "hello".
            self assert: node isIdentifierReferenceNode.
            self assert: (node downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "hello".
        }.

        {
            let node := self parseSingleExpression: "_helloWorld12345".
            self assert: node isIdentifierReferenceNode.
            self assert: (node downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "_helloWorld12345".
        }.
    }.

    test: testUnaryMessage with: {
        let node := self parseSingleExpression: "a negated".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "negated".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testUnaryMinus with: {
        let node := self parseSingleExpression: "-a".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "pre--".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testUnaryPlus with: {
        let node := self parseSingleExpression: "+a".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "pre-+".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testUnaryLogicalNot with: {
        let node := self parseSingleExpression: "!a".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "pre-!".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testUnaryBitwiseNot with: {
        let node := self parseSingleExpression: "~a".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "pre-~".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    method extractBinarySendSequenceSelectors: (binarySendSequence: ASTBinaryMessageSendSequenceNode rcRef const ref) ::=> Std Collections Vector(Std ImmutableString) := {
        let result mutable type: Std Collections Vector(Std ImmutableString).

        binarySendSequence selectors do: {:selectorNode :: Void |
            self assert: selectorNode isSymbolLiteralNode.
            let value type: Std ImmutableString := (selectorNode downCastFor: ASTSymbolLiteralNode) value asArraySlice.
            result add: value
        }.

        result asMoveReference
    }.

    method extractBinarySendSequenceIdentifiers: (binarySendSequence: ASTBinaryMessageSendSequenceNode rcRef const ref) ::=> Std Collections Vector(Std ImmutableString) := {
        let result mutable type: Std Collections Vector(Std ImmutableString).

        binarySendSequence operands do: {:operandNode :: Void |
            self assert: operandNode isIdentifierReferenceNode.
            let value type: Std ImmutableString := (operandNode downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice.
            result add: value
        }.

        result asMoveReference
    }.

    test: testBinaryOperation with: {
        let node := self parseSingleExpression: "a+b".
        self assert: node isBinaryMessageSendSequenceNode.

        let binarySendSequence ref := node downCastFor: ASTBinaryMessageSendSequenceNode.
        let selectors := self extractBinarySendSequenceSelectors: binarySendSequence.
        let identifiers := self extractBinarySendSequenceIdentifiers: binarySendSequence.

        self deny: binarySendSequence isLowPrecedence.
        self assert: selectors asArraySlice equals: Std ImmutableString array(
            "+"
        ).
        self assert: identifiers asArraySlice equals: Std ImmutableString array(
            "a", "b"
        ).
    }.

    test: testBinaryOperation2 with: {
        let node := self parseSingleExpression: "a+b*c".
        self assert: node isBinaryMessageSendSequenceNode.

        let binarySendSequence ref := node downCastFor: ASTBinaryMessageSendSequenceNode.
        let selectors := self extractBinarySendSequenceSelectors: binarySendSequence.
        let identifiers := self extractBinarySendSequenceIdentifiers: binarySendSequence.

        self deny: binarySendSequence isLowPrecedence.
        self assert: selectors asArraySlice equals: Std ImmutableString array(
            "+", "*"
        ).
        self assert: identifiers asArraySlice equals: Std ImmutableString array(
            "a", "b", "c"
        ).
    }.

    test: testBinaryOperation3 with: {
        let node := self parseSingleExpression: "a + b*c".
        self assert: node isBinaryMessageSendSequenceNode.

        let binarySendSequence ref := node downCastFor: ASTBinaryMessageSendSequenceNode.
        let selectors := self extractBinarySendSequenceSelectors: binarySendSequence.
        let identifiers := self extractBinarySendSequenceIdentifiers: binarySendSequence.

        self deny: binarySendSequence isLowPrecedence.
        self assert: selectors asArraySlice equals: Std ImmutableString array(
            "+", "*"
        ).
        self assert: identifiers asArraySlice equals: Std ImmutableString array(
            "a", "b", "c"
        ).
    }.

    test: testLowPrecedenceBinaryOperation with: {
        let node := self parseSingleExpression: "a ::+ b".
        self assert: node isBinaryMessageSendSequenceNode.

        let binarySendSequence ref := node downCastFor: ASTBinaryMessageSendSequenceNode.
        let selectors := self extractBinarySendSequenceSelectors: binarySendSequence.
        let identifiers := self extractBinarySendSequenceIdentifiers: binarySendSequence.

        self assert: binarySendSequence isLowPrecedence.
        self assert: selectors asArraySlice equals: Std ImmutableString array(
            "+"
        ).
        self assert: identifiers asArraySlice equals: Std ImmutableString array(
            "a", "b"
        ).
    }.

    test: testLowPrecedenceBinaryOperation2 with: {
        let node := self parseSingleExpression: "a ::+ b ::* c".
        self assert: node isBinaryMessageSendSequenceNode.

        let binarySendSequence ref := node downCastFor: ASTBinaryMessageSendSequenceNode.
        let selectors := self extractBinarySendSequenceSelectors: binarySendSequence.
        let identifiers := self extractBinarySendSequenceIdentifiers: binarySendSequence.

        self assert: binarySendSequence isLowPrecedence.
        self assert: selectors asArraySlice equals: Std ImmutableString array(
            "+", "*"
        ).
        self assert: identifiers asArraySlice equals: Std ImmutableString array(
            "a", "b", "c"
        ).
    }.

    test: testKeywordMessage with: {
        let node := self parseSingleExpression: "a computeWith: b".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode arguments size equals: 1.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: messageNode arguments first isIdentifierReferenceNode.
        self assert: (messageNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testKeywordMessageNoReceiver with: {
        let node := self parseSingleExpression: "computeWith: b".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode arguments size equals: 1.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

        self assert: messageNode receiver isNil.

        self assert: messageNode arguments first isIdentifierReferenceNode.
        self assert: (messageNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testUnaryChainMessage with: {
        let node := self parseSingleExpression: "a hello; computeWith: c; << d; yourself".
        self assert: node isMessageChainNode.

        let chainNode ref := node downCastFor: ASTMessageChainNode.
        self assert: chainNode receiver isIdentifierReferenceNode.
        self assert: (chainNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
        self assert: chainNode messages size equals: 4.

        {
            let messageNode ref := chainNode messages first.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "hello".
            self assert: chainedNode arguments isEmpty
        }.

        {
            let messageNode ref := chainNode messages second.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "c".
        }.

        {
            let messageNode ref := chainNode messages third.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "<<".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "d".
        }.

        {
            let messageNode ref := chainNode messages fourth.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "yourself".
            self assert: chainedNode arguments isEmpty
        }.
    }.

    test: testBinaryChainMessage with: {
        let node := self parseSingleExpression: "a + b; computeWith: c; << d; yourself".
        self assert: node isMessageChainNode.

        let chainNode ref := node downCastFor: ASTMessageChainNode.
        self assert: chainNode receiver isIdentifierReferenceNode.
        self assert: (chainNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
        self assert: chainNode messages size equals: 4.

        {
            let messageNode ref := chainNode messages first.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "+".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
        }.

        {
            let messageNode ref := chainNode messages second.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "c".
        }.

        {
            let messageNode ref := chainNode messages third.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "<<".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "d".
        }.

        {
            let messageNode ref := chainNode messages fourth.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "yourself".
            self assert: chainedNode arguments isEmpty
        }.
    }.

    test: testKeywordChainMessage with: {
        let node := self parseSingleExpression: "a computeWith: b; computeWith: c; << d; yourself".
        self assert: node isMessageChainNode.

        let chainNode ref := node downCastFor: ASTMessageChainNode.
        self assert: chainNode receiver isIdentifierReferenceNode.
        self assert: (chainNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
        self assert: chainNode messages size equals: 4.

        {
            let messageNode ref := chainNode messages first.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
        }.

        {
            let messageNode ref := chainNode messages second.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "c".
        }.

        {
            let messageNode ref := chainNode messages third.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "<<".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "d".
        }.

        {
            let messageNode ref := chainNode messages fourth.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "yourself".
            self assert: chainedNode arguments isEmpty
        }.
    }.

    test: testKeywordChainMessageNoReceiver with: {
        let node := self parseSingleExpression: "computeWith: b; computeWith: c; << d; yourself".
        self assert: node isMessageChainNode.

        let chainNode ref := node downCastFor: ASTMessageChainNode.
        self assert: chainNode receiver isNil.
        self assert: chainNode messages size equals: 4.

        {
            let messageNode ref := chainNode messages first.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
        }.

        {
            let messageNode ref := chainNode messages second.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "computeWith:".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "c".
        }.

        {
            let messageNode ref := chainNode messages third.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "<<".

            self assert: chainedNode arguments size equals: 1.
            self assert: chainedNode arguments first isIdentifierReferenceNode.
            self assert: (chainedNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "d".
        }.

        {
            let messageNode ref := chainNode messages fourth.
            self assert: messageNode isMessageChainMessageNode.
            let chainedNode := messageNode downCastFor: ASTMessageChainMessageNode.
            self assert: chainedNode selector isSymbolLiteralNode.
            self assert: (chainedNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "yourself".
            self assert: chainedNode arguments isEmpty
        }.
    }.

    test: testAssignmentOperation with: {
        let node := self parseSingleExpression: "a:=b".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode arguments size equals: 1.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: ":=".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: messageNode arguments first isIdentifierReferenceNode.
        self assert: (messageNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testAssignmentOperation2 with: {
        let node := self parseSingleExpression: "a:=b:=c".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode arguments size equals: 1.
        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: ":=".

        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: messageNode arguments first isMessageSendNode.
        {
            let innerMessageNode ref := messageNode arguments first downCastFor: ASTMessageSendNode.
            self assert: innerMessageNode arguments size equals: 1.
            self assert: innerMessageNode selector isSymbolLiteralNode.
            self assert: (innerMessageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: ":=".

            self assert: innerMessageNode receiver isIdentifierReferenceNode.
            self assert: (innerMessageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".

            self assert: innerMessageNode arguments first isIdentifierReferenceNode.
            self assert: (innerMessageNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "c".
        }.
    }.

    test: testEmptyTuple with: {
        let node := self parseSingleExpression: "()".
        self assert: node isMakeTupleNode.

        let tupleNode ref := node downCastFor: ASTMakeTupleNode.
        self assert: tupleNode elements isEmpty
    }.

    test: testMakeTuple with: {
        let node := self parseSingleExpression: "a,".
        self assert: node isMakeTupleNode.

        let tupleNode ref := node downCastFor: ASTMakeTupleNode.
        self assert: tupleNode elements size equals: 1.

        self assert: tupleNode elements first isIdentifierReferenceNode.
        self assert: (tupleNode elements first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testMakeTuple2 with: {
        let node := self parseSingleExpression: "a,b".
        self assert: node isMakeTupleNode.

        let tupleNode ref := node downCastFor: ASTMakeTupleNode.
        self assert: tupleNode elements size equals: 2.

        self assert: tupleNode elements first isIdentifierReferenceNode.
        self assert: (tupleNode elements first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: tupleNode elements second isIdentifierReferenceNode.
        self assert: (tupleNode elements second downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testMakeTuple3 with: {
        let node := self parseSingleExpression: "a,b,".
        self assert: node isMakeTupleNode.

        let tupleNode ref := node downCastFor: ASTMakeTupleNode.
        self assert: tupleNode elements size equals: 2.

        self assert: tupleNode elements first isIdentifierReferenceNode.
        self assert: (tupleNode elements first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: tupleNode elements second isIdentifierReferenceNode.
        self assert: (tupleNode elements second downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testEmptyLiteralArray with: {
        let node := self parseSingleExpression: "#()".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements isEmpty
    }.

    test: testLiteralArray with: {
        let node := self parseSingleExpression: "#(a)".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements size equals: 1.

        self assert: arrayNode elements first isIdentifierReferenceNode.
        self assert: (arrayNode elements first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testLiteralArray2 with: {
        let node := self parseSingleExpression: "#(a b)".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements size equals: 2.

        self assert: arrayNode elements first isIdentifierReferenceNode.
        self assert: (arrayNode elements first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: arrayNode elements second isIdentifierReferenceNode.
        self assert: (arrayNode elements second downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testLiteralArray3 with: {
        let node := self parseSingleExpression: "#(hello:World: #b)".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements size equals: 2.

        self assert: arrayNode elements first isSymbolLiteralNode.
        self assert: (arrayNode elements first downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "hello:World:".

        self assert: arrayNode elements second isSymbolLiteralNode.
        self assert: (arrayNode elements second downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "b".
    }.

    test: testLiteralArray4 with: {
        let node := self parseSingleExpression: "#(* / // % + - << >> <= >= < > = == ~= ~~ & | && || ==> --> )".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        let operators mutable type: Std Collections Vector(Std ImmutableString).
        arrayNode elements do: {:each :: Void |
            self assert: each isSymbolLiteralNode.
            let value type: Std ImmutableString := (each downCastFor: ASTSymbolLiteralNode) value asArraySlice.
            operators add: value.
        }.

        self assert: operators asArraySlice equals: Std ImmutableString array(
            "*", "/", "//", "%", "+", "-", "<<", ">>",
            "<=", ">=", "<", ">", "=", "==", "~=", "~~", "&", "|", "&&",
            "||", "==>", "-->"
        ).
    }.

    test: testSourceWithEmptyLiteralArray with: {
        let node := self parseStringWithLiteralArrayContent: "".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements isEmpty
    }.

    test: testSourceWithLiteralArray with: {
        let node := self parseStringWithLiteralArrayContent: "a".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements size equals: 1.

        self assert: arrayNode elements first isIdentifierReferenceNode.
        self assert: (arrayNode elements first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testSourceWithLiteralArray2 with: {
        let node := self parseStringWithLiteralArrayContent: "a b".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements size equals: 2.

        self assert: arrayNode elements first isIdentifierReferenceNode.
        self assert: (arrayNode elements first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: arrayNode elements second isIdentifierReferenceNode.
        self assert: (arrayNode elements second downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testSourceWithLiteralArray3 with: {
        let node := self parseStringWithLiteralArrayContent: "hello:World: #b".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: arrayNode elements size equals: 2.

        self assert: arrayNode elements first isSymbolLiteralNode.
        self assert: (arrayNode elements first downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "hello:World:".

        self assert: arrayNode elements second isSymbolLiteralNode.
        self assert: (arrayNode elements second downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "b".
    }.

    test: testSourceWithLiteralArray4 with: {
        let node := self parseStringWithLiteralArrayContent: "* / // % + - << >> <= >= < > = == ~= ~~ & | && || ==> -->".
        self assert: node isLiteralArrayNode.

        let arrayNode ref := node downCastFor: ASTLiteralArrayNode.
        let operators mutable type: Std Collections Vector(Std ImmutableString).
        arrayNode elements do: {:each :: Void |
            self assert: each isSymbolLiteralNode.
            let value type: Std ImmutableString := (each downCastFor: ASTSymbolLiteralNode) value asArraySlice.
            operators add: value.
        }.

        self assert: operators asArraySlice equals: Std ImmutableString array(
            "*", "/", "//", "%", "+", "-", "<<", ">>",
            "<=", ">=", "<", ">", "=", "==", "~=", "~~", "&", "|", "&&",
            "||", "==>", "-->"
        ).
    }.

    test: testCallExpression with: {
        let node := self parseSingleExpression: "a()".
        self assert: node isCallNode.

        let callNode ref := node downCastFor: ASTCallNode.
        self assert: callNode callable isIdentifierReferenceNode.
        self assert: (callNode callable downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: callNode arguments isEmpty.
    }.

    test: testCallExpression2 with: {
        let node := self parseSingleExpression: "a(42)".
        self assert: node isCallNode.

        let callNode ref := node downCastFor: ASTCallNode.
        self assert: callNode callable isIdentifierReferenceNode.
        self assert: (callNode callable downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: callNode arguments first isIntegerLiteralNode.
        self assert: (callNode arguments first downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "42".
    }.

    test: testCallExpression3 with: {
        let node := self parseSingleExpression: "a(42, b)".
        self assert: node isCallNode.

        let callNode ref := node downCastFor: ASTCallNode.
        self assert: callNode callable isIdentifierReferenceNode.
        self assert: (callNode callable downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: callNode arguments first isIntegerLiteralNode.
        self assert: (callNode arguments first downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "42".

        self assert: callNode arguments second isIdentifierReferenceNode.
        self assert: (callNode arguments second downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testSubscriptExpression with: {
        let node := self parseSingleExpression: "a[42]".
        self assert: node isSubscriptNode.

        let subscriptNode ref := node downCastFor: ASTSubscriptNode.
        self assert: subscriptNode array isIdentifierReferenceNode.
        self assert: (subscriptNode array downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: subscriptNode index  isIntegerLiteralNode.
        self assert: (subscriptNode index downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "42".
    }.

    test: testQuoteNode with: {
        let node := self parseSingleExpression: "`'a".
        self assert: node isQuoteNode.

        let quoteNode ref := node downCastFor: ASTQuoteNode.
        self assert: quoteNode quoted isIdentifierReferenceNode.
        self assert: (quoteNode quoted downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testQuasiQuoteNode with: {
        let node := self parseSingleExpression: "``a".
        self assert: node isQuasiQuoteNode.

        let quoteNode ref := node downCastFor: ASTQuasiQuoteNode.
        self assert: quoteNode quoted isIdentifierReferenceNode.
        self assert: (quoteNode quoted downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testQuasiUnquoteNode with: {
        let node := self parseSingleExpression: "`,a".
        self assert: node isQuasiUnquoteNode.

        let unquoteNode ref := node downCastFor: ASTQuasiUnquoteNode.
        self assert: unquoteNode expression isIdentifierReferenceNode.
        self assert: (unquoteNode expression downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testSpliceNode with: {
        let node := self parseSingleExpression: "`@a".
        self assert: node isSpliceNode.

        let spliceNode ref := node downCastFor: ASTSpliceNode.
        self assert: spliceNode expression isIdentifierReferenceNode.
        self assert: (spliceNode expression downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".
    }.

    test: testUnaryMessageWithMacroSelector with: {
        let node := self parseSingleExpression: "a `,b".
        self assert: node isMessageSendNode.

        let messageNode ref := node downCastFor: ASTMessageSendNode.
        self assert: messageNode selector isQuasiUnquoteNode.

        let unquoteNode ref := messageNode selector downCastFor: ASTQuasiUnquoteNode.
        self assert: unquoteNode expression isIdentifierReferenceNode.
        self assert: (unquoteNode expression downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testBlockNode with: {
        let node := self parseSingleExpression: "{}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode blockClosureSignature isNil.
        self assert: blockNode pragmas isEmpty.
        self assert: blockNode expressionList isExpressionListNode.

        let expressionList ref := blockNode expressionList downCastFor: ASTExpressionListNode.
        self assert: expressionList expressions isEmpty.
    }.

    test: testBlockNode2 with: {
        let node := self parseSingleExpression: "{v}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode blockClosureSignature isNil.
        self assert: blockNode pragmas isEmpty.
        self assert: blockNode expressionList isExpressionListNode.

        let expressionList ref := blockNode expressionList downCastFor: ASTExpressionListNode.
        self assert: expressionList expressions size equals: 1.

        self assert: expressionList expressions first isIdentifierReferenceNode.
        self assert: (expressionList expressions first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "v".
    }.

    test: testBlockClosureNode with: {
        let node := self parseSingleExpression: "{|}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode blockClosureSignature isNotNil.
        self assert: blockNode blockClosureSignature isBlockClosureSignatureNode.
        self assert: blockNode pragmas isEmpty.
        self assert: blockNode expressionList isExpressionListNode.

        let signature ref := blockNode blockClosureSignature downCastFor: ASTBlockClosureSignatureNode.
        self assert: signature arguments isEmpty.
        self assert: signature returnType isNil.

        let expressionList ref := blockNode expressionList downCastFor: ASTExpressionListNode.
        self assert: expressionList expressions isEmpty.
    }.

    test: testBlockClosureNode2 with: {
        let node := self parseSingleExpression: "{:: Void |}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode blockClosureSignature isNotNil.
        self assert: blockNode blockClosureSignature isBlockClosureSignatureNode.
        self assert: blockNode pragmas isEmpty.
        self assert: blockNode expressionList isExpressionListNode.

        let signature ref := blockNode blockClosureSignature downCastFor: ASTBlockClosureSignatureNode.
        self assert: signature arguments isEmpty.
        self assert: signature returnType isIdentifierReferenceNode.
        self assert: (signature returnType downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "Void".

        let expressionList ref := blockNode expressionList downCastFor: ASTExpressionListNode.
        self assert: expressionList expressions isEmpty.
    }.

    test: testBlockClosureNode3 with: {
        let node := self parseSingleExpression: "{:a |}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode blockClosureSignature isNotNil.
        self assert: blockNode blockClosureSignature isBlockClosureSignatureNode.
        self assert: blockNode pragmas isEmpty.
        self assert: blockNode expressionList isExpressionListNode.

        let signature ref := blockNode blockClosureSignature downCastFor: ASTBlockClosureSignatureNode.
        self assert: signature arguments size equals: 1.

        let argument ref := signature arguments first downCastFor: ASTBlockClosureArgumentNode.
        self assert: argument type isNil.
        self assert: argument identifier isSymbolLiteralNode.
        self assert: (argument identifier downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "a".

        self assert: signature returnType isNil.

        let expressionList ref := blockNode expressionList downCastFor: ASTExpressionListNode.
        self assert: expressionList expressions isEmpty.
    }.

    test: testBlockClosureNode4 with: {
        let node := self parseSingleExpression: "{:a :(Int32)b :c |}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode blockClosureSignature isNotNil.
        self assert: blockNode blockClosureSignature isBlockClosureSignatureNode.
        self assert: blockNode pragmas isEmpty.
        self assert: blockNode expressionList isExpressionListNode.

        let signature ref := blockNode blockClosureSignature downCastFor: ASTBlockClosureSignatureNode.
        self assert: signature arguments size equals: 3.

        {
            let argument ref := signature arguments first downCastFor: ASTBlockClosureArgumentNode.
            self assert: argument type isNil.
            self assert: argument identifier isSymbolLiteralNode.
            self assert: (argument identifier downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "a".
        }.

        {
            let argument ref := signature arguments second downCastFor: ASTBlockClosureArgumentNode.
            self assert: argument type isIdentifierReferenceNode.
            self assert: (argument type downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "Int32".

            self assert: argument identifier isSymbolLiteralNode.
            self assert: (argument identifier downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "b".
        }.

        {
            let argument ref := signature arguments third downCastFor: ASTBlockClosureArgumentNode.
            self assert: argument type isNil.
            self assert: argument identifier isSymbolLiteralNode.
            self assert: (argument identifier downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "c".
        }.

        self assert: signature returnType isNil.

        let expressionList ref := blockNode expressionList downCastFor: ASTExpressionListNode.
        self assert: expressionList expressions isEmpty.
    }.

    test: testBlockClosureNode5 with: {
        let node := self parseSingleExpression: "{:(Float32)a :(Int32)b :: Float32 | a arcTan2: b }".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode blockClosureSignature isNotNil.
        self assert: blockNode blockClosureSignature isBlockClosureSignatureNode.
        self assert: blockNode pragmas isEmpty.
        self assert: blockNode expressionList isExpressionListNode.

        let signature ref := blockNode blockClosureSignature downCastFor: ASTBlockClosureSignatureNode.
        self assert: signature arguments size equals: 2.

        {
            let argument ref := signature arguments first downCastFor: ASTBlockClosureArgumentNode.
            self assert: argument type isIdentifierReferenceNode.
            self assert: (argument type downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "Float32".

            self assert: argument identifier isSymbolLiteralNode.
            self assert: (argument identifier downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "a".
        }.

        {
            let argument ref := signature arguments second downCastFor: ASTBlockClosureArgumentNode.
            self assert: argument type isIdentifierReferenceNode.
            self assert: (argument type downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "Int32".

            self assert: argument identifier isSymbolLiteralNode.
            self assert: (argument identifier downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "b".
        }.

        self assert: signature returnType isIdentifierReferenceNode.
        self assert: (signature returnType downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "Float32".

        let expressionList ref := blockNode expressionList downCastFor: ASTExpressionListNode.
        self assert: expressionList expressions size equals: 1.
        self assert: expressionList expressions first isMessageSendNode.

        let messageNode ref := expressionList expressions first downCastFor: ASTMessageSendNode.
        self assert: messageNode receiver isIdentifierReferenceNode.
        self assert: (messageNode receiver downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "a".

        self assert: messageNode selector isSymbolLiteralNode.
        self assert: (messageNode selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "arcTan2:".

        self assert: messageNode arguments size equals: 1.
        self assert: messageNode arguments first isIdentifierReferenceNode.
        self assert: (messageNode arguments first downCastFor: ASTIdentifierReferenceNode) identifier asArraySlice equals: "b".
    }.

    test: testMakeEmptyDictionary with: {
        let node := self parseSingleExpression: "#{}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements isEmpty.
    }.

    test: testMakeEmptyDictionary2 with: {
        let node := self parseSingleExpression: "#{.}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements isEmpty.
    }.

    test: testMakeEmptyDictionary3 with: {
        let node := self parseSingleExpression: "#{..}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements isEmpty.
    }.

    test: testMakeDictionary with: {
        let node := self parseSingleExpression: "#{A: 1}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 1.

        self assert: dictionaryNode elements first isDictionaryElementNode.
        let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
        self assert: element key isSymbolLiteralNode.
        self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

        self assert: element value isIntegerLiteralNode.
        self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
    }.

    test: testMakeDictionary2 with: {
        let node := self parseSingleExpression: "#{A:}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 1.

        self assert: dictionaryNode elements first isDictionaryElementNode.
        let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
        self assert: element key isSymbolLiteralNode.
        self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

        self assert: element value isNil.
    }.

    test: testMakeDictionary3 with: {
        let node := self parseSingleExpression: "#{A: 1 .. B: 2}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 2.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "2".
        }.
    }.

    test: testMakeDictionary4 with: {
        let node := self parseSingleExpression: "#{#A : 1 .. B: 2}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 2.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "2".
        }.
    }.

    test: testMakeDictionary5 with: {
        let node := self parseSingleExpression: "#{#A : 1 .. B: 2.}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 2.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "2".
        }.
    }.

    test: testMakeDictionary6 with: {
        let node := self parseSingleExpression: "#{A: 1. B: . C: .}".
        self assert: node isMakeDictionaryNode.

        let dictionaryNode ref := node downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 3.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isNil.
        }.

        {
            self assert: dictionaryNode elements third isDictionaryElementNode.
            let element ref := dictionaryNode elements third downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "C".

            self assert: element value isNil.
        }.
    }.

    test: testLiteralEmptyDictionary with: {
        let node := self parseSingleExpression: "#( #{} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements isEmpty.
    }.

    test: testLiteralEmptyDictionary2 with: {
        let node := self parseSingleExpression: "#( #{.} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements isEmpty.
    }.

    test: testLiteralEmptyDictionary3 with: {
        let node := self parseSingleExpression: "#( #{..} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements isEmpty.
    }.

    test: testLiteralDictionary with: {
        let node := self parseSingleExpression: "#( #{A: 1} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 1.

        self assert: dictionaryNode elements first isDictionaryElementNode.
        let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
        self assert: element key isSymbolLiteralNode.
        self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

        self assert: element value isIntegerLiteralNode.
        self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
    }.

    test: testLiteralDictionary2 with: {
        let node := self parseSingleExpression: "#( #{A:} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 1.

        self assert: dictionaryNode elements first isDictionaryElementNode.
        let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
        self assert: element key isSymbolLiteralNode.
        self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

        self assert: element value isNil.
    }.

    test: testLiteralDictionary3 with: {
        let node := self parseSingleExpression: "#( #{A: 1 .. B: 2} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 2.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "2".
        }.
    }.

    test: testLiteralDictionary4 with: {
        let node := self parseSingleExpression: "#( #{#A : 1 .. B: 2} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 2.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "2".
        }.
    }.

    test: testLiteralDictionary5 with: {
        let node := self parseSingleExpression: "#( #{#A : 1 .. B: 2.} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 2.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "2".
        }.
    }.

    test: testLiteralDictionary6 with: {
        let node := self parseSingleExpression: "#( #{A: 1. B: . C: .} )".
        self assert: node isLiteralArrayNode.

        let literalArrayNode ref := node downCastFor: ASTLiteralArrayNode.
        self assert: literalArrayNode elements size equals: 1.
        self assert: literalArrayNode elements first isMakeDictionaryNode.

        let dictionaryNode ref := literalArrayNode elements first downCastFor: ASTMakeDictionaryNode.
        self assert: dictionaryNode elements size equals: 3.

        {
            self assert: dictionaryNode elements first isDictionaryElementNode.
            let element ref := dictionaryNode elements first downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "A".

            self assert: element value isIntegerLiteralNode.
            self assert: (element value downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "1".
        }.

        {
            self assert: dictionaryNode elements second isDictionaryElementNode.
            let element ref := dictionaryNode elements second downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "B".

            self assert: element value isNil.
        }.

        {
            self assert: dictionaryNode elements third isDictionaryElementNode.
            let element ref := dictionaryNode elements third downCastFor: ASTDictionaryElementNode.
            self assert: element key isSymbolLiteralNode.
            self assert: (element key downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "C".

            self assert: element value isNil.
        }.
    }.

    test: testUnaryPragma with: {
        let node := self parseSingleExpression: "{<pragma>}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode pragmas size equals: 1.

        self assert: blockNode pragmas first isPragmaNode.
        let pragma ref := blockNode pragmas first downCastFor: ASTPragmaNode.
        self assert: pragma selector isSymbolLiteralNode.
        self assert: (pragma selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "pragma".

        self assert: pragma arguments isEmpty.
    }.

    test: testKeywordPragma with: {
        let node := self parseSingleExpression: "{<pragma: 42>}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode pragmas size equals: 1.

        self assert: blockNode pragmas first isPragmaNode.
        let pragma ref := blockNode pragmas first downCastFor: ASTPragmaNode.
        self assert: pragma selector isSymbolLiteralNode.
        self assert: (pragma selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "pragma:".

        self assert: pragma arguments size equals: 1.
        self assert: pragma arguments first isIntegerLiteralNode.
        self assert: (pragma arguments first downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "42".
    }.

    test: testKeywordPragma2 with: {
        let node := self parseSingleExpression: "{<pragma: 42 value: -1>}".
        self assert: node isBlockNode.

        let blockNode ref := node downCastFor: ASTBlockNode.
        self assert: blockNode pragmas size equals: 1.

        self assert: blockNode pragmas first isPragmaNode.
        let pragma ref := blockNode pragmas first downCastFor: ASTPragmaNode.
        self assert: pragma selector isSymbolLiteralNode.
        self assert: (pragma selector downCastFor: ASTSymbolLiteralNode) value asArraySlice equals: "pragma:value:".

        self assert: pragma arguments size equals: 2.
        self assert: pragma arguments first isIntegerLiteralNode.
        self assert: (pragma arguments first downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "42".
        self assert: pragma arguments second isIntegerLiteralNode.
        self assert: (pragma arguments second downCastFor: ASTIntegerLiteralNode) stringValue asArraySlice equals: "-1".
    }.
}.

} ## End of namespace Tests
}. ## End of namespace SysmelLanguage
}. ## End of namespace Compiler
}. ## End of namespace Sysmel
