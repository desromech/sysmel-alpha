namespace Smalltalk definition: {

Object extend: {
    method enclosedSetElement := self.
    method asSetElement := self.
}.

Set definition: {
    method asSet
        := self.

    method add: newObject := {
        let index := self scanFor: newObject.
        (array at: index) ifNil: {
            self atNewIndex: index put: newObject asSetElement
        }.

        newObject
    }.

    method remove: oldObject ifAbsent: aBlock := {
        let index := self scanFor: oldObject.
        (array at: index) ifNil: {
            return: aBlock value
        }.

        array at: index put: nil.
        tally := tally - 1u.
        self fixCollisionsFrom: index.

        oldObject
    }.

    method fixCollisionsFrom: (start: UIntPointer) := {
        let arraySize := array basicSize.
        let index mutable := start.
        let element mutable.
        until: (element := array at: (index := index % arraySize + 1u)) isNil do: {
            (let newIndex := self scanFor: element enclosedElement) = index ifFalse: {
                array swap: index with: newIndex
            }.
        }.
    }.

    method scanFor: key ::=> UIntPointer := {
        ## Make sure we at least have a size.
        let keyCount := self capacity.
        keyCount = 0 ifTrue: {
            self errorNoFreeSpace
        }.

        ## Find the natural key slot.
        let keySlot := (key hash castTo: UIntPointer) % keyCount.

        ## Perform linear probing.
        let i mutable := keySlot.
        while: i < keyCount do: {
            let slotKey := array __private __data[i].
            slotKey == nil || slotKey = key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let slotKey := array __private __data[i].
            slotKey == nil || slotKey = key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        self errorNoFreeSpace.
        return: 0
    }.

    method do: aBlock := {
        array do: {:each :: Void |
            each ifNotNil: {
                aBlock value: each
            }
        }.
        nil
    }.

    method like: key := {
        (array at: (self scanFor: key)) enclosedSetElement
    }.

    method intersection: aCollection := {
        let outputSet := self class new.
        aCollection do: {:each :: Void |
            (self includes: each) ifTrue: {
                outputSet add: each
            }
        }.

        outputSet
    }.
}.

}. ## End of namespace Smalltalk
