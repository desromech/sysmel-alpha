namespace Std definition: {
namespace Reflection definition: {

compileTime constant BasicInitializeFunctionPointerType := ((Void pointer) => Void) pointer.
compileTime constant CopyConstructorFunctionPointerType := ((Void pointer -- Void const pointer) => Void) pointer.
compileTime constant MoveConstructorFunctionPointerType := ((Void pointer -- Void pointer) => Void) pointer.
compileTime constant FinalizeFunctionPointerType := ((Void pointer) => Void) pointer.

}. ## End of namespace Reflection

## I am a native object that supports the basic construction and finalization
## methods, and I provide a convenient method for retrieving my type information.
class Object definition: {
    virtual method initialize ::=> Void := {
    }.

    virtual method finalize ::=> Void := {
    }.
}.

## I am a native object that is reference counted.
## I am typically used as the base class for all of the objects that have automatical memory management.
class RCObject superclass: Object; definition: {
    compileTime if: Compiler compilationTarget hasOperatingSystem then: {
        private field strongCounter_ type: AtomicUIntPointer.
        private field weakCounter_ type: AtomicUIntPointer.

        override method initialize => Void := {
            strongCounter_ store: 1 with: MemoryOrder Release.
            weakCounter_ store: 1 with: MemoryOrder Release.
        }.

        (inline method := (other: SelfType const ref)) => SelfType ref := {
            ## The counters should not be modified.
            self
        }.

        (inline method := (other: SelfType tempRef)) => SelfType ref := {
            ## The counters should not be modified.
            self
        }.
    }.
}.

}. ## End of namespace Std
