namespace Smalltalk definition: {

gcclass LimitedWriteStream superclass: WriteStream; definition: {
    field limit type: UIntPointer.
    field limitBlock.

    meta definition: {
        method defaultLimit => UIntPointer
            := 1000.

        method on: aCollection
            := self basicNew on: aCollection;
                limit: self defaultLimit;
                limitBlock: nil;
                yourself.

        method on: aCollection from: firstIndex to: lastIndex
            := self basicNew on: aCollection from: firstIndex to: lastIndex;
                limit: self defaultLimit;
                limitBlock: nil;
                yourself.


        method on: aCollection limit: anInteger limitBlock: aLimitBlock
            := self basicNew on: aCollection;
                limit: (anInteger castTo: UIntPointer);
                limitBlock: aLimitBlock;
                yourself.

        method with: aCollection
            := self basicNew with: aCollection;
                limit: self defaultLimit;
                limitBlock: nil;
                yourself.

        method with: aCollection from: firstIndex to: lastIndex
            := self basicNew with: aCollection from: firstIndex to: lastIndex;
                limit: self defaultLimit;
                limitBlock: nil;
                yourself.
    }.

    method limit
        := limit.

    method limit: (newLimit: UIntPointer) := {
        limit := newLimit.
        self
    }.

    method limitBlock
        := limitBlock.

    method limitBlock: newLimitBlock := {
        limitBlock := newLimitBlock.
        self
    }.

    method nextPut: anObject := {
        position >= limit
            ifTrue: { limitBlock value }
            ifFalse: {super nextPut: anObject}.
        anObject
    }.

    method pastEndPut: anObject := {
        (collection size castTo: UIntPointer) >= limit ifTrue: { limitBlock value }.
        super pastEndPut: anObject
    }.

    method nextPutAll: aCollection := {
        aCollection class ~~ collection class ifTrue: {
            return: (super nextPutAll: aCollection)
        }.

        let newPosition := position + (aCollection size castTo: UIntPointer).
        newPosition > limit ifTrue: {
            super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).
            limitBlock value.
		    return: aCollection
        }.

        newPosition > writeLimit ifTrue: {
            self growBy: newPosition - writeLimit
        }.

        collection replaceFrom: position until: newPosition with: aCollection.

        position := newPosition.
        return: aCollection
    }.

    method setLimit: anInteger limitBlock: aBlock := {
        limit := anInteger castTo: UIntPointer.
        limitBlock := aBlock.
        position > limit ifTrue: {
            position := limit.
            limitBlock value
        }.
        self
    }.
}.

} ## End of namespace Smalltalk
