namespace Smalltalk definition: {

Integer extend: {
    meta definition: {
        method new: length neg: neg
            := neg
                ifTrue: { return: (LargeNegativeInteger new: length) }
                ifFalse: { return: (LargePositiveInteger new: length) }.
    }.

    method isInteger := true.
	method asInteger := self.
    method isLiteral := true.

    method asFraction
        := self.

	method floor := self.
	method ceiling := self.
	method truncated := self.
	method rounded := self.
	method fract := 0.
	method fractionPart := 0.
    method integerPart := self.

    method round: numberOfWishedDecimal
        := self.

    method bitInvert
        := -1 - self.

    method bitInvert32
        := self bitXor: 16rFFFFFFFF.

    method bitAt: anInteger
        := (self >> (anInteger - 1)) & 1.

    method allMask: mask
        := mask = (self bitAnd: mask).

    method anyMask: mask
        := 0 ~= (self bitAnd: mask).

    method noMask: mask
        := 0 = (self bitAnd: mask).

    method highBit
        := self subclassResponsibility.

    method highBitOfMagnitude
        := self subclassResponsibility.

    method lowBit
        := self subclassResponsibility.

    method timesRepeat: aBlock := {
        1 to: self do: {
            aBlock value
        }.
        self
    }.

    method normalize := self.

    method byteAt: (index: UIntPointer) ::=> UInt8 := {
        self subclassResponsibility.
        0 castTo: UInt8
    }.

    method byteAt: (index: UIntPointer) put: (value: UInt8)
        := self subclassResponsibility.

    method bytesCount => UIntPointer := {
        self subclassResponsibility.
        0
    }.

    method replaceFrom: start to: stop with: replacement startingAt: repStart := {
        let j mutable := repStart castTo: UIntPointer.
        (start castTo: UIntPointer) to: (stop castTo: UIntPointer) do: {:i :: Void |
            self byteAt: i put: ((replacement byteAt: j) castTo: UInt8).
            j := j + 1u.
        }.

        self
    }.

    method bytesCompare: arg := {
		arg isInteger ifFalse: {self error: "Expected an integer argument."}.

		let integerArg := arg reinterpretCastTo: Integer.
		let len := self bytesCount.
		let arglen := integerArg bytesCount.
        len ~= arglen ifTrue: {
            len < arglen
                ifTrue: {return: -1}
                ifFalse: {return: 1}
        }.

		(len castTo: IntPointer) to: 1 by: -1 do: {:i :: Void |
            let leftByte := self byteAt: (i castTo: UIntPointer).
            let rightByte := integerArg byteAt: (i castTo: UIntPointer).
            leftByte ~= rightByte ifTrue: {
                leftByte < rightByte
                    ifTrue: {return: -1}
                    ifFalse: {return: 1}
            }
		}.

        0
	}.

    method digitAdd: arg := {
		arg isInteger ifFalse: {self error: "Expected an integer argument."}.

		let integerArg := arg reinterpretCastTo: Integer.
		let accum mutable type: UInt32 := 0.
		let len := self bytesCount.
		let arglen := integerArg bytesCount.
		let resultLen := len max: arglen.
		let sum mutable := Integer new: len neg: self negative.
		1 to: resultLen do: {:i :: Void |
			accum := (accum >> 8) + (self byteAt: i) + (integerArg byteAt: i).
			sum byteAt: i put: (accum & 16rff castTo: UInt8).
		}.
		accum > 255 ifTrue: {
			sum := sum growby: 1.
			sum at: sum bytesCount put: (accum >> 8 castTo: UInt8)
		}.

		sum
	}.

    method = aNumber := {
        aNumber isNumber ifFalse: { return: false }.
        aNumber isInteger ifTrue: {
            aNumber negative == self negative
                ifTrue: {return: (self bytesCompare: aNumber) = 0}
                ifFalse: {return: false}
        }.

        aNumber adaptToInteger: self andCompare: #=
    }.

    method < aNumber := {
        aNumber isNumber ifFalse: { return: false }.
        aNumber isInteger ifTrue: {
            aNumber negative == self negative
                ifTrue: {
                    self negative
                        ifTrue: {return: (self bytesCompare: aNumber) > 0}
                        ifFalse: {return: (self bytesCompare: aNumber) < 0}}
                ifFalse: {return: self negative}
        }.

        aNumber adaptToInteger: self andCompare: #<
    }.

    method <= aNumber := {
        aNumber isNumber ifFalse: { return: false }.
        aNumber isInteger ifTrue: {
            aNumber negative == self negative
                ifTrue: {
                    self negative
                        ifTrue: {return: (self bytesCompare: aNumber) >= 0}
                        ifFalse: {return: (self bytesCompare: aNumber) <= 0}}
                ifFalse: {return: self negative}
        }.

        aNumber adaptToInteger: self andCompare: #<=
    }.

    method > aNumber := {
        aNumber isNumber ifFalse: { return: false }.
        aNumber isInteger ifTrue: {
            aNumber negative == self negative
                ifTrue: {
                    self negative
                        ifTrue: {return: (self bytesCompare: aNumber) < 0}
                        ifFalse: {return: (self bytesCompare: aNumber) > 0}}
                ifFalse: {return: self negative}
        }.

        aNumber adaptToInteger: self andCompare: #>
    }.

    method >= aNumber := {
        aNumber isNumber ifFalse: { return: false }.
        aNumber isInteger ifTrue: {
            aNumber negative == self negative
                ifTrue: {
                    self negative
                        ifTrue: {return: (self bytesCompare: aNumber) <= 0}
                        ifFalse: {return: (self bytesCompare: aNumber) >= 0}}
                ifFalse: {return: self negative}
        }.

        aNumber adaptToInteger: self andCompare: #>=
    }.

    method * aNumber := {
        aNumber isInteger ifTrue: {
            return: (self digitMultiply: aNumber neg: self negative ~~ aNumber negative)
        }.

        aNumber adaptToInteger: self andSend: #"*"
    }.

    method + aNumber := {
        aNumber isInteger ifTrue: {
            self negative == aNumber negative
                ifTrue: {return: (self digitAdd: aNumber) normalize}
                ifFalse: {return: (self digitSubtract: aNumber)}
        }.
        aNumber isFraction ifTrue: {
            return: (Fraction numerator: self * aNumber denominator + aNumber numerator denominator: aNumber denominator)
        }.

        aNumber adaptToInteger: self andSend: #+
    }.

    method - aNumber := {
        aNumber isInteger ifTrue: {
            self negative == aNumber negative
                ifTrue: {return: (self digitSubtract: aNumber)}
                ifFalse: {return: (self digitAdd: aNumber) normalize}
        }.
        aNumber isFraction ifTrue: {
            return: (Fraction numerator: self * aNumber denominator - aNumber numerator denominator: aNumber denominator)
        }.

        aNumber adaptToInteger: self andSend: #-
    }.

    method / aNumber := {
        aNumber isInteger ifTrue: {
            let quoRem := self digitDiv: aNumber neg: self negative ~~ aNumber negative.
            (quoRem at: 2) = 0
                ifTrue: {return: (quoRem at: 1) normalize }
			    ifFalse: {return: (Fraction numerator: self denominator: aNumber) reduced }
        }.

        aNumber adaptToInteger: self andSend: #/
    }.

    method factorial := {
        self = 0 ifTrue: { return: 1}.
        self > 0 ifTrue: { return: self * (self - 1) factorial }.
        self error: "Not valid for negative integers"
    }.

    method hex
        := self storeStringBase: 16.

    method storeStringHex
        := self storeStringBase: 16.

    method radix: base
        := self printStringBase: base.

    method printStringHex
        := self printStringBase: 16.

    method printStringLength: minimum
        := self printStringLength: minimum padded: false.

    method printStringLength: minimum padded: zeroFlag
        := self printStringBase: 10 length: minimum padded: zeroFlag.

    method printStringBase: base length: minimum padded: zeroFlag
        := String streamContents: {:s :: Void | self printOn: s base: base length: minimum padded: zeroFlag }.

    method storeOn: aStream base: base := {
        let integer mutable := self asProtoObject.
        self negative ifTrue: {
            aStream nextPut: '-'.
            integer := self negated
        }.
        base = 10 ifFalse: {
            aStream nextPutAll: base printString; nextPut: 'r'
        }.
        integer printOn: aStream base: base
    }.

}.

}. ## End of namespace Smalltalk
