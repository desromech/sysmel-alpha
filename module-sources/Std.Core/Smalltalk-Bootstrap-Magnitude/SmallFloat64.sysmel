namespace Smalltalk definition: {

SmallFloat64 extend: {
	meta definition: {
		method basicNew
			:= self error: "SmallFloat64s can only be created by performing arithmetic".

		method basicNew: (variableSize: UIntPointer)
			:= self basicNew.

	}.

	method negated
		:= self __decodeSmallFloat negated.

	method sqrt := {
		let selfValue := self __decodeSmallFloat.
		selfValue < 0 ifTrue: {
			return: (DomainError signal: "sqrt is undefined for negative numbers.")
		}.

		selfValue sqrt.
	}.

	method abs
		:= self __decodeSmallFloat abs.

	method sign
		:= self __decodeSmallFloat sign castTo: IntPointer.

	method floor
		:= self __decodeSmallFloat floor castTo: Int64.

	method ceiling
		:= self __decodeSmallFloat ceiling castTo: Int64.

	method truncated
		:= self __decodeSmallFloat truncated castTo: Int64.

	method rounded
		:= self __decodeSmallFloat rounded castTo: Int64.

	method fract
		:= self __decodeSmallFloat fract.

	method fractionPart
		:= self __decodeSmallFloat fract.

	method exp
		:= self __decodeSmallFloat exp.

	method exp2
		:= self __decodeSmallFloat exp2.

	method ln
		:= self __decodeSmallFloat ln.

	method log2
		:= self __decodeSmallFloat log2.

	method = aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a = b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a = b
		}.

		super = aNumber
	}.

	method ~= aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a ~= b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a ~= b
		}.

		super ~= aNumber
	}.

	method < aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a < b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a < b
		}.

		super < aNumber
	}.

	method <= aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a <= b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a <= b
		}.

		super <= aNumber
	}.

	method > aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a > b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a > b
		}.

		super > aNumber
	}.

	method >= aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a >= b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a >= b
		}.

		super >= aNumber
	}.

	method <=> aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a <=> b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a <=> b
		}.

		super <=> aNumber
	}.

	method + aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a + b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a + b
		}.

        super + aNumber
    }.

	method - aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a - b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a - b
		}.

        super - aNumber
    }.

	method * aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			return: a * b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a * b
		}.

        super * aNumber
    }.

	method / aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallInteger.
			b = 0 ifTrue: {
				(ZeroDivide dividend: aNumber) signal
			}.
			return: a / b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallFloat.
			let b := aNumber __decodeSmallOrBoxedFloat.
			b = 0 ifTrue: {
				(ZeroDivide dividend: aNumber) signal
			}.
			return: a / b
		}.

        super / aNumber
    }.

	method printOn: aStream := {
        let floatPrinter mutable type: Std BasicValueFloatPrinter.
        floatPrinter nextPutDouble: self __decodeSmallFloat.
        floatPrinter printOn: aStream.

        self
    }.

    method printOnNativeTextStreamWriter: (writer: Std IO TextStreamWriter ref) := {
        writer << self __decodeSmallFloat.
		self
    }.

	method copy := self.
	method deepCopy := self.
	method shallowCopy := self.
	method clone := self.
}.
}. ## End of namespace Smalltalk
