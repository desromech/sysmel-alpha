namespace Stdn definition: {
namespace Graphics definition: {
namespace GUI definition: {

class Window.
class WindowCreationInfo.

#**
 * I represent an interface into a window system window.
 *#
class WindowSystem superclass: Object; definition: {
    public field targetFrameRate type: Stdn Chrono Time.

    protected field globalEventHandlers type: Stdn Collections Vector(EventHandlerPtr).

    meta definition: {
        global MainWindowSystem mutable type: WindowSystemRef.

        method activeWindowSystem: (aWindowSystem: WindowSystemRef const ref) ::=> Void
            := MainWindowSystem := aWindowSystem.

        method validActiveWindowSystem => WindowSystemRef
            := MainWindowSystem.
    }.

    method registerGlobalEventHandler: (globalHandler: EventHandlerPtr const ref) ::=> Void := {
        globalEventHandlers add: globalHandler
    }.

    method unregisterGlobalEventHandler: (globalHandler: EventHandlerPtr const ref) ::=> Void := {
        globalEventHandlers remove: globalHandler
    }.

    virtual method createWindow: (description: WindowCreationInfo const ref) ::=> Window sharedPointer
        := Window sharedPointer nil.

    virtual method createWindowWithTitle: (title: Stdn String const ref) extent: (extent: Int32x2) ::=> Window sharedPointer := {
        let creationInfo mutable type: WindowCreationInfo.
        creationInfo
            title: title;
            extent: extent.

        self createWindow: creationInfo.
    }.

    virtual method createWindowWithTitle: (title: Stdn String const ref) position: (position: Int32x2) extent: (extent: Int32x2) ::=> Window sharedPointer := {
        let creationInfo mutable type: WindowCreationInfo.
        creationInfo
            title: title;
            position: position;
            extent: extent.

        self createWindow: creationInfo.
    }.

    ## Do we have to finish the main loop?
    virtual method isQuitting => Boolean8
        := false.

    protected field mainLoopOldTicks type: Stdn Chrono Time.
    protected field mainLoopAccumulatedTicks type: Stdn Chrono Time.
    protected field mainLoopFrameStartTicks type: Stdn Chrono Time.
    protected field mainLoopStartTicks type: Stdn Chrono Time.
    protected field mainLoopFrameCount type: UInt32.

    ## Run the default main loop.
    virtual method runMainLoop => Int32 := {
        mainLoopOldTicks := Stdn Chrono now().
        mainLoopAccumulatedTicks := 0.
        mainLoopStartTicks := Stdn Chrono now().

        compileTime if: Compiler compilationTarget isWebAssembly then: {
            Emscripten emscripten_set_main_loop_arg(windowSystemMainLoopCallback address, self address, targetFrameRate castTo: Int32, 1).
        } else: {

            until: self isQuitting do: {
                self mainLoopIteration.

                targetFrameRate > 0 ifTrue: {
                    let ticksPerFrame := Stdn Chrono TicksPerSecond / targetFrameRate.
                    let targetNextFrameTime := mainLoopFrameStartTicks + ticksPerFrame.
                    Stdn Chrono sleepUntil(targetNextFrameTime)
                } ifFalse: {
                    self waitForNextEventOrTimeout.
                }.
            }.
        }.

        return: 0
    }.

    #**
     * A single iteration of the main loop.
     *#
    virtual method mainLoopIteration => Void := {
        let ticksPerFrame := Stdn Chrono TicksPerSecond / targetFrameRate.

        mainLoopFrameStartTicks := Stdn Chrono now().
        self pollAndPumpEvents.

        let deltaTicks := mainLoopFrameStartTicks - mainLoopOldTicks.
        mainLoopAccumulatedTicks := mainLoopAccumulatedTicks + deltaTicks.

        let deterministicFrameCount := mainLoopAccumulatedTicks / ticksPerFrame max: 0.
        mainLoopAccumulatedTicks := mainLoopAccumulatedTicks - deterministicFrameCount*ticksPerFrame.

        ## Send the tick events
        {
            let event mutable type: TickEvent.
            event
                ticks: mainLoopFrameStartTicks - mainLoopStartTicks;
                deterministicDelta: ticksPerFrame;
                deterministicRemainingDelta: mainLoopAccumulatedTicks;
                deterministicFrameCount: (deterministicFrameCount castTo: UInt32);
                mainLoopFrameCount: mainLoopFrameCount;
                delta: deltaTicks.
            self broadcastEvent: event.
        }.

        mainLoopFrameCount := mainLoopFrameCount + 1.
        mainLoopOldTicks := mainLoopFrameStartTicks.
    }.

    #**
     * Poll for events non-blockingly and then pump the events into the actual windows.
     *#
    virtual method pollAndPumpEvents => Void := {

    }.

    #**
     * Wait and pump the next, or until something times out.
     *#
    virtual method waitForNextEventOrTimeout => Void := {

    }.

    #**
     * Broadcast and event into all of the windows.
     *#
    virtual method broadcastEvent: (event: Event ref) ::=> Void := {
        globalEventHandlers do: {:each :: Void |
            each _ processEvent: event.
        }
    }.
}.

compileTime if: Compiler compilationTarget isWebAssembly then: {
function windowSystemMainLoopCallback(windowSystemPointer: Void pointer) => Void := {
    (windowSystemPointer reinterpretCastTo: WindowSystem pointer) _ mainLoopIteration
}.
}.

compileTime constant WindowSystemRef := WindowSystem sharedPointer.
compileTime constant WindowSystemWeakRef := WindowSystem weakPointer.

## The main global window system. This one is used by the Smalltalk style IDE tools.

}. ## End of namespace GUI
}. ## End of namespace Graphics
}. ## End of namespace Stdn
