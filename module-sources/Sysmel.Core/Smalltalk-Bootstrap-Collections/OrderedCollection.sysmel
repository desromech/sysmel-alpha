namespace Smalltalk definition: {

#**
 * A vector where elements can be added at the end and in the beginning with amortized O(1) cost.
 * Most of this implementation is copied from Pharo.
 *#
OrderedCollection definition: {
    field array type: Array.
    field firstIndex type: UIntPointer.
    field lastIndex type: UIntPointer.

    meta extend: {
        method new
            := self new: 10.

        method new: (initialCapacity: UIntPointer)
            := self basicNew setCollection: (self allocateStorageArrayWithCapacity: initialCapacity).

        method newFrom: aCollection := {
            let result := self new: (aCollection size castTo: UIntPointer).
            result addAll: aCollection.
            result
        }.

        method allocateStorageArrayWithCapacity: (newCapacity: UIntPointer) ::=> Array
            := Array basicNew: newCapacity.
    }.

    method asOrderedCollection
        := self.

    method with: otherCollection collect: aBlock := {
		otherCollection size = self size ifFalse: {self errorSizeMismatch}.
		let result := self species new: self size.
		1 to: self size do: {:i :: Void |
			result addLast:
				(aBlock value: (self at: i) value: (otherCollection at: i))
		}.
		result
	}.

    method add: newObject
        := self addLast: newObject.

    method addLast: newObject := {
        lastIndex == array size ifTrue: {self makeRoomAtLast}.
        lastIndex := lastIndex + 1 .
        array at: lastIndex put: newObject.
        newObject
    }.

    method at: (index: UIntPointer) := {
        index < 1 ifTrue: {self errorSubscriptBounds: index}.
        let elementIndex := index + firstIndex - 1.
        elementIndex > lastIndex ifTrue: { self errorSubscriptBounds: index}.
        array at: elementIndex
    }.

    method at: (index: UIntPointer) put: anElement := {
        index < 1 ifTrue: {self errorSubscriptBounds: index}.
        let elementIndex := index + firstIndex - 1.
        elementIndex > lastIndex ifTrue: { self errorSubscriptBounds: index}.
        array at: elementIndex put: anElement
    }.

    method at: index ifAbsentPut: block := {
        let v mutable.
        index <= self size ifTrue: {
            v := self at: (index castTo: UIntPointer).
            return: (v ifNotNil: v ifNil: {self at: (index castTo: UIntPointer) put: block value})
        }.

        while: (self size < index) do: {self add: nil}.
        self at: (index castTo: UIntPointer) put: block value
    }.

    method setCollection: theArray := {
        array := theArray reinterpretCastTo: Array.
        self reset.
        self
    }.

    method remove: oldObject ifAbsent: absentBlock := {
        firstIndex to: lastIndex do: {:index :: Void |
            (oldObject = (array at: index)) ifTrue: {
                self removeIndex: index.
                return: oldObject
            }
        }.

        absentBlock value
    }.

    method removeIndex: index := {
        let removedIndex := index castTo: UIntPointer.
        array replaceFrom: removedIndex until: lastIndex with: array startingAt: removedIndex.
        array at: lastIndex put: nil.
	    lastIndex := lastIndex - 1.
        self
    }.

    method removeAll := {
        self setCollection: (self allocateStorageArrayWithCapacity: array basicSize).
        self.
    }.

    method removeLast := {
        self emptyCheck.
        let lastObject := array at: lastIndex.
        array at: lastIndex put: nil.
        lastIndex := lastIndex - 1.
        lastObject
    }.

    method reset
        := self resetTo: 1.

    method resetTo: (index: UIntPointer) := {
        firstIndex := index.
        lastIndex := index - 1.
        self
    }.

    method makeRoomAtLast := {
        let tally := self size.
        tally * 2 >= lastIndex ifTrue: {
            return: self growAtLast.
        }.
        tally == 0 ifTrue: {
            return: (self resetTo: 1)
        }.

        let newLastIndex := lastIndex // 2.
    	let newFirstIndex := newLastIndex - lastIndex + firstIndex.
        0 until: tally do: {:(UIntPointer)i :: Void |
            array at: newFirstIndex + i put: (array at: firstIndex + i).
        }.

        firstIndex := newFirstIndex.
        lastIndex := newLastIndex.
        self
    }.

    method size => UIntPointer
        := lastIndex - firstIndex + 1.

    method growAtLast := {
        let newCapacity := array basicSize * 2 max: 1.
        let newArray := self allocateStorageArrayWithCapacity: newCapacity.
        let size := self size.
        firstIndex to: lastIndex do: {:(UIntPointer)i :: Void |
            newArray at: i put: (array at: i)
        }.

        array := newArray.
        self
    }.

    method postCopy := {
        array := array copy reinterpretCastTo: Array.
        self
    }.

    method allocateStorageArrayWithCapacity: (newCapacity: UIntPointer) ::=> Array
        := (self class allocateStorageArrayWithCapacity: newCapacity) reinterpretCastTo: Array.
}.

}.
