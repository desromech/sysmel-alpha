namespace Smalltalk definition: {

SequenceableCollection definition: {
	meta definition: {
		method streamSpecies
			:= self.

		method streamContents: unaryBlock
			:= self new: 100 streamContents: unaryBlock.

		method new: initialSize streamContents: unaryBlock := {
			let stream := WriteStream on: (self streamSpecies new: initialSize).
			unaryBlock value: stream.
			stream contents
		}.

		method streamContents: unaryBlock limitedTo: sizeLimit := {
			let stream mutable.
			stream := LimitedWriteStream
				on: (self streamSpecies new: (sizeLimit min: 100))
				limit: sizeLimit
				limitBlock: {:: Void | return: stream contents }.
			unaryBlock value: stream.
			stream contents
		}.
	}.

	method asArray
		:= Array withAll: self.

	method asByteArray
		:= ByteArray withAll: self.

	method asFloatArray
		:= FloatArray withAll: self.

	method asIntegerArray
		:= IntegerArray withAll: self.

	method asWordArray
		:= WordArray withAll: self.

	method = otherCollection := {
		self == otherCollection ifTrue: {return: true}.
		self species == otherCollection species ifFalse: {return: false}.
		self hasEqualElements: otherCollection
	}.

	method hasEqualElements: otherCollection := {
		(otherCollection isKindOf: SequenceableCollection) ifFalse: {return: false}.
		let size := self size castTo: UIntPointer.
		let otherSize := otherCollection size castTo: UIntPointer.
		size = otherSize ifFalse: {return: false}.
		1 to: size do: {:i :: Void |
			(self at: i) = (otherCollection at: i) ifFalse: {
				return: false
			}.
		}.

		true
	}.

	method hash := {
		let hash mutable := self species hash castTo: UInt32.
		1 to: (self size castTo: UIntPointer) do: {:i :: Void |
			hash := (hash + ((self at: i) hash castTo: UInt32)) * 1664525u castTo: UInt32
		}.
		hash
	}.

	method do: aBlock := {
		1 to: self size do: {:i :: Void |
			aBlock value: (self at: i)
		}.
		nil
	}.

	method pairsDo: aBlock := {
		1 to: (self size castTo: UIntPointer) / 2 do: {:i :: Void |
			aBlock value: (self at: i*2 - 1) value: (self at: i*2)
		}.
		self
	}.

	method keysAndValuesDo: aBlock := {
		1 to: self size do: {:i :: Void |
			aBlock value: i value: (self at: i)
		}.
		nil
	}.

	method doWithIndex: aBlock := {
		1 to: self size do: {:i :: Void |
			aBlock value: (self at: i) value: i
		}.
		nil
	}.

	method collect: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void |
			result at: i put: (aBlock value: (self at: i))
		}.
		result
	}.

	method collectWithIndex: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void|
			result at: i put: (aBlock value: (self at: i) value: i)
		}.
		result
	}.

	method collect: aBlock as: aClass
		:= (aClass new: self size) fillFrom: self with: aBlock.

	method select: aPredicate := {
		self class new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifTrue: {
					stream nextPut: element
				}
			}
		}
	}.

	method reject: aPredicate := {
		self class new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifFalse: {
					stream nextPut: element
				}
			}
		}
	}.

	method copyWithSize: (newSize: UIntPointer) := {
		let result := self species new: newSize.
		let copySize := newSize min: (self size castTo: UIntPointer).
		1 to: copySize do: {:i :: Void |
			result at: i put: (self at: i)
		}.
		result
	}.

	method copyWith: anElement := {
		let size := self size.
		let result := self species new: size + 1.
		1 to: size do: {:i :: Void |
			result at: i put: (self at: i)
		}.
		result at: size + 1 put: anElement.
		result
	}.

	method grownBy: (extraSize: UIntPointer)
		:= self copyWithSize: (self size castTo: UIntPointer) + extraSize.

	method replaceFrom: (startIndex: UIntPointer) until: (endIndex: UIntPointer) with: other := {
		startIndex until: endIndex do: {:i :: Void |
			self at: i + 1 put: (other at: i - startIndex + 1)
		}.
		self
	}.

	method -- other := {
		let mySize := self size castTo: UIntPointer.
		let otherSize := other size castTo: UIntPointer.
		let result := self copyWithSize: mySize + otherSize.
		result replaceFrom: mySize until: mySize + otherSize with: other.
		result
	}.

	compileTime compileLanguage: #pharoMethodEmbedded source: "
		, other
			^ self -- other
	".

	method first := self at: 1.
	method second := self at: 2.
	method third := self at: 3.
	method fourth := self at: 4.
	method fifth := self at: 5.
	method sixth := self at: 6.
	method seventh := self at: 7.
	method eighth := self at: 8.
	method ninth := self at: 9.

	method last := self at: self size.

	method atAllPut: value := {
		1 to: self size do: {:i :: Void |
			self at: i put: value
		}.
		self
	}.

	method indexOf: anElement
		:= self indexOf: anElement ifAbsent: 0.

	method indexOf: anElement ifAbsent: exceptionBlock
		:= self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock.

	method indexOf: anElement startingAt: start
	 	:= self indexOf: anElement startingAt: start ifAbsent: 0.

	method indexOf: anElement startingAt: start ifAbsent: exceptionBlock := {
		(start castTo: UIntPointer) to: (self size castTo: UIntPointer) do: {:index :: Void |
			(self at: index) = anElement ifTrue: {
				return: index
			}
		}.

		exceptionBlock value
	}.

	method writeStream
		:= WriteStream on: self.

	method readStream
		:= ReadStream on: self.
}.

}. ## End of namespace Smalltalk.
