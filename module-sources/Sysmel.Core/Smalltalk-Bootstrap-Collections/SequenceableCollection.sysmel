namespace Smalltalk definition: {

SequenceableCollection definition: {
	meta definition: {
		method streamSpecies
			:= self.

		method streamContents: unaryBlock
			:= self new: 100 streamContents: unaryBlock.

		method new: initialSize streamContents: unaryBlock := {
			let stream := WriteStream on: (self streamSpecies new: initialSize).
			unaryBlock value: stream.
			stream contents
		}.

		method streamContents: unaryBlock limitedTo: sizeLimit := {
			let stream mutable.
			stream := LimitedWriteStream
				on: (self streamSpecies new: (sizeLimit min: 100))
				limit: sizeLimit
				limitBlock: {:: Void | return: stream contents }.
			unaryBlock value: stream.
			stream contents
		}.
	}.

	method asArray
		:= Array withAll: self.

	method asByteArray
		:= ByteArray withAll: self.

	method asFloatArray
		:= FloatArray withAll: self.

	method asIntegerArray
		:= IntegerArray withAll: self.

	method asWordArray
		:= WordArray withAll: self.

	method = otherCollection := {
		self == otherCollection ifTrue: {return: true}.
		self species == otherCollection species ifFalse: {return: false}.
		self hasEqualElements: otherCollection
	}.

	method hasEqualElements: otherCollection := {
		(otherCollection isKindOf: SequenceableCollection) ifFalse: {return: false}.
		let size := self size castTo: UIntPointer.
		let otherSize := otherCollection size castTo: UIntPointer.
		size = otherSize ifFalse: {return: false}.
		1 to: size do: {:i :: Void |
			(self at: i) = (otherCollection at: i) ifFalse: {
				return: false
			}.
		}.

		true
	}.

	method hash := {
		let hash mutable := self species hash castTo: UInt32.
		1 to: (self size castTo: UIntPointer) do: {:i :: Void |
			hash := (hash + ((self at: i) hash castTo: UInt32)) * 1664525u castTo: UInt32
		}.
		hash
	}.

	method do: aBlock := {
		1 to: (self size castTo: UIntPointer) do: {:i :: Void |
			aBlock value: (self at: i)
		}.
		nil
	}.

	method reverseDo: aBlock := {
		(self size castTo: IntPointer) to: 1 by: -1 do: {:i :: Void |
			aBlock value: (self at: i)
		}.
		nil
	}.

	method pairsDo: aBlock := {
		1 to: (self size castTo: UIntPointer) / 2 do: {:i :: Void |
			aBlock value: (self at: i*2 - 1) value: (self at: i*2)
		}.
		self
	}.

	method keysAndValuesDo: aBlock := {
		1 to: self size do: {:i :: Void |
			aBlock value: i value: (self at: i)
		}.
		nil
	}.

	method with: otherCollection do: aBlock := {
		otherCollection size = self size ifFalse: {self errorSizeMismatch}.
		1 to: self size do: {:i :: Void |
			aBlock value: (self at: i) value: (otherCollection at: i)
		}.
		self
	}.

	method with: otherCollection collect: aBlock := {
		otherCollection size = self size ifFalse: {self errorSizeMismatch}.
		let result := self species new: self size.
		1 to: self size do: {:i :: Void |
			result at: i put:
				(aBlock value: (self at: i) value: (otherCollection at: i))
		}.
		result
	}.

	method withIndexDo: aBlock := {
		1 to: self size do: {:i :: Void |
			aBlock value: (self at: i) value: i
		}.
		nil
	}.

	method doWithIndex: aBlock
		:= self withIndexDo: aBlock.

	method collect: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void |
			result at: i put: (aBlock value: (self at: i))
		}.
		result
	}.

	method collectWithIndex: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void|
			result at: i put: (aBlock value: (self at: i) value: i)
		}.
		result
	}.

	method select: aPredicate := {
		self species new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifTrue: {
					stream nextPut: element
				}
			}
		}
	}.

	method select: aPredicate thenCollect: collectBlock := {
		self species new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifTrue: {
					stream nextPut: (collectBlock value: element)
				}
			}
		}
	}.

	method select: aPredicate thenDo: aBlock := {
		1 to: self size do: {:i :: Void|
			let element := self at: i.
			(aPredicate value: element) ifTrue: {
				(aBlock value: element)
			}
		}.
		self
	}.

	method reject: aPredicate := {
		self species new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifFalse: {
					stream nextPut: element
				}
			}
		}
	}.

	method reject: aPredicate thenCollect: collectBlock := {
		self species new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifFalse: {
					stream nextPut: (collectBlock value: element)
				}
			}
		}
	}.

	method reject: aPredicate thenDo: aBlock := {
		1 to: self size do: {:i :: Void|
			let element := self at: i.
			(aPredicate value: element) ifFalse: {
				(aBlock value: element)
			}
		}.
		self
	}.

	method copyFrom: start to: stop := {
		let startIndex := start castTo: UIntPointer.
		let stopIndex := stop castTo: UIntPointer.
		let copySize := stopIndex - startIndex + 1.
		let result := self species new: copySize.
		1 to: copySize do: {:i :: Void |
			result at: i put: (self at: i + startIndex - 1u)
		}.
		result
	}.

	method copyWithSize: (newSize: UIntPointer) := {
		let result := self species new: newSize.
		let copySize := newSize min: (self size castTo: UIntPointer).
		1 to: copySize do: {:i :: Void |
			result at: i put: (self at: i)
		}.
		result
	}.

	method first: n := {
		n > self size ifTrue: {self error: 'Invalid copy size'}.
		self copyWithSize: (n castTo: UIntPointer)
	}.

	method allButLast: n := {
		n > self size ifTrue: {self error: 'Invalid copy size'}.
		self copyWithSize: ((self size castTo: UIntPointer) - n castTo: UIntPointer)
	}.

	method allButLast := {
		self emptyCheck.
		self copyWithSize: ((self size castTo: UIntPointer) - 1u)
	}.

	method allButLastDo: aBlock := {
		1 to: (self size castTo: IntPointer) - 1 do: {:i :: Void |
			aBlock value: (self at: i)
		}.
		nil
	}.

	method copyWith: anElement := {
		let size := self size.
		let result := self species new: size + 1.
		1 to: size do: {:i :: Void |
			result at: i put: (self at: i)
		}.
		result at: size + 1 put: anElement.
		result
	}.

	method grownBy: (extraSize: UIntPointer)
		:= self copyWithSize: (self size castTo: UIntPointer) + extraSize.

	method replaceFrom: (startIndex: UIntPointer) until: (endIndex: UIntPointer) with: other
		:= self replaceFrom: startIndex until: endIndex with: other startingAt: 1.

	method replaceFrom: (startIndex: UIntPointer) until: (endIndex: UIntPointer) with: other startingAt: (otherStartIndex: UIntPointer) := {
		startIndex until: endIndex do: {:i :: Void |
			self at: i + 1 put: (other at: i - startIndex + otherStartIndex)
		}.
		self
	}.

	method -- other := {
		let mySize := self size castTo: UIntPointer.
		let otherSize := other size castTo: UIntPointer.
		let result := self copyWithSize: mySize + otherSize.
		result replaceFrom: mySize until: mySize + otherSize with: other.
		result
	}.

	compileTime compileLanguage: #pharoMethodEmbedded source: "
		, other
			^ self -- other
	".

	method anyOne := {
		self emptyCheck.
		self at: 1
	}.

	method first := self at: 1.
	method second := self at: 2.
	method third := self at: 3.
	method fourth := self at: 4.
	method fifth := self at: 5.
	method sixth := self at: 6.
	method seventh := self at: 7.
	method eighth := self at: 8.
	method ninth := self at: 9.

	method last := self at: self size.

	method atAllPut: value := {
		1 to: self size do: {:i :: Void |
			self at: i put: value
		}.
		self
	}.

	method identityIndexOf: anElement
		:= self identityIndexOf: anElement ifAbsent: 0.

	method identityIndexOf: anElement ifAbsent: exceptionBlock := {
		1 to: self size do: {:i :: Void |
			(self at: i) == anElement ifTrue: {return: i}
		}.
		exceptionBlock value
	}.

	method indexOf: anElement
		:= self indexOf: anElement ifAbsent: 0.

	method indexOf: anElement ifAbsent: exceptionBlock
		:= self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock.

	method indexOf: anElement startingAt: start
	 	:= self indexOf: anElement startingAt: start ifAbsent: 0.

	method indexOf: anElement startingAt: start ifAbsent: exceptionBlock := {
		(start castTo: UIntPointer) to: (self size castTo: UIntPointer) do: {:index :: Void |
			(self at: index) = anElement ifTrue: {
				return: index
			}
		}.

		exceptionBlock value
	}.

	method lastIndexOf: anElement
		:= self lastIndexOf: anElement ifAbsent: 0.

	method lastIndexOf: anElement ifAbsent: exceptionBlock
		:= self lastIndexOf: anElement startingAt: 1 ifAbsent: exceptionBlock.

	method lastIndexOf: anElement startingAt: start
	 	:= self lastIndexOf: anElement startingAt: start ifAbsent: 0.

	method lastIndexOf: anElement startingAt: start ifAbsent: exceptionBlock := {
		let size := (self size castTo: UIntPointer).
		(start castTo: UIntPointer) to: size do: {:index :: Void |
			(self at: size - index + 1u) = anElement ifTrue: {
				return: index
			}
		}.

		exceptionBlock value
	}.

	method swap: oneIndex with: anotherIndex := {
		let temp := self at: oneIndex.
		self at: oneIndex put: (self at: anotherIndex).
		self at: anotherIndex put: temp.
		self.
	}.

	method writeStream
		:= WriteStream on: self.

	method readStream
		:= ReadStream on: self.
}.

}. ## End of namespace Smalltalk.
