namespace Smalltalk definition: {
Object extend: {
	method isString := false.
}.

String definition: {
    method isString := true.

	meta definition: {
		method fromNativeString: (string: Char8 const arraySlice) ::=> _DependentInstanceType := {
			let result := self new: string size.
			Stdn memcpy(result __private __data[0] address, string elements, string size).
			result
		}.
	}.

	method beginsWith: prefix := {
		prefix class == String || prefix class == Symbol ifTrue: {
			let prefixString := prefix reinterpretCastTo: String.
			let mySize := __data size.
			let prefixSize := prefixString __private __data size.
			mySize < prefixSize ifTrue: {
				return: false.
			}.

			return: (Stdn memcmp(__data[0] address, prefixString __private __data [0] address, prefixSize) == 0)
		}.
		return: (super beginsWith: prefix)
	}.

	method withoutPrefix: prefix := {
		(self beginsWith: prefix)
			ifTrue: { self copyFrom: 1 + prefix size to: self size }
			ifFalse: { self }
	}.

	method withoutSuffix: suffix := {
		(self beginsWith: suffix)
			ifTrue: { self copyFrom: 1 to: self size - suffix size }
			ifFalse: { self }
	}.

	method endsWith: suffix := {
		suffix class == String || suffix class == Symbol ifTrue: {
			let suffixString := suffix reinterpretCastTo: String.
			let mySize := __data size.
			let suffixSize := suffixString __private __data size.
			mySize < suffixSize ifTrue: {
				return: false.
			}.

			return: (Stdn memcmp(__data[mySize - suffixSize] address, suffixString __private __data [0] address, suffixSize) == 0)
		}.
		return: (super endsWith: suffix)
	}.

    method hash := self stringHash.
    method = other := self stringEquals: other.

    inline method speciesHash => UIntPointer
        := 13312.

    method stringHash := {
        let result mutable := self speciesHash.
        0 until: __data size do: {:i :: Void |
            let c := __data[i].
            result := (result + c) * 1664525
        }.

        return: result & ObjectModel SmallIntegerMaxValue
    }.

    method stringEquals: other := {
        self == other ifTrue: {
            return: true
        }.
        other isString ifFalse: {
            return: false.
        }.

        let otherString := other reinterpretCastTo: String.
        __data size == otherString __private __data size ifFalse: {
            return: false.
        }.

        return: Stdn memcmp(__data[0] address, otherString __private __data[0] address, __data size) == 0.
    }.

	method asStdnMutableString => Stdn String := {
		Stdn String fromUTF8: __data[0] address size: __data size
	}.
}.

ProtoObject extend: {
	method asStdnMutableString => Stdn String := {
		self asString asStdnMutableString.
	}
}.

(Char8 arraySlice | Char8 const arraySlice) extend: {
	method asSmalltalkString => String
		:= String fromNativeString: self
}.

(Char8 pointer | Char8 const pointer) extend: {
	method asSmalltalkString => String
		:= String fromNativeString: (self until: Stdn cstrlen(self))
}.

Stdn String extend: {
	const method asSmalltalkString => String
		:= String fromNativeString: self asArraySlice
}.

compileTime constant ByteString := String.
compileTime constant WideString := String.

}. ## End of namespace Smalltalk
