namespace Smalltalk definition: {
Object extend: {
	method isString := false.
}.

String definition: {
    field __data protected type: Char8 array.

	__global Smalltalk generateBasicAtAccessorsForArrayField: __data elementType: Char8.
	__global Smalltalk generateAtAccessorsForArrayField: __data elementType: Char8.

	meta definition: {
		method fromNativeString: (string: Char8 const arraySlice) ::=> _DependentInstanceType := {
			let result := self new: string size.
			Stdn memcpy(result __private __data[0] address, string elements, string size).
			result
		}.


		method cr := self with: '\r'.
		method crlf := self with: '\r' with: '\n'.
		method crlfcrlf := self with: '\r' with: '\n' with: '\r' with: '\n'.
		method empty := "".
		method lf := self with: '\n'.
		method space := self with: ' '.
		method tab := self with: '\t'.

		method value: aCharacter := self with: (Character value: aCharacter).
	}.

    method isString := true.

	method isLiteral := false.

	method beginsWith: prefix := {
		prefix class == String || prefix class == Symbol ifTrue: {
			let prefixString := prefix reinterpretCastTo: String.
			let mySize := __data size.
			let prefixSize := prefixString __private __data size.
			mySize < prefixSize ifTrue: {
				return: false.
			}.

			return: (Stdn memcmp(__data[0] address, prefixString __private __data [0] address, prefixSize) == 0)
		}.
		return: (super beginsWith: prefix)
	}.

	method withoutPrefix: prefix := {
		(self beginsWith: prefix)
			ifTrue: { self copyFrom: 1 + prefix size to: self size }
			ifFalse: { self }
	}.

	method withoutSuffix: suffix := {
		(self beginsWith: suffix)
			ifTrue: { self copyFrom: 1 to: self size - suffix size }
			ifFalse: { self }
	}.

	method endsWith: suffix := {
		suffix class == String || suffix class == Symbol ifTrue: {
			let suffixString := suffix reinterpretCastTo: String.
			let mySize := __data size.
			let suffixSize := suffixString __private __data size.
			mySize < suffixSize ifTrue: {
				return: false.
			}.

			return: (Stdn memcmp(__data[mySize - suffixSize] address, suffixString __private __data [0] address, suffixSize) == 0)
		}.
		return: (super endsWith: suffix)
	}.

	method findString: substring
		:= self findString: substring startingAt: 1.

	method findString: substring startingAt: start
		:= self findCaseSensitiveString: substring startingAt: start.

	method findCaseSensitiveString: substring startingAt: start := {
		let startIndex := start castTo: IntPointer.
		startIndex < 1 ifTrue: {self errorSubscriptBounds: start}.

		substring class == String || substring class == Symbol ifTrue: {
			let castedSubstring := substring reinterpretCastTo: String.
			let substringSize := castedSubstring __private __data size.
			let substringData := castedSubstring __private __data[0] address.
			(startIndex castTo: UIntPointer) to: __data size do: {:i :: Void |
				let remainingSize := __data size - startIndex.
				remainingSize < substringSize ifTrue: {
					return: 0
				}.

				Stdn memcmp(__data[i - 1] address, substringData, substringSize) == 0 ifTrue: {
					return: i
				}.
			}.
		} ifFalse: {
			let substringSize := substring size castTo: UIntPointer.
			(startIndex castTo: UIntPointer) to: __data size do: {:i :: Void |
				let remainingSize := __data size - (i - 1).
				remainingSize < substringSize ifTrue: {
					return: 0
				}.

				let j mutable type: UIntPointer := 1.
				let keepMatching mutable := false.
				while: j <= substringSize && keepMatching do: {
					keepMatching := (__data at: i + j - 1u) == (substring at: j).
				} continueWith: {j := j + 1u}.

				keepMatching ifTrue: {
					return: i
				}
			}.
		}.

		0
	}.

    method hash := self stringHash.
    method = other := self stringEquals: other.

    inline method speciesHash => UIntPointer
        := 13312.

    method stringHash := {
        let result mutable := self speciesHash.
        0 until: __data size do: {:i :: Void |
            let c := __data[i].
            result := (result + c) * 1664525
        }.

        return: result & ObjectModel SmallIntegerMaxValue
    }.

    method stringEquals: other := {
        self == other ifTrue: {
            return: true
        }.
        other isString ifFalse: {
            return: false.
        }.

        let otherString := other reinterpretCastTo: String.
        __data size == otherString __private __data size ifFalse: {
            return: false.
        }.

        return: Stdn memcmp(__data[0] address, otherString __private __data[0] address, __data size) == 0.
    }.

	method asStdnMutableString => Stdn String := {
		Stdn String fromUTF8: __data[0] address size: __data size
	}.

	method asString
		:= self.

    method printOnNativeTextStreamWriter: (writer: Stdn IO TextStreamWriter ref) := {
		__data size > 0 ifTrue: {
		    writer write: __data [0] address size: __data size
		}.

		self
    }.

	method printOn: aStream
		:= self storeOn: aStream.

	method storeOn: aStream := {
		aStream nextPut: '\''.
		0 until: __data size do: {:i :: Void|
			let c := __data[i].
			aStream nextPut: c.
			c == '\'' ifTrue: {aStream nextPut: c}.
		}.

		aStream nextPut: '\''.
		self
	}.

	method translated
		:= self.

	method numArgs := {
		let size := __data size.
		size = 0 ifTrue: {return: -1}.

		let firstChar := __data[0].
		firstChar = '_' || firstChar isLetter ifTrue: {
			let colonCount mutable := 0u.
			let isPreviousAColon mutable := false.
			0 until: __data size do: {:i :: Void |
				let each := __data[i].
				(each = ':') ifTrue: {
					isPreviousAColon ifTrue: {return: -1}.
					colonCount := colonCount + 1u.
					isPreviousAColon := true.
				} ifFalse: {
					each isAlphaNumeric || each = '_' ifFalse: {return: -1}.
					isPreviousAColon := false.
				}
			}.

			colonCount > 0 ifTrue: {
				__data[size - 1] = ':'
					ifTrue: { return: colonCount }
					ifFalse: { return: -1 }
			}.

			return: 0
		}.

		## Make sure this is a binary selector.
		0 until: __data size do: {:i :: Void |
			let each := __data[i].
			each isSpecial ifFalse: {return: -1}
		}.
		1
	}.
}.

ProtoObject extend: {
	method asStdnMutableString => Stdn String := {
		self asString asStdnMutableString.
	}
}.

(Char8 arraySlice | Char8 const arraySlice) extend: {
	method asSmalltalkString => String
		:= String fromNativeString: self
}.

(Char8 pointer | Char8 const pointer) extend: {
	method asSmalltalkString => String
		:= String fromNativeString: (self until: Stdn cstrlen(self))
}.

Stdn String extend: {
	const method asSmalltalkString => String
		:= String fromNativeString: self asArraySlice
}.

compileTime constant ByteString := String.
compileTime constant WideString := String.

}. ## End of namespace Smalltalk
