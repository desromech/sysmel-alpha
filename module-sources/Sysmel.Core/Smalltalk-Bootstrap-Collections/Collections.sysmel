namespace Smalltalk definition: {
Object extend: {
	method isEmptyOrNil
		:= false.

	method isArray := false.
}.

Collection definition: {
	meta definition: {
		method with: first := {
			self new
				add: first;
				yourself
		}.

		method with: first with: second := {
			self new
				add: first;
				add: second;
				yourself
		}.

		method with: first with: second with: third := {
			self new
				add: first;
				add: second;
				add: third;
				yourself
		}.

		method with: first with: second with: third with: fourth := {
			self new
				add: first;
				add: second;
				add: third;
				add: fourth;
				yourself
		}.

		method with: first with: second with: third with: fourth with: fifth := {
			self new
				add: first;
				add: second;
				add: third;
				add: fourth;
				add: fifth;
				yourself
		}.

		method with: first with: second with: third with: fourth with: fifth with: sixth := {
			self new
				add: first;
				add: second;
				add: third;
				add: fourth;
				add: fifth;
				add: sixth;
				yourself
		}.

		method withAll: other
			:= (self new: other size)
				addAll: other;
				yourself.
	}.

	method isEmpty
		:= self size == 0.

	method isNotEmpty
		:= self isEmpty not.

	method isEmptyOrNil
		:= self size == 0.

	method ifEmpty: aBlock := {
		self isEmpty ifTrue: {
			aBlock value
		} ifFalse: {
			self
		}
	}.

	method ifNotEmpty: aBlock := {
		self isEmpty ifTrue: {
			self
		} ifFalse: {
			aBlock cull: self
		}
	}.

	method ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock := {
		self isEmpty ifTrue: {
			emptyBlock value
		} ifFalse: {
			notEmptyBlock cull: self
		}
	}.

	method ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock := {
		self isEmpty ifTrue: {
			emptyBlock value
		} ifFalse: {
			notEmptyBlock cull: self
		}
	}.

	method addAll: otherCollection := {
		otherCollection do: {:each :: Void |
			self add: each
		}.
		self
	}.

	method asArray := {
		let result := Array new: self size.
		let index mutable := 1.
		self do: {:each :: Void |
			result at: index put: each.
			index := index + 1
		}.
		result
	}.

	method anySatify: aPredicate := {
		self do: {:each :: Void |
			(aPredicate value: each) ifTrue: {
				return: true
			}.
		}.
		false
	}.

	method allSatify: aPredicate := {
		self do: {:each :: Void |
			(aPredicate value: each) ifFalse: {
				return: false
			}.
		}.
		true
	}.

	method includes: anElement
		:= self anySatify: {:each | each = anElement}.

	method copyWithout: anElement
		:= self reject: {:each | each = anElement}.
}.

UndefinedObject extend: {
	method isEmptyOrNil
		:= true.
}.

SequenceableCollection definition: {
	meta definition: {
		method streamSpecies
			:= self.

		method streamContents: unaryBlock
			:= self new: 100 streamContents: unaryBlock.

		method new: initialSize streamContents: unaryBlock := {
			let stream := WriteStream on: (self streamSpecies new: initialSize).
			unaryBlock value: stream.
			stream contents
		}.

		method streamContents: unaryBlock limitedTo: sizeLimit := {
			let stream mutable.
			stream := LimitedWriteStream
				on: (self streamSpecies new: (sizeLimit min: 100))
				limit: sizeLimit
				limitBlock: {:: Void | return: stream contents }.
			unaryBlock value: stream.
			stream contents
		}.
	}.

	method asArray
		:= Array withAll: self.

	method do: aBlock := {
		1 to: self size do: {:i :: Void|
			aBlock value: (self at: i)
		}.
		nil
	}.

	method doWithIndex: aBlock := {
		1 to: self size do: {:i :: Void|
			aBlock value: (self at: i) value: i
		}.
		nil
	}.

	method collect: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void|
			result at: i put: (aBlock value: (self at: i))
		}.
		result
	}.

	method collectWithIndex: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void|
			result at: i put: (aBlock value: (self at: i) value: i)
		}.
		result
	}.

	method select: aPredicate := {
		self class new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifTrue: {
					stream nextPut: element
				}
			}
		}
	}.

	method reject: aPredicate := {
		self class new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifFalse: {
					stream nextPut: element
				}
			}
		}
	}.

	method copyWithSize: (newSize: UIntPointer) := {
		let result := self species new: newSize.
		let copySize := newSize min: self size.
		1 to: copySize + 1 do: {:i :: Void |
			result at: i put: (self at: i)
		}.
		result
	}.

	method copyWith: anElement := {
		let size := self size.
		let result := self species new: size + 1.
		1 to: size do: {:i :: Void |
			result at: i put: (self at: i)
		}.
		result at: size + 1 put: anElement.
		result
	}.

	method grownBy: (extraSize: UIntPointer)
		:= self copyWithSize: self size + extraSize.

	method replaceFrom: (startIndex: UIntPointer) until: (endIndex: UIntPointer) with: other := {
		startIndex until: endIndex do: {:i :: Void |
			self at: i + 1 put: (other at: i - startIndex + 1)
		}.
		self
	}.

	method -- other := {
		let mySize := self size.
		let otherSize := other size.
		let result := self copyWithSize: mySize + otherSize.
		result replaceFrom: mySize until: mySize + otherSize with: other.
		result
	}.

	method first := self at: 1.
	method second := self at: 2.
	method third := self at: 3.
	method fourth := self at: 4.
	method fifth := self at: 5.
	method sixth := self at: 6.
	method seventh := self at: 7.
	method eighth := self at: 8.
	method ninth := self at: 9.
}.

ArrayedCollection definition: {
	meta definition: {
		method with: first := {
			let result := self new: 1.
			result at: 1 put: first.
			result
		}.

		method with: first with: second := {
			let result := self new: 2.
			result at: 1 put: first.
			result at: 2 put: second.
			result
		}.

		method with: first with: second with: third := {
			let result := self new: 3.
			result at: 1 put: first.
			result at: 2 put: second.
			result at: 3 put: third.
			result
		}.

		method with: first with: second with: third with: fourth := {
			let result := self new: 4.
			result at: 1 put: first.
			result at: 2 put: second.
			result at: 3 put: third.
			result at: 4 put: fourth.
			result
		}.

		method with: first with: second with: third with: fourth with: fifth := {
			let result := self new: 5.
			result at: 1 put: first.
			result at: 2 put: second.
			result at: 3 put: third.
			result at: 4 put: fourth.
			result at: 5 put: fifth.
			result
		}.

		method with: first with: second with: third with: fourth with: fifth with: sixth := {
			let result := self new: 6.
			result at: 1 put: first.
			result at: 2 put: second.
			result at: 3 put: third.
			result at: 4 put: fourth.
			result at: 5 put: fifth.
			result at: 6 put: sixth.
			result
		}.

		method withAll: other := {
			let newSize := other size castTo: UIntPointer.
			let result := self new: newSize.
			result replaceFrom: 0 until: newSize with: other.
			result
		}.
	}.

}.

MethodDictionary definition: {
	method values := {
		let result := Array new: tally.
		result.
	}.
}.

Array definition: {
	method isArray := true.
	method asArray := self.
}.

}. ## End of namespace Smalltalk
