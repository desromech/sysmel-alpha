namespace Smalltalk definition: {
Object extend: {
	method isEmptyOrNil
		:= false.

	method isArray := false.
}.

UndefinedObject extend: {
	method isEmptyOrNil
		:= true.
}.

Collection definition: {
	meta definition: {
		method with: first := {
			self new
				add: first;
				yourself
		}.

		method with: first with: second := {
			self new
				add: first;
				add: second;
				yourself
		}.

		method with: first with: second with: third := {
			self new
				add: first;
				add: second;
				add: third;
				yourself
		}.

		method with: first with: second with: third with: fourth := {
			self new
				add: first;
				add: second;
				add: third;
				add: fourth;
				yourself
		}.

		method with: first with: second with: third with: fourth with: fifth := {
			self new
				add: first;
				add: second;
				add: third;
				add: fourth;
				add: fifth;
				yourself
		}.

		method with: first with: second with: third with: fourth with: fifth with: sixth := {
			self new
				add: first;
				add: second;
				add: third;
				add: fourth;
				add: fifth;
				add: sixth;
				yourself
		}.

		method withAll: other
			:= (self new: other size)
				addAll: other;
				yourself.
	}.

	method isEmpty
		:= self size == 0.

	method isNotEmpty
		:= self isEmpty not.

	method notEmpty
		:= self isEmpty not.

	method isEmptyOrNil
		:= self size == 0.

	method ifEmpty: aBlock := {
		self isEmpty ifTrue: {
			aBlock value
		} ifFalse: {
			self
		}
	}.

	method ifNotEmpty: aBlock := {
		self isEmpty ifTrue: {
			self
		} ifFalse: {
			aBlock cull: self
		}
	}.

	method ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock := {
		self isEmpty ifTrue: {
			emptyBlock value
		} ifFalse: {
			notEmptyBlock cull: self
		}
	}.

	method ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock := {
		self isEmpty ifTrue: {
			emptyBlock value
		} ifFalse: {
			notEmptyBlock cull: self
		}
	}.

	method addAll: otherCollection := {
		otherCollection do: {:each :: Void |
			self add: each
		}.
		self
	}.

	method remove: oldObject
		:= self remove oldObject ifAbsent: {| self errorNotFound: oldObject }.

	method remove: oldObject ifAbsent: absentBlock
		:= self subclassResponsibility.

	method removeAll := {
		self do: {:each :: Void |
			self remove: each
		}.
		self
	}.

	method asArray := {
		let result := Array new: self size.
		let index mutable := 1.
		self do: {:each :: Void |
			result at: index put: each.
			index := index + 1
		}.
		result
	}.

	method asDictionary
		:= self as: Dictionary.

	method asOrderedCollection
		:= self as: OrderedCollection.

	method asSet
		:= Set withAll: self.

	method asIdentitySet
		:= (Set new: self size) addAll: self.

	method anySatisfy: aPredicate := {
		self do: {:each :: Void |
			(aPredicate value: each) ifTrue: {
				return: true
			}.
		}.
		false
	}.

	method allSatisfy: aPredicate := {
		self do: {:each :: Void |
			(aPredicate value: each) ifFalse: {
				return: false
			}.
		}.
		true
	}.

	method fillFrom: aCollection with: aBlock := {
		aCollection do: {:each :: Void |
			self add: (aBlock value: each).
		}.

		self
	}.

	method includes: anElement
		:= self anySatisfy: {:each | each = anElement}.

	method collect: aBlock as: aClass
		:= (aClass new: self size) fillFrom: self with: aBlock.

	method collect: aBlock into: aCollection
		:= aCollection fillFrom: self with: aBlock.

	method associationsDo: aBlock
		:= self do: aBlock.

	method copyWithout: anElement
		:= self reject: {:each | each = anElement}.

	method detect: aBlock ifNone: exceptionBlock
		:= self detect: aBlock ifFound: {:element | element } ifNone: exceptionBlock.

	method detect: aBlock ifFound: foundBlock
		:= self detect: aBlock ifFound: foundBlock ifNone: {| nil }.

	method detect: aBlock ifFound: foundBlock ifNone: exceptionBlock := {
		self do: {:each :: Void |
			(aBlock value: each) ifTrue: {
				return: (foundBlock cull: each)
			}
		}.

		exceptionBlock value
	}.

	method detect: aBlock
		:= self detect: aBlock ifNone: {| self errorNotFound: aBlock}.

	method inject: thisValue into: binaryBlock := {
		let nextValue mutable := thisValue.
		self do: {:each :: Void | nextValue := binaryBlock value: nextValue value: each}.
		nextValue
	}.

	method printNameOn: aStream
        := super printOn: aStream.

    method printOn: aStream := {
        self printNameOn: aStream.
        self printElementsOn: aStream.
    }.

    method printElementsOn: aStream := {
        aStream nextPut: '('.
        self do: {:each :: Void | each printOn: aStream} separatedBy: {:: Void | aStream space}.
        aStream nextPut: ')'.
    }.

    method do: aBlock separatedBy: separatorBlock := {
        let hasSeenFirst mutable := false.
        self do: {:each :: Void |
            hasSeenFirst ifTrue: {
                separatorBlock value.
            } ifFalse: {
                hasSeenFirst := true.
            }.

            aBlock value: each
        }.
    }.

	method occurrencesOf: anObject := {
		let result mutable type: UIntPointer.
		self do: {:each :: Void |
			each = anObject ifTrue: {
				result := result + 1u
			}
		}.
		result
	}.

	method flattened
		:= Array streamContents: {:out :: Void | self flattenOn: out }.

	method flattenOn: aStream
		:= self do: {:each :: Void | each flattenOn: aStream }.

	method errorSizeMismatch
		:= SizeMismatch signal.

	method errorEmptyCollection
		:= CollectionIsEmpty signalWith: self.

	method emptyCheck := {
		self isEmpty ifTrue: {self errorEmptyCollection}.
		self.
	}.

	method anyOne := {
		self emptyCheck.
		self do: {:each :: Void | return: each}.
		nil
	}.

	method max
		:= self inject: self anyOne into: {:a :b | a max: b}.

	method min
		:= self inject: self anyOne into: {:a :b | a min: b}.

	method sum := {
		self emptyCheck.
		let sample := self anyOne.
		let sum := self self inject: sample into: {:a :b | a + b}.
		sum - sample
	}.
}.

}. ## End of namespace Smalltalk.
