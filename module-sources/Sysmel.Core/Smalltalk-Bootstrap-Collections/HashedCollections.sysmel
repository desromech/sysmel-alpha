namespace Smalltalk definition: {

HashedCollection definition: {
    meta extend: {
        method new
            := self basicNew initialize: 5; yourself.
        method new: (initialCapacity: UIntPointer)
            := self basicNew initialize: initialCapacity; yourself.
    }.

    method initialize: (initialCapacity: UIntPointer) := {
        array := Array new: initialCapacity
    }.

    method capacity => UIntPointer
        := array __private __data size.

    method size => UIntPointer
        := tally.

    inline method findElementIndex: key ::=> UIntPointer := {
        let index := self scanFor: key.
        index > 0 ifTrue: {
            return: (index castTo: UIntPointer)
        }.

        ## This case should never happen with a normal HashedCollection.
        self errorNoFreeSpace.
        0u
    }.

    method scanFor: key ::=> UIntPointer := {
        self subclassResponsibility.
        return: 0
    }.

    inline method atNewIndex: (newIndex: UIntPointer) put: newSetElement := {
        array at: newIndex put: newSetElement.
        tally := tally + 1.
        self fullCheck.
    }.

    method fullCheck := {
        let currentCapacity := array __private __data size.
        let currentSize := tally.
        let remainingCapacity := currentCapacity - currentSize.
        let growThreshold := remainingCapacity // 4 max: 1.
        remainingCapacity < growThreshold ifTrue: {
            self grow
        }
    }.

    method grow := {
        let oldElements := array.
        let oldCapacity := oldElements __private __data size.
        tally := 0.
        array := Array new: (oldCapacity * 2 max: 5).
        0 until: oldCapacity do: {:i :: Void |
            let element := oldElements[i].
            element ifNotNil: {
                self noCheckAdd: element
            }.
        }.

        self.
    }.

    method noCheckAdd: element := {
        array at: (self scanFor: element) put: element.
        tally := tally + 1
    }.

    method errorNoFreeSpace
        := self error: "There is no free space in this collection!".
}.

Object extend: {
    method enclosedSetElement := self.
    method asSetElement := self.
}.

Set definition: {
    method add: newObject := {
        let index := self scanFor: newObject.
        (array at: index) ifNil: {
            self atNewIndex: index put: newObject asSetElement
        }.

        newObject
    }.

    method scanFor: key ::=> UIntPointer := {
        ## Make sure we at least have a size.
        let keyCount := self capacity.
        keyCount = 0 ifTrue: {
            self errorNoFreeSpace
        }.

        ## Find the natural key slot.
        let keySlot := (key hash castTo: UIntPointer) % keyCount.

        ## Perform linear probing.
        let i mutable := keySlot.
        while: i < keyCount do: {
            let slotKey := array __private __data[i].
            slotKey == nil || slotKey = key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let slotKey := array __private __data[i].
            slotKey == nil || slotKey = key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        self errorNoFreeSpace.
        return: 0
    }.

    method do: aBlock := {
        array do: {:each :: Void |
            each ifNotNil: {
                aBlock value: each
            }
        }.
        nil
    }.

    method like: key := {
        (array at: (self scanFor: key)) enclosedSetElement
    }.
}.

Dictionary definition: {
    method do: aBlock := {
        0 until: array size do: {:(UIntPointer)i :: Void |
            let element := array[i].
            element ifNotNil: {
                aBlock value: element
            }
        }.
        nil
    }.

    method associationsDo: aBlock := {
        self do: aBlock
    }.

    method keysDo: aBlock := {
        self do: {:association :: Void |
            aBlock value: association key
        }.
    }.

    method valuesDo: aBlock := {
        self do: {:association :: Void |
            aBlock value: association value
        }.
    }.

    method keysAndValuesDo: aBlock := {
        self do: {:association :: Void |
            aBlock value: association key value: association value
        }.
    }.

    method scanFor: key ::=> UIntPointer := {
        ## Make sure we at least have a size.
        let keyCount := self capacity.
        keyCount = 0 ifTrue: {
            self errorNoFreeSpace
        }.

        ## Find the natural key slot.
        let keySlot := (key hash castTo: UIntPointer) % keyCount.

        ## Perform linear probing.
        let i mutable := keySlot.
        while: i < keyCount do: {
            let assoc := array __private __data[i].
            assoc == nil || assoc key = key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let assoc := array __private __data[i].
            assoc == nil || assoc key = key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        self errorNoFreeSpace.
        return: 0
    }.

    method keys := {
        let resultSize := self size.
        let result := Array new: resultSize.
        let destIndex mutable type: UIntPointer.

        self keysDo: {:each :: Void |
            result[destIndex] := each.
            destIndex := destIndex + 1.
        }.

        result
    }.

    method values := {
        let resultSize := self size.
        let result := Array new: resultSize.
        let destIndex mutable type: UIntPointer.

        self valuesDo: {:each :: Void |
            result[destIndex] := each.
            destIndex := destIndex + 1.
        }.

        result
    }.

    method associations := {
        let resultSize := self size.
        let result := Array new: resultSize.
        let destIndex mutable type: UIntPointer.

        self associationsDo: {:each :: Void |
            result[destIndex] := each.
            destIndex := destIndex + 1.
        }.

        result
    }.

    method associationAt: key
        := self associationAt: key ifAbsent: {:: Void | self errorKeyNotFound: key}.

    method associationAt: key ifAbsent: aBlock := {
        let element := array at: (self findElementIndex: key).
        return: (element ifNil: {aBlock value} ifNotNil: {element})
    }.

    method associationAt: key ifPresent: aBlock := {
        let element := array at: (self findElementIndex: key).
        return: (element ifNotNil: {aBlock cull: element})
    }.

    method at: key
        := self at: key ifAbsent: {:: Void | self errorKeyNotFound: key}.

    method at: key ifAbsent: aBlock := {
        let element := array at: (self findElementIndex: key).
        return: (element ifNil: {aBlock} ifNotNil: {element}) value
    }.

    method at: key ifAbsentPut: aBlock := {
        self at: key ifAbsent: { :: ProtoObject | self at: key put: aBlock value}
    }.

    method at: key put: anObject := {
        let index := self findElementIndex: key.
        let assoc := array at: index.
        assoc ifNil: {
            self atNewIndex: index put: (Association key: key value: anObject)
        } ifNotNil: {
            assoc value: anObject
        }.
        anObject
    }.

    method noCheckAdd: element := {
        array at: (self scanFor: element key) put: element.
        tally := tally + 1
    }.

    method errorKeyNotFound: aKey
        := KeyNotFound signalFor: aKey.
}.

IdentityDictionary definition: {
    method scanFor: key ::=> UIntPointer := {
        ## Make sure we at least have a size.
        let keyCount := self capacity.
        keyCount = 0 ifTrue: {
            self errorNoFreeSpace
        }.

        ## Find the natural key slot.
        let keySlot := (key identityHash castTo: UIntPointer) % keyCount.

        ## Perform linear probing.
        let i mutable := keySlot.
        while: i < keyCount do: {
            let assoc := array __private __data[i].
            assoc == nil || assoc key == key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let assoc := array __private __data[i].
            assoc == nil || assoc key == key ifTrue: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        self errorNoFreeSpace.
        return: 0
    }.
}.

MethodDictionary definition: {

    method associationsDo: aBlock := {
        self keysAndValuesDo: {:key :value :: Void |
            aBlock value: (Association key: key value: value)
        }
    }.

    method keysDo: aBlock := {
        0 until: array __private __data size do: {:i :: Void |
            let key := array __private __data[i].
            key ifNotNil: {
                aBlock value: key
            }
        }.
        nil
    }.

    method keysAndValuesDo: aBlock := {
        0 until: array __private __data size do: {:i :: Void |
            let key := array __private __data[i].
            key ifNotNil: {
                let value := values __private __data[i].
                aBlock value: key value: value.
            }
        }.

        nil
    }.

    method at: key put: anObject := {
        self at: key putNoSpaceCheck: anObject.
        self fullCheck.
        anObject
    }.

    method grow := {
        let oldKeys := array.
        let oldValues := values.
        let oldCapacity := oldKeys __private __data size.
        let newCapacity := oldCapacity * 2 max: 5.
        tally := 0.

        let newArray := Array new: newCapacity.
        let newValues := Array new: newCapacity.

        ## WARNING: From this point until the end of this method,
        ## dynamic message lookup is FORBIDDEN.
        array := newArray.
        values := newValues.

        0 until: oldCapacity do: {:i :: Void |
            let key := oldKeys[i].
            key ifNotNil: {
                self at: key putNoSpaceCheck: oldValues[i]
            }.
        }.

        self.
    }.
}.

}. ## End of namespace Smalltalk
