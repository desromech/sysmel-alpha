namespace Stdn definition: {

## Native exception base class.
class Exception superclass: Object; definition: {
    SelfType addFlag: #throwable.

    public field messageText type: FixedString const pointer.

    compileTime if: Compiler compilationTarget hasNoOperatingSystem then: {
        method signal => Void := {
            ## TODO: Use a trap instruction here.
        }.
    } else: {
        compileTime if: Compiler hasExceptions not then: {
            method signal => Void := {
                stderr << "Fatal error: " << self; nl.
                native_abort().
            }.
        }.
    }.
}.

## A programming error that is typically not possible to recover from.
class Error superclass: Exception; definition: {}.

## A notification for aborting a task.
class Abort superclass: Error; definition: {}.

## A fatal programming error that is typically impossible to recover from.
class FatalError superclass: Error; definition: {}.

## An assesertion failure.
class AssertionFailure superclass: Error; definition: {}.

## Throwing exceptions during clean up actions is forbidden
class ForbiddenExceptionDuringCleanUp superclass: Error; definition: {}.

## An internal exception that is used for implementing non-local returns.
class InternalNonLocalReturn superclass: Exception; definition: {}.

Compiler compilationTarget internalNonLocalReturnExceptionClass: InternalNonLocalReturn.
## Raises a generic error exception.
function raiseError noReturn(errorMessage: StringLiteral) ::=> Void := {
    ## FIXME: do not separate these because of a missing cast.
    let exception mutable := Error().
    exception
        messageText: errorMessage address;
        signal.
}.

## Raises a fatal error exception.
function raiseFatalError noReturn(errorMessage: StringLiteral) ::=> Void := {
    ## FIXME: do not separate these because of a missing cast.
    let exception mutable := FatalError().
    exception
        messageText: errorMessage address;
        signal.
}.

## Raises an assertion failure exception.
function raiseAssertionFailure noReturn(errorMessage: StringLiteral) ::=> Void := {
    ## FIXME: do not separate these because of a missing cast.
    let exception mutable := AssertionFailure().
    exception
        messageText: errorMessage address;
        signal.
}.

function raiseForbiddenExceptionDuringCleanUp noReturn() => Void := {
    ## FIXME: do not separate these because of a missing cast.
    let exception mutable := ForbiddenExceptionDuringCleanUp().
    exception signal.
}.

## Raises an Abort exception.
function abort noReturn() => Void := {
    let exception mutable := Abort().
    exception signal
}.

macro method error: message
    :=``(Stdn raiseError(`,message)).

macro method fatalError: message
    :=``(Stdn raiseFatalError(`,message)).

#**
 * assert: an assertion that can be disabled in compile time.
 *#
macro method assert: condition := {
    let position := condition asSourcePositionString.
    let expression := condition originalSourceCode.
    let errorMessage := "Assertion " -- expression -- " FAILED in " -- position.
    let messageNode := __astBuilder literalString: errorMessage position: condition position.

    ``(`,condition ifFalse: {
        Stdn raiseAssertionFailure(`,messageNode)
    })
}.

#**
 * assertAlways: An assertion that is always active.
 *#
macro method assertAlways: condition := {
    let position := condition asSourcePositionString.
    let expression := condition originalSourceCode.
    let errorMessage := "Assertion " -- expression -- " FAILED in " -- position.
    let messageNode := __astBuilder literalString: errorMessage position: condition position.

    ``(`,condition ifFalse: {
        Stdn raiseAssertionFailure(`,messageNode)
    })
}.

}.
