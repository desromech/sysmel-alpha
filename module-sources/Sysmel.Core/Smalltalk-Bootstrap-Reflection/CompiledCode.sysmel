namespace Smalltalk definition: {

CompiledCode definition: {
    public field header type: IntPointer.
    public field literals type: Array.
    public field __bytecodes type: UInt8 array.
    global SmallFrame mutable.
    global LargeFrame mutable.

    meta definition: {
        method newMethod: numberOfBytes header: headerWord := {
            (self basicNew: (numberOfBytes castTo: UIntPointer))
                createLiteralsWithHeaderWord: headerWord;
                yourself.
        }.

        method initialize := {
            SmallFrame := 16.
            LargeFrame := 56.
            self
        }.
    }.

    method createLiteralsWithHeaderWord: headerWord := {
        headerWord __isSmallInteger ifFalse: {self error: "Compiled code header word must be a SmallInteger."}.
        header := headerWord __decodeSmallInteger.
        literals := Array basicNew: self numLiterals.
        self
    }.

    inline method numLiterals => UIntPointer := {
        <staticBinding>
        <nogc>
        header & 16r7FFF castTo: UIntPointer
    }.

    inline method numArgs => UIntPointer := {
        <staticBinding>
        <nogc>
        (header >> 24) & 16r0F castTo: UIntPointer
    }.

    inline method numTemps => UIntPointer := {
        <staticBinding>
        <nogc>
        (header >> 18) & 16r3F castTo: UIntPointer
    }.

    inline method initialPC => UIntPointer := {
        <staticBinding>
        <nogc>
        (self numLiterals + 1u) * UIntPointer instanceSize + 1
    }.

    inline method signFlag => Boolean8 := {
        <staticBinding>
        <nogc>
        header < 0
    }.

    method literalAt: (index: UIntPointer)
        := literals at: index.

    method literalAt: (index: UIntPointer) put: value
        := literals at: index put: value.

    method size
        := (1u + self numLiterals) * UIntPointer instanceSize + __bytecodes size.

    method at: (index: UIntPointer) := {
        let initialPC := self initialPC.

        index < initialPC ifTrue: {
            let wordIndex := index // UIntPointer instanceSize.
            wordIndex = 0 ifTrue: {self errorSubscriptBounds: index}.
            wordIndex = 1 ifTrue: {return: header }.

            let literalIndex := wordIndex - 1.
            literalIndex <= self numLiterals ifTrue: {return: (literals basicAt: literalIndex) }.
            self errorSubscriptBounds: index
        }.

        let bytecodeIndex := index - initialPC.
        bytecodeIndex < __bytecodes size ifFalse: {self errorSubscriptBounds: index }.
        __bytecodes[bytecodeIndex]
    }.

    method at: (index: UIntPointer) put: value := {
        let initialPC := self initialPC.

        index < initialPC ifTrue: {
            let wordIndex := index // UIntPointer instanceSize.
            wordIndex = 0 ifTrue: {self errorSubscriptBounds: index}.
            wordIndex = 1 ifTrue: {return: header }.

            let literalIndex := wordIndex - 1.
            literalIndex <= self numLiterals ifTrue: {return: (literals basicAt: literalIndex put: value) }.
            self errorSubscriptBounds: index
        }.

        let bytecodeIndex := index - initialPC.
        bytecodeIndex < __bytecodes size ifFalse: {self errorSubscriptBounds: index }.
        __bytecodes[bytecodeIndex] := value castTo: UInt8
    }.

    method primitive
        := 0.

    method setFrameBit: boolean := {
        let largeFrameBit := 16r20000 castTo: IntPointer.
        boolean ifTrue: {
            header := header | largeFrameBit
        } ifFalse: {
            header := header & (~largeFrameBit)
        }.
        self
    }.

    method needsFrameSize: newFrameSize := {
        (self numTemps + newFrameSize) > LargeFrame ifTrue: {
            return: (self error: "Cannot compile -- stack including temps is too deep")
        }.

        self setFrameBit: ((self numTemps + newFrameSize) > SmallFrame || self primitive = 84 #* perform:withArguments: *#)
    }.

    method actualBytecodeSize => UIntPointer := {
        ## This may be optionally defined on a separate package.
        ## FIXME: Remove this ugly hack.
        (self respondsTo: #trailerSize)
            ifTrue: {__bytecodes size - (self trailerSize castTo: UIntPointer)}
            ifFalse: {__bytecodes size}
    }.

    method dumpString := {
        String streamContents: {:out :: Void |
            out
                print: self class;
                nextPutAll: " numArgs: "; print: self numArgs;
                nextPutAll: " numLiterals: "; print: self numLiterals;
                nextPutAll: " numTemps: "; print: self numTemps; nl.
            literals do: {:each :: Void | out print: each } separatedBy: {:: Void | out space }.
            out nl.
            0 until: self actualBytecodeSize do: {:i :: Void |
                out space.
                __bytecodes[i] asProtoObject printOn: out base: 16 length: 2 padded: true.
                (i % 16) = 15 ifTrue: {out nl}.
            }.
        }
    }.

}.

}. ## End of namespace Smalltalk
