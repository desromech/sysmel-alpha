namespace Smalltalk definition: {
namespace Runtime definition: {

static global globalReflectionLockStateChangedCondition mutable type: Stdn ConditionVariable;
    constructionPriority: Compiler compilationTarget gcInitializationPriority.
static global globalReflectionLockStateMutex mutable type: Stdn Mutex;
    constructionPriority: Compiler compilationTarget gcInitializationPriority.
static global globalReflectionReadLockCount mutable type: UIntPointer.
static global globalReflectionWriteLockWaitingCount mutable type: UIntPointer. ## We give priority to the writers to prevent starvation.
static global globalReflectionWriteLockTaken mutable type: Boolean8.

static global globalReflectionThisThreadReadEnterCount mutable threadLocal type: UIntPointer.
static global globalReflectionThisThreadWriteEnterCount mutable threadLocal type: UIntPointer.

function doTakeReadLock() => Void := {
    ## Wait until there are no more writers.
    while: globalReflectionWriteLockTaken && globalReflectionWriteLockWaitingCount > 0 do: {
        globalReflectionLockStateChangedCondition wait: globalReflectionLockStateMutex
    }.

    globalReflectionReadLockCount := globalReflectionReadLockCount + 1
}.

function enterReflectionLockedRead() => Void := {
    <nogc>
    ## Avoid entering the critical section by counting using thread local storage.
    globalReflectionThisThreadReadEnterCount == 0 && globalReflectionThisThreadWriteEnterCount == 0 ifTrue: {
        globalReflectionLockStateMutex withLock: {
            doTakeReadLock().
        }.
    }.
    globalReflectionThisThreadReadEnterCount := globalReflectionThisThreadReadEnterCount + 1
}.

function leaveReflectionLockedRead() => Void := {
    <nogc>
    Stdn assert: globalReflectionThisThreadReadEnterCount > 0.
    globalReflectionThisThreadReadEnterCount := globalReflectionThisThreadReadEnterCount - 1.

    globalReflectionThisThreadReadEnterCount == 0 && globalReflectionThisThreadWriteEnterCount == 0 ifTrue: {
        globalReflectionLockStateMutex withLock: {
            Stdn assert: globalReflectionReadLockCount > 0.
            Stdn assert: globalReflectionWriteLockTaken not.

            globalReflectionReadLockCount := globalReflectionReadLockCount - 1.

            ## If there are no more readers and writers, allow another writer to enter the lock.
            globalReflectionReadLockCount == 0 ifTrue: {
                globalReflectionLockStateChangedCondition notifyAll
            }.
        }.
    }.
}.

macro method withReflectionLockedRead: aBlock := ``{
    __global Smalltalk Runtime enterReflectionLockedRead().
    try: `,aBlock finally: {
        __global Smalltalk Runtime leaveReflectionLockedRead()
    }
}.

function enterReflectionLockedWrite() => Void := {
    <nogc>
    globalReflectionThisThreadWriteEnterCount == 0 ifTrue: {
        globalReflectionLockStateMutex withLock: {
            ## If we need to upgrade a reader into a writer, we have to
            ## release the read lock to prevent a deadlock where multiple
            ## readers would like to upgrade its lock.
            globalReflectionThisThreadReadEnterCount > 0 ifTrue: {
                Stdn assert: globalReflectionReadLockCount > 0.
                globalReflectionReadLockCount := globalReflectionReadLockCount - 1.
                globalReflectionReadLockCount == 0 ifTrue: {
                    globalReflectionLockStateChangedCondition notifyAll
                }.
            }.

            ## We want to have priority over the readers to take the mutex.
            globalReflectionWriteLockWaitingCount := globalReflectionWriteLockWaitingCount + 1.

            ## This is an exclusive lock, so we are only taken in
            while: globalReflectionReadLockCount > 0 || globalReflectionWriteLockTaken do: {
                globalReflectionLockStateChangedCondition wait: globalReflectionLockStateMutex
            }.

            ## Take the lock.
            globalReflectionWriteLockTaken := true.

            ## We are not waiting anymore for the lock.
            globalReflectionWriteLockWaitingCount := globalReflectionWriteLockWaitingCount - 1.

        }.
    }.
    globalReflectionThisThreadWriteEnterCount := globalReflectionThisThreadWriteEnterCount + 1.
}.

function leaveReflectionLockedWrite() => Void := {
    <nogc>
    Stdn assert: globalReflectionThisThreadWriteEnterCount > 0.
    globalReflectionThisThreadWriteEnterCount := globalReflectionThisThreadWriteEnterCount - 1.

    globalReflectionThisThreadWriteEnterCount == 0 ifTrue: {
        globalReflectionLockStateMutex withLock: {
            Stdn assert: globalReflectionWriteLockTaken.
            globalReflectionWriteLockTaken := false.
            globalReflectionLockStateChangedCondition notifyAll.

            ## If we are downgrading into a read lock, then we should also wait for other writers to finish.
            globalReflectionThisThreadReadEnterCount > 0 ifTrue: {
                doTakeReadLock().
            }.
        }.
    }.
}.

macro method withReflectionLockedWrite: aBlock := ``{
    __global Smalltalk Runtime enterReflectionLockedWrite().
    try: `,aBlock finally: {
        __global Smalltalk Runtime leaveReflectionLockedWrite()
    }
}.

}. ## End of namespace Runtime
}. ## End of namespace Smalltalk
