namespace Smalltalk definition: {

Object extend: {
	method isBehavior
		:= false.
	method isClass
		:= false.
}.

TypeInformation definition: {
	method addSubclass: aSubclass := self.
}.

Behavior definition: {
	method isBehavior
		:= true.

	method initializeSlots: instance
		:= nil.

	method subclasses := #().

	method ensureIsAddedToSuperClass := self.

	method subclassesDo: aBlock
		:= __global Smalltalk Runtime withReflectionLockedRead: {self subclasses do: aBlock}.

	method allSubclassesDo: aBlock := {
		__global Smalltalk Runtime withReflectionLockedRead: {
			self subclassesDo: {:cls :: Void |
				aBlock value: cls.
				cls allSubclassesDo: aBlock
			}.
		}.
		self
	}.

	method withAllSubclassesDo: aBlock := {
		__global Smalltalk Runtime withReflectionLockedRead: {
			aBlock value: self.
			self allSubclassesDo: aBlock
		}
	}.

	method allSubclasses := {
		let result := OrderedCollection new.
		self allSubclassesDo: {:each :: Void |
			result add: each
		}.
		result
	}.

	method withAllSubclasses := {
		let result := OrderedCollection new.
		self withAllSubclassesDo: {:each :: Void |
			result add: each
		}.
		result
	}.

	method allSelectors := {
		let result := Set new.
		result addAll: self selectors.
		superclass ifNotNil: {
			result addAll: superclass allSelectors
		}.
		result
	}.

	method selectors := {
		let result := OrderedCollection new.
		methodDict keysDo: {:each :: Void |
			(each includes: '|') ifFalse: {
				result add: each
			}
		}.
		result
	}.

	method __manipulateInstance: instance gcSlotsWith: (manipulationBlock: ((ProtoObject pointer) => Void) nativeStackBlockClosure) ::=> Void := {
		<staticBinding>
		<nogc>
		instance __isImmediateValue ifTrue: {return: nil}.

		let fixedSlotCount := instanceDataSize / UIntPointer instanceSize.
		let fixedSlots := instance reinterpretCastTo: ProtoObject pointer.

		0 until: fixedSlotCount do: {:i :: Void |
			(gcLayout isSlotIndexGCPointer: i) ifTrue: {
				manipulationBlock(fixedSlots[i] address)
			}.
		}.

		gcLayout variableDataIsGCPointers ifTrue: {
			let variableDataSize := (instance reinterpretCastTo: Stdn Reflection GCObjectHeader pointer) _ __variableDataSize * variableInstanceElementSize.
			let variableSlotCount := variableDataSize / UIntPointer instanceSize.
			let variableSlots := fixedSlots[fixedSlotCount] address.
			0 until: variableSlotCount do: {:i :: Void |
				manipulationBlock(variableSlots[i] address)
			}
		}.
	}.
}.

Class definition: {
	method ensureIsAddedToSuperClass := {
		superclass ifNotNil: {
			superclass addSubclass: self
		}.

		self
	}.

	method addSubclass: aSubclass ::=> Void := {
		__global Smalltalk Runtime withReflectionLockedRead: {
			(subclasses includes: aSubclass) ifFalse: {
				subclasses := subclasses copyWith: aSubclass.
			}.
		}.
	}.

	method isClass
		:= true.

	method classSide
		:= self class.

	method instanceSide
		:= self.
}.

Metaclass definition: {
	method classSide
		:= self.

	method instanceSide
		:= thisClass.

	method isMetaclassOfClassOrNil := {
		thisClass ifNil: { true }
			ifNotNil: {thisClass == Class }
	}.

	method subclasses := {
		let result := OrderedCollection new.
		self subclassesDo: {:each :: Void |
			result add: each
		}.

		result asArray
	}.

	method subclassesDo: aBlock := {
		## Method taken from Pharo
		## Evaluate aBlock for each of the receiver's immediate subclasses.

		self isMetaclassOfClassOrNil ifFalse: {
			self instanceSide subclassesDo: { :each :: Void | aBlock value: each classSide }
		}.

		self
	}.
}.

}. ## End of namespace Smalltalk
