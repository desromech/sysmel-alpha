## The most essential declarations.
namespace Smalltalk definition: {

gcclass ProtoObject.
gcclass Metaclass.

ProtoObject metaClassClass: Metaclass.
Metaclass metaClassClass: Metaclass.

Compiler compilationTarget
	dynamicObjectType: ProtoObject
}.

namespace SysmelKernel definition: {
	compileTime constant Dynobject := Smalltalk ProtoObject.
}.

namespace Smalltalk definition: {

gcclass Object superclass: ProtoObject. Compiler compilationTarget defaultGCClassSuperClass: Object.
	## Reflection types.
	gcclass ProgramEntity superclass: Object.
		gcclass ModuleDefinedProgramEntity superclass: ProgramEntity.
			gcclass TypeInformation superclass: ModuleDefinedProgramEntity.
			    gcclass Behavior superclass: TypeInformation.
			        gcclass ClassDescription superclass: Behavior.
			            gcclass Class superclass: ClassDescription.
			            gcclass Metaclass superclass: ClassDescription.

## ProtoObject
ProtoObject type supertype: Class.

				gcclass NativeTypeInformation superclass: TypeInformation.
			gcclass ModuleNamespaceInformation superclass: ModuleDefinedProgramEntity.
			gcclass SharedProgramEntity superclass: ProgramEntity.
				gcclass NamespaceInformation superclass: SharedProgramEntity.
		gcclass ModuleInformation superclass: ProgramEntity.
	gcclass ProgramEntityExtensionElement superclass: Object.
		gcclass ExtensionMacroMessage superclass: ProgramEntityExtensionElement.
		gcclass ExtensionOverloadedMethod superclass: ProgramEntityExtensionElement.
		gcclass ExtensionMethod superclass: ProgramEntityExtensionElement.

	gcclass SharedPool superclass: Object.

    ## Boolean8
    gcclass Boolean superclass: Object.
        gcclass True superclass: Boolean.
        gcclass False superclass: Boolean.

    ## Undefined object
    gcclass UndefinedObject superclass: Object.

    ## Numbers
    gcclass Magnitude superclass: Object.
        gcclass Number superclass: Magnitude.
            gcclass Float superclass: Number.
                gcclass BoxedFloat64 superclass: Float.
                gcclass SmallFloat64 superclass: Float.
			gcclass Fraction superclass: Number.
				gcclass ScaledDecimal superclass: Fraction.
            gcclass Integer superclass: Number.
                gcclass LargeInteger superclass: Integer.
                    gcclass LargeNegativeInteger superclass: LargeInteger.
                    gcclass LargePositiveInteger superclass: LargeInteger.
                gcclass SmallInteger superclass: Integer.
		gcclass Character superclass: Magnitude.

		gcclass LookupKey superclass: Magnitude.
			gcclass Association superclass: LookupKey.

		gcclass Variable superclass: Object.
			gcclass LiteralVariable superclass: Variable.
				gcclass AdditionalBinding superclass: LiteralVariable.
				gcclass ClassVariable superclass: LiteralVariable.
				gcclass GlobalVariable superclass: LiteralVariable.
				gcclass UndeclaredVariable superclass: LiteralVariable.
				gcclass WorkspaceVariable superclass: LiteralVariable.
			gcclass Slot superclass: Variable.
				gcclass IndexedSlot superclass: Slot.
					gcclass InstanceVariableSlot superclass: IndexedSlot.
				gcclass UndefinedSlot superclass: Slot.

    gcclass GCLayout superclass: Object.

## The core collections
gcclass Collection superclass: Object.
    gcclass HashedCollection superclass: Collection.
        gcclass Dictionary superclass: HashedCollection.
            gcclass MethodDictionary superclass: Dictionary.
			gcclass IdentityDictionary superclass: Dictionary.
				gcclass SystemDictionary superclass: IdentityDictionary.
		gcclass Set superclass: HashedCollection.
			gcclass IdentitySet superclass: Set.
    gcclass SequenceableCollection superclass: Collection.
		gcclass ArrayedCollection superclass: SequenceableCollection.
			gcclass Array superclass: ArrayedCollection.
				gcclass WeakArray weakSubclass superclass: Array.
			gcclass ByteArray superclass: ArrayedCollection.
			gcclass FloatArray superclass: ArrayedCollection.
			gcclass IntegerArray superclass: ArrayedCollection.
			gcclass WordArray superclass: ArrayedCollection.

			gcclass String superclass: ArrayedCollection.
				gcclass Symbol superclass: String.
		gcclass Interval superclass: SequenceableCollection.
		gcclass LinkedList superclass: SequenceableCollection.
		gcclass OrderedCollection superclass: SequenceableCollection.
	gcclass WeakRegistry superclass: Collection.
	gcclass WeakFinalizationList superclass: Collection.


## Block closures
gcclass BlockClosure superclass: Object.
gcclass FullBlockClosure superclass: BlockClosure.
gcclass CleanBlockClosure superclass: FullBlockClosure.

gcclass NativeBlockClosureHeaderClass superclass: BlockClosure.
gcclass NativeBlockClosure superclass: NativeBlockClosureHeaderClass.
gcclass NativeSimpleBlockClosure superclass: NativeBlockClosure.

## Methods
gcclass CompiledCode superclass: Object.
	gcclass CompiledMethod superclass: CompiledCode.
	gcclass CompiledBlock superclass: CompiledCode.
gcclass NativeCompiledMethod superclass: Object.

gcclass Pragma superclass: Object.
gcclass AdditionalMethodState superclass: Object.

## Message
gcclass Message superclass: Object.

ProtoObject definition: {
    ## We use a fixed 16-byte object header, to be able to use SSE instructions.
    (SelfType addMainVTableFieldNamed: #__vtable) private.

    if: UIntPointer instanceSize == 4 then: {
        ## TODO: Support big-endian.
        field __padding private type: UInt32.
    }.

    ## 32 bits: gc color, isPinned, isImmutable.
    field _ private bits: 5; type: UInt32.

    field __gcBits private type: UInt32; bits: 3.
    field __isPinned private type: UInt32; bits: 1.
    field __isImmutable private type: UInt32; bits: 1.
    field __identityHash private type: UInt32; bits: 22.

    ## Variable data size
    field __variableDataSize private type: UInt32.

	method initialize
		:= self. ## By default do nothing.

	method finalize
		:= self. ## By default do nothing.

	method basicSize => UIntPointer := {
		self __isImmediateValue ifTrue: {self primitiveFailed}.
		__variableDataSize.
	}.

	method size := {
		self __isImmediateValue ifTrue: {self primitiveFailed}.
		__variableDataSize.
	}.
}.

ProgramEntity definition: {
	## These first fields must match the fields in Stdn Reflection ProgramEntity so that
	## exception handling can work.
	public field parent type: ProgramEntity.
}.

SharedProgramEntity definition: {

}.

ModuleDefinedProgramEntity definition: {
	## These first fields must match the fields in Stdn Reflection ModuleDefinedProgramEntity so that
	## exception handling can work.
	public field module type: ModuleInformation.
	protected field children.
}.

TypeInformation definition: {
	## These first fields must match the fields in Stdn Reflection TypeInformation so that
	## exception handling can work.
	public field superclass type: TypeInformation.
	public field instanceDataSize type: UIntPointer.
	public field instanceDataAlignment type: UIntPointer.

	public field basicInitializationFunctionPointer type: Stdn Reflection BasicInitializeFunctionPointerType.
	public field copyConstructorFunctionPointer type: Stdn Reflection CopyConstructorFunctionPointerType.
	public field moveConstructorFunctionPointer type: Stdn Reflection MoveConstructorFunctionPointerType.
    public field finalizeFunctionPointer type: Stdn Reflection FinalizeFunctionPointerType.

	public field methodDict public type: MethodDictionary.

	method lookupSelector: (selector: ProtoObject) ::=> ProtoObject := {
        <staticBinding>
        <nogc>
        ##LibC printf("Behavior %p >> lookupSelector: %p\n", self, selector).

        if: methodDict ~~ nil then: {
            let methodObject := methodDict atOrNil: selector.
            if: methodObject  ~~ nil then: {
                return: methodObject
            }.
        }.

        if: superclass == nil then: {
            return: nil.
        }.

        return: (superclass lookupSelector: selector)
    }.

	method canUnderstand: aSymbol
		:= (self lookupSelector: aSymbol) isNotNil.

	method isGarbageCollectedType => Boolean8
		:= false.
}.

ModuleInformation definition: {
	public field name type: Symbol.
	public field globalNamespace type: ModuleNamespaceInformation.
	public field importedModules type: Array.
	##public field importedIndirectModules type: Array.
	public field extensionMacros type: Array.
	public field extensionOverloadedMethods type: Array.
	public field extensionMethods type: Array.
	public field addedClasses type: Array.
	public field addedGCClasses type: Array.

	field started type: Boolean8.
}.

ModuleNamespaceInformation definition: {
	public field sharedNamespace type: NamespaceInformation.
	public field name type: Symbol.
	public field localSymbolTable type: SystemDictionary.
}.

NamespaceInformation definition: {
	public field name type: Symbol.
	public field moduleNamespaces.
	protected field children.
	protected field childrenTable.
}.

ProgramEntityExtensionElement definition: {
	public field extendedParent.
	public field name.
	public field extension.

	method apply :=
		self subclassResponsibility.
}.

ExtensionMacroMessage definition: {

}.

ExtensionOverloadedMethod definition: {

}.

ExtensionMethod definition: {

}.

Compiler compilationTarget
	typeInformationGCClass: TypeInformation;
	moduleInformationGCClass: ModuleInformation;
	moduleNamespaceInformationGCClass: ModuleNamespaceInformation;

	## For registering/unregistering the extension methods on module load/unload time.
	extensionMacroMessageGCClass: ExtensionMacroMessage;
	extensionOverloadedMethodGCClass: ExtensionOverloadedMethod;
	extensionMethodGCClass: ExtensionMethod.

Behavior definition: {
    public field gcLayout public type: GCLayout.
    public field slots public type: Array.

    public field variableInstanceElementSize public type: UInt32.
    public field variableInstanceElementAlignment public type: UInt32.

    ## The type of the instance is actually a dependent type because of the meta-circular hierarchy.
    method basicNew => _DependentInstanceType := {
		<intrinsic: #"gc.object.basicNew">
        return: (self basicNew: 0)
    }.

    method basicNew: (initialSize: UIntPointer) ::=> _DependentInstanceType := {
		<intrinsic: #"gc.object.basicNew.variable">
        ## Compute the object size.
        let objectSize := instanceDataSize + initialSize*variableInstanceElementSize.

        ## Allocate the object memory.
        let allocatedObject := Stdn GC NativeCollector uniqueInstance
            allocate: objectSize
            variableDataSize: (variableInstanceElementSize > 0 ifTrue: initialSize ifFalse: 0u)
            initializingWith: basicInitializationFunctionPointer.

        ## Convert the allocated object.
        return: (allocatedObject reinterpretCastTo: ProtoObject)
    }.

	method makeCopyOfInstance: (instance: ProtoObject) ::=> ProtoObject := {
		## Compute the object size.
		let variableDataSize := instance __private __variableDataSize.
		let objectSize := instanceDataSize + variableDataSize*variableInstanceElementSize.

		## Allocate the object memory.
        let allocatedObject := Stdn GC NativeCollector uniqueInstance
            allocate: objectSize
            variableDataSize: variableDataSize
            initializingWith: basicInitializationFunctionPointer
			copyingFrom: (instance reinterpretCastTo: Void pointer) copyConstructor: copyConstructorFunctionPointer.

        ## Convert the allocated object.
        return: (allocatedObject reinterpretCastTo: ProtoObject)
	}.

	method new => _DependentInstanceType
		:= self basicNew initialize; yourself.

    method new: initialSize ::=> _DependentInstanceType
		:= (self basicNew: (initialSize castTo: UIntPointer)) initialize; yourself.

	method run: selector with: arguments in: receiver := {
		let message := Message new
			selector: selector;
			args: arguments;
			lookupClass: self;
			yourself.
		return: (receiver doesNotUnderstand: message)
	}.

	method isGarbageCollectedType => Boolean8
		:= true.
}.

Class definition: {
    field subclasses protected type: ProtoObject.
    field name protected type: Symbol.

    method name => Symbol := {
        return: name
    }.

	method subclasses
		:= subclasses.
}.

Metaclass definition: {
    field thisClass protected type: Behavior.

    method isMetaType => Boolean8 := {
        return: true
    }.
}.

## GCLayout
GCLayout definition: {
	compileTime constant BitsPerWord := UIntPointer instanceSize *8 castTo: UIntPointer.

	field variableDataIsGCPointers public type: Boolean8.
    field bitmap public type: UIntPointer array.

	method isSlotIndexGCPointer: (slotIndex: UIntPointer) ::=> Boolean8 := {
		<staticBinding>
		<nogc>
		(slotIndex >= bitmap size * BitsPerWord) ifTrue: {
			return: false.
		}.

		let wordIndex := slotIndex / BitsPerWord.
		let bitIndex := slotIndex % BitsPerWord.
		let bit := (1 castTo: UIntPointer) << bitIndex.

		bitmap[wordIndex] anyMask: bit
	}.
}.

## Table with the immediate clases.
if: UIntPointer instanceSize == 4 then: {
	global immediateClassTable type: (Behavior array: 4) := (
		UndefinedObject, ## 2r00
		SmallInteger,	 ## 2r01
		Character,	 	 ## 2r10
		SmallInteger,	 ## 2r11
	).
} else: {
	global immediateClassTable type: (Behavior array: 8) := (
		UndefinedObject, ## 2r000
		SmallInteger,	 ## 2r001
		Character,	 	 ## 2r010
		UndefinedObject, ## 2r011 (Reserved)

		SmallFloat64, 	 ## 2r100
		UndefinedObject, ## 2r101 (Reserved)
		UndefinedObject, ## 2r110 (Reserved)
		UndefinedObject, ## 2r111 (Reserved)
	).
}.

##-----------------------------------------------------------------------------
ProtoObject definition: {

    if: UIntPointer instanceSize = 4 then: {
        method __isImmediateValue => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self == nil || (((self reinterpretCastTo: UIntPointer) & 3) ~= 0)
        }.

        method __immediateTypeTag => UInt8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            (self reinterpretCastTo: UIntPointer) & 3 castTo: UInt8
        }.

        method __isSmallInteger => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            ((self reinterpretCastTo: UIntPointer) & 1) = 1
        }.

		method __decodeSmallInteger => IntPointer := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
			(self reinterpretCastTo: IntPointer) >> 1
		}.

        method __isCharacter => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self __immediateTypeTag = 2
        }.

		method __decodeCharacter => UInt32 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
			(self reinterpretCastTo: UIntPointer) >> 2 castTo: UInt32
		}.

        method __isSmallFloat => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            false
        }.

        method __decodeSmallFloat => Float64 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            0.0
        }.

    } else: {
        method __isImmediateValue => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self == nil || (((self reinterpretCastTo: UIntPointer) & 7) ~= 0)
        }.

        method __immediateTypeTag => UInt8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            (self reinterpretCastTo: UIntPointer) & 7 castTo: UInt8
        }.

        method __isSmallInteger => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self __immediateTypeTag = 1
        }.

		method __decodeSmallInteger => IntPointer := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
			(self reinterpretCastTo: IntPointer) >> 3
		}.

        method __isCharacter => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self __immediateTypeTag = 2
        }.

		method __decodeCharacter => Char32 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
			(self reinterpretCastTo: UIntPointer) >> 3 castTo: Char32
		}.

        method __isSmallFloat => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self __immediateTypeTag = 4
        }.

		method __decodeSmallFloat => Float64 := {
			<notInCompileTime>
			<staticBinding>
			<nogc>
			let smallFloat := self reinterpretCastTo: UInt64.

			## Shift out the tag
			let bits mutable := smallFloat >> 3.

			## Add back the exponent offset.
			bits := bits + (896 << 53 castTo: UInt64).

			## Rotate the sign back to its place.
			## FIXME: Use a primitive instruction here.
			bits := (bits >> 1) | ((bits & 1) << 63).

			## Cast back to a float64.
			bits reinterpretCastTo: Float64
		}.
    }.

	method __isSmallOrBoxedFloat => Boolean8 := {
		<notInCompileTime>
		<staticBinding>
		<nogc>
		self __isSmallFloat || self class == BoxedFloat64
	}.

	method __decodeSmallOrBoxedFloat => Float64 := {
		<notInCompileTime>
		<staticBinding>
		<nogc>
		self __isSmallFloat ifTrue: {
			self __decodeSmallFloat
		} ifFalse: {
			(self reinterpretCastTo: BoxedFloat64) __float64Value
		}
	}.

    method class => Behavior := {
        <staticBinding>
        <nogc>
        <intrinsic: #"dynobject.class">
        self __isImmediateValue ifTrue: {
            return: immediateClassTable[self __immediateTypeTag].
        }.

        __vtable[-1] reinterpretCastTo: Behavior
    }.

    method identityHash => UIntPointer := {
        <staticBinding>
        <nogc>
        <intrinsic: #"dynobject.identityHash">
        self __isImmediateValue ifTrue: {
            (self reinterpretCastTo: UIntPointer) castTo: UIntPointer.
        } ifFalse: {
            __identityHash
        }
    }.

    method == (other: ProtoObject) => Boolean8 := {
        <staticBinding>
        <nogc>
		<intrinsic: #"dynobject.identityEquals">
		## Identity equality method is also defined as a macro, so lets just exploit its previous definition.
		self == other
    }.

    method ~~ (other: ProtoObject) => Boolean8 := {
        <staticBinding>
        <nogc>
		<intrinsic: #"dynobject.identityNotEquals">
		## Identity equality method is also defined as a macro, so lets just exploit its previous definition.
		self ~~ other
    }.
}.

##-----------------------------------------------------------------------------
## NativeCompiledMethod method

NativeCompiledMethod definition: {
    public field entryPoint type: Void pointer.
    field __literals protected type: ProtoObject array.
}.

##-----------------------------------------------------------------------------
## Important collections
Object definition: {
	method species
		:= self class.

	method = other
		:= self == other.

	method ~= other
		:= (self = other) == false.

	method hash
		:= self identityHash.

	method -> value
		:= Association basicNew key: self; value: value; yourself.

	method flag: flag := self.

	method as: aSimilarClass := {
		aSimilarClass == self class
			ifTrue: { self }
			ifFalse: { aSimilarClass newFrom: self }
	}
}.

LookupKey definition: {
	public field key type: ProtoObject.
}.

Association definition: {
	public field value type: ProtoObject.

	meta method key: key value: value
		:= self new key: key; value: value; yourself.
}.


Variable definition: {
	public field name type: ProtoObject.
}.

LiteralVariable definition: {
	public field value type: ProtoObject.
}.

macro method generateBasicAtAccessorsForArrayField: arrayField elementType: elementType := ``{
	method basicAt: (index: UIntPointer) ::=> `,elementType := {
		index < 1 || index > `,arrayField size ifTrue: {(self errorSubscriptBounds: index)}.
		return: (`,arrayField at: index)
	}.

	method basicAt: (index: UIntPointer) put: (value: `,elementType) ::=> `,elementType := {
		index < 1 || index > `,arrayField size ifTrue: {(self errorSubscriptBounds: index)}.
		(`,arrayField at: index) := value.
		return: value
	}.

	method basicSubscriptAt: (index: UIntPointer) ::=> `,elementType ref := {
		index >= `,arrayField size ifTrue: { (self errorSubscriptBounds: index + 1) }.

		return: `,arrayField[index]
	}.
}.

macro method generateAtAccessorsForArrayField: arrayField elementType: elementType := ``{
	method at: (index: UIntPointer) ::=> ProtoObject := {
		index < 1 || index > `,arrayField size ifTrue: {(self errorSubscriptBounds: index)}.
		return: (`,arrayField at: index)
	}.

	method at: (index: UIntPointer) put: (value: `,elementType) ::=> `,elementType := {
		index < 1 || index > `,arrayField size ifTrue: {(self errorSubscriptBounds: index)}.
		(`,arrayField at: index) := value.
		return: value
	}.

	method subscriptAt: (index: UIntPointer) ::=> `,elementType ref := {
		index >= `,arrayField size ifTrue: { (self errorSubscriptBounds: index + 1)}.
		return: `,arrayField[index]
	}.
}.

MethodDictionary definition: {
    field values protected type: Array.

    method initializeForCapacity: (initialCapacity: UIntPointer) ::=> SelfType := {
        tally := 0.
        array := Array basicNew: initialCapacity.
        values := Array basicNew: initialCapacity.
        return: self
    }.

    method scanFor: (key: ProtoObject) ::=> UIntPointer := {
        <staticBinding>
        <nogc>

        ## Make sure we at least have a size.
        let keyCount := array __private __data size.
        if: keyCount = 0 then: {
            return: 0
        }.

        ## Find the natural key slot.
        let keySlot := key identityHash % keyCount.

        ## Perform linear probing.
        let i mutable := keySlot.
        while: i < keyCount do: {
            let slotKey := array __private __data[i].
            if: slotKey == key || slotKey == nil then: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let slotKey := array __private __data[i].
            if: slotKey == key || slotKey == nil then: {
                return: (i + 1 castTo: UIntPointer)
            }.
        } continueWith: { i := i + 1 }.

        return: 0
    }.

    method at: (key: ProtoObject) putNoSpaceCheck: (value: ProtoObject) ::=> SelfType := {
        <staticBinding>
        let slot := self scanFor: key.
        if: slot == 0 then: {
            return: self
        }.

        array __private __data[slot - 1] := key.
        values __private __data[slot - 1] := value.
        tally := tally + 1.
        return: self
    }.

    method atOrNil: (key: ProtoObject) ::=> ProtoObject := {
        <staticBinding>
        <nogc>
        ## LibC printf("atOrNil: %p | tally %zu array [%d]%p values [%d]%p\n", key, tally, array basicSize, array, values basicSize, values).
        let slot := self scanFor: key.
        if: slot == 0 then: {
            return: nil
        }.

        ##LibC printf("Found key %p in slot %d\n", array[slot], slot).
        return: values __private __data[slot - 1]
    }.
}.

##-----------------------------------------------------------------------------
## Block closure
BlockClosure definition: {
	protected field outerContext.
	protected field startpc type: UIntPointer.
	protected field numArgs type: UInt32.

	method cull: argument := {
		numArgs < 1 ifTrue: {
			self value
		} ifFalse: {
			self value: argument
		}.
	}.

	method cull: firstArg cull: secondArg := {
		numArgs < 2 ifTrue: {
			self cull: firstArg
		} ifFalse: {
			self value: firstArg value: secondArg
		}.
	}.

	method cull: firstArg cull: secondArg cull: thirdArg := {
		numArgs < 3 ifTrue: {
			self cull: firstArg cull: secondArg
		} ifFalse: {
			self value: firstArg value: secondArg value: thirdArg
		}.
	}.

	method cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg := {
		numArgs < 4 ifTrue: {
			self cull: firstArg cull: secondArg cull: thirdArg
		} ifFalse: {
			self value: firstArg value: secondArg value: thirdArg value: fourthArg
		}.
	}.
}.

NativeBlockClosureHeaderClass definition: {
	virtual method initializeCopyingFrom: o
		:= self.
	virtual method initializeMovingFrom: o
		:= self.
	virtual method finalize
		:= self.
}.

NativeBlockClosure definition: {
	protected field activationFunctionPointer_ type: Void pointer.

	inline method checkRequiredArgumentCount: (i: UInt32) ::=> Void := {
		numArgs ~= i ifTrue: {
			Stdn fatalError: "Mismatching argument count for block closure activation."
		}.
	}.

	method value := {
		self checkRequiredArgumentCount: 0.
		(startpc reinterpretCastTo:
			((Void pointer -- BlockClosure) => ProtoObject) pointer)
				(activationFunctionPointer_, self)
	}.

	method value: argument := {
		self checkRequiredArgumentCount: 1.
		(startpc reinterpretCastTo:
			(Void pointer -- BlockClosure -- ProtoObject => ProtoObject) pointer)
				(activationFunctionPointer_, self, argument)
	}.

	method value: firstArg value: secondArg := {
		self checkRequiredArgumentCount: 2.
		(startpc reinterpretCastTo:
			((Void pointer -- BlockClosure -- ProtoObject -- ProtoObject) => ProtoObject) pointer)
				(activationFunctionPointer_, self, firstArg, secondArg)
	}.

	method value: firstArg value: secondArg value: thirdArg := {
		self checkRequiredArgumentCount: 3.
		(startpc reinterpretCastTo:
			((Void pointer -- BlockClosure -- ProtoObject -- ProtoObject -- ProtoObject) => ProtoObject) pointer)
				(activationFunctionPointer_, self, firstArg, secondArg, thirdArg)
	}.

	method value: firstArg value: secondArg value: thirdArg value: fourthArg := {
		self checkRequiredArgumentCount: 4.
		(startpc reinterpretCastTo:
			((Void pointer -- BlockClosure -- ProtoObject -- ProtoObject -- ProtoObject -- ProtoObject) => ProtoObject) pointer)
				(activationFunctionPointer_, self, firstArg, secondArg, thirdArg, fourthArg)
	}.

	method value: firstArg value: secondArg value: thirdArg value: fourthArg value: fifthArg := {
		self checkRequiredArgumentCount: 5.
		(startpc reinterpretCastTo:
			((Void pointer -- BlockClosure -- ProtoObject -- ProtoObject -- ProtoObject -- ProtoObject -- ProtoObject) => ProtoObject) pointer)
				(activationFunctionPointer_, self, firstArg, secondArg, thirdArg, fourthArg, fifthArg)
	}.

	method value: firstArg value: secondArg value: thirdArg value: fourthArg value: fifthArg value: sixthArg := {
		self checkRequiredArgumentCount: 6.
		(startpc reinterpretCastTo:
			((Void pointer -- BlockClosure -- ProtoObject -- ProtoObject -- ProtoObject -- ProtoObject -- ProtoObject -- ProtoObject) => ProtoObject) pointer)
				(activationFunctionPointer_, self, firstArg, secondArg, thirdArg, fourthArg, fifthArg, sixthArg)
	}.
}.

Symbol definition: {
	method value: firstArg
		:= firstArg perform: self.
}.

NativeSimpleBlockClosure definition: {
    field __captures protected type: ProtoObject array.
}.

FullBlockClosure definition: {
	protected field receiver.
}.

##-----------------------------------------------------------------------------
## Object perform
Object definition: {
	## perform:(with:)* is defined as a macro that generates a message send with
	## the symbol argument as a selector, so exploit the macro expansion machinery
	## for implementing #perform: in terms of #perform:
	method perform: aSymbol
		:= self perform: aSymbol.

	method perform: aSymbol with: anObject
		:= self perform: aSymbol with: anObject.

	method perform: aSymbol with: firstObject with: secondObject
		:= self perform: aSymbol with: firstObject with: secondObject.

	method perform: aSymbol with: firstObject with: secondObject with: thirdObject
		:= self perform: aSymbol with: firstObject with: secondObject with: thirdObject.

	method perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject
		:= self perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject.

	method perform: aSymbol withArguments: anArray := {
		(anArray size castTo: UIntPointer) selectCase: #{
		0 : {return: (self perform: aSymbol)}.
		1 : {return: (self perform: aSymbol with: anArray first)}.
		2 : {return: (self perform: aSymbol with: anArray first with: anArray second)}.
		3 : {return: (self perform: aSymbol with: anArray first with: anArray second with: anArray third)}.
		4 : {return: (self perform: aSymbol with: anArray first with: anArray second with: anArray third with: anArray fourth)}.
		5 : {return: (self perform: aSymbol with: anArray first with: anArray second with: anArray third with: anArray fourth with: anArray fifth)}.
		6 : {return: (self perform: aSymbol with: anArray first with: anArray second with: anArray third with: anArray fourth with: anArray fifth with: anArray sixth)}.
		7 : {return: (self perform: aSymbol with: anArray first with: anArray second with: anArray third with: anArray fourth with: anArray fifth with: anArray sixth with: anArray seventh)}.
		_ : self error: "Unsupported argument count for  #perform:withArguments:."
		}.
	}
}.

##-----------------------------------------------------------------------------
## Message definition, for #doesNotUnderstand:
Message definition: {
	public field selector.
	public field args.
	public field lookupClass.
}.

##-----------------------------------------------------------------------------
## Normal method lookup
namespace Runtime definition: {

struct MessageLookupResult definition: {
	public field methodObject type: Void pointer.
	public field dispatchTrampoline type: Void pointer.
}.

struct InlineCacheRecord definition: {
	public field lookupClass type: Stdn AtomicUIntPointer.
	public field lookupMethod type: Stdn AtomicUIntPointer.
}.

struct InlineCache definition: {
	compileTime constant RecordCount := 5.
	public field lastWrittenSlot type: Stdn AtomicUIntPointer.
	public field records type: (InlineCacheRecord array: RecordCount).
}.

function genericMessageLookup(receiver: ProtoObject, selector: Object, typeInfo: TypeInformation,
	nativeDispatchTrampoline: Void pointer, objectDispatchTrampoline: Void pointer,
	inlineCache: InlineCache pointer) => MessageLookupResult := {
	<nogc>

	let lookupResult mutable type: MessageLookupResult.
	let methodObject := typeInfo lookupSelector: selector.

    if: methodObject == nil then: {
        if: selector == #doesNotUnderstand: then: {
            LibC printf("Fatal error: Failed to lookup doesNotUnderstand:\n").
            LibC abort().
        }.

        lookupResult methodObject: (typeInfo reinterpretCastTo: Void pointer).
		lookupResult dispatchTrampoline: objectDispatchTrampoline.
    } else: {
		if: methodObject class == NativeCompiledMethod then: {
			let compiledMethod := methodObject reinterpretCastTo: NativeCompiledMethod.
			lookupResult methodObject: compiledMethod entryPoint.
			lookupResult dispatchTrampoline: nativeDispatchTrampoline.
		} else: {
			lookupResult methodObject: (methodObject reinterpretCastTo: Void pointer)..
			lookupResult dispatchTrampoline: objectDispatchTrampoline.
		}.
	}.

	return: lookupResult
}.

inline function receiverClassGetter(receiver: ProtoObject) => TypeInformation := {
	<nogc>
	receiver class
}.

inline function methodSuperClassGetter(methodClass: TypeInformation) => TypeInformation := {
	<nogc>
	methodClass superclass
}.

inline function gcBlockClosureAllocator(instanceSize: UIntPointer, instanceAlignment: UIntPointer, prototype: Void pointer) => BlockClosure := {
	<nogc>
	let allocatedObject := Stdn GC NativeCollector uniqueInstance
 		allocate: instanceSize instanceAlignment: 0
		copyingFromPrototype: prototype.

	return: (allocatedObject reinterpretCastTo: BlockClosure)
}.

Compiler compilationTarget managedObjectModel
    messageLookupFunction: genericMessageLookup;
	receiverClassGetter: receiverClassGetter;
	methodSuperClassGetter: methodSuperClassGetter;
	inlineCacheStructure: InlineCache;

	gcLayoutClass: GCLayout;
    arrayClass: Array;
    associationClass: Association;
    byteArrayClass: ByteArray;
    compiledMethodClass: NativeCompiledMethod;
    dictionaryClass: Dictionary;
	identityDictionaryClass: IdentityDictionary;
	systemDictionaryClass: SystemDictionary;
    methodDictionaryClass: MethodDictionary;
	additionalMethodStateClass: AdditionalMethodState;
	pragmaClass: Pragma;
	messageClass: Message;
    symbolClass: Symbol;
    stringClass: String;
	characterClass: Character;
	integerClass: Integer;
	largePositiveIntegerClass: LargePositiveInteger;
	largeNegativeIntegerClass: LargeNegativeInteger;
	floatClass: Float;
	boxedFloat64Class: BoxedFloat64;
	fractionClass: Fraction;
	scaledDecimalClass: ScaledDecimal;
	boolClass: Boolean;
	trueClass: True;
	falseClass: False;

	additionalBindingClass: AdditionalBinding;
	classVariableClass: ClassVariable;
	globalVariableClass: GlobalVariable;
	undeclaredVariableClass: UndeclaredVariable;
	workspaceVariableClass: WorkspaceVariable;

	blockClosureHeaderClass: NativeBlockClosureHeaderClass;
	blockClosureClass: NativeBlockClosure;
	simpleBlockClosureClass: NativeSimpleBlockClosure;
	gcBlockClosureAllocationFunction: gcBlockClosureAllocator;
    yourself
}.

}.
