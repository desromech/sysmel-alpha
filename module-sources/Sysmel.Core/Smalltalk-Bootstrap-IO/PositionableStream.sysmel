namespace Smalltalk definition: {
#**
 * I am a positionable read stream for reading the content of a collection.
 * My implementation is ported from Pharo.
 *#
gcclass PositionableStream superclass: Stream; definition: {
    public field collection.
    protected field position type: UIntPointer.
    protected field readLimit type: UIntPointer.

    meta definition: {
        method on: aCollection
            := self basicNew on: aCollection.

        method on: aCollection from: firstIndex to: lastIndex
            := self basicNew on: aCollection from: firstIndex to: lastIndex.

        method with: aCollection do: aBlock := {
            let aStream := self on: aCollection.
            try: {
                aBlock value: aStream
            } finally: {aStream close}
        }.
    }.

    method on: aCollection := {
        collection := aCollection.
        position := 0.
        readLimit := aCollection size castTo: UIntPointer.
        self reset.
        self
    }.

    method on: aCollection from: firstIndex to: lastIndex
        := self on: (aCollection copyFrom: firstIndex to: lastIndex).

    method reset := {
        position := 0.
        self
    }.

    method position
        := position.

    method skip: anInteger := {
        let newPosition := (position castTo: IntPointer) + (anInteger castTo: IntPointer) castTo: UIntPointer.
        newPosition > readLimit ifTrue: { self positionError }.
        position := newPosition.
    }.

    method skipTo: anObject := {
        until: self atEnd do: {
            self next = anObject ifTrue: {return: true}
        }.
        false
    }.

    method position: anInteger := {
        let newPosition := anInteger castTo: IntPointer.
        0 <= newPosition && newPosition <= (readLimit castTo: IntPointer)
            ifTrue: { position := newPosition castTo: UIntPointer }
            ifFalse: { self positionError }.
        self
    }.

    method positionError
        := self error: "Attempt to set the position of a PositionableStream out of bounds".

    method contents
        := collection copyWithSize: readLimit.

    method originalContents
        := collection.

    method atEnd
        := position >= readLimit.

    method isBinary
        := collection class == ByteArray.

    method isEmpty
        := position >= readLimit && position = 0.

    method oldBack := {
        position = 0 ifTrue: {self positionError}.
        position = 1 ifTrue: { position := 0. return: nil}.
        self skip: -2.
        self next
    }.

    method oldPeekBack := {
        let element := self oldBack.
        self skip: 1.
        element
    }.

    method back := {
        position = 0 ifTrue: {self positionError}.
        position := position - 1.
        self peek.
    }.

    method peekBack := {
        let element := self back.
        self skip: 1.
        element
    }.

    method peek := {
        self atEnd ifTrue: {return: nil}.

        let nextObject := self next.
        position := position - 1.
        nextObject
    }.

    method peekFor: anObject := {
        self atEnd ifTrue: {return: false}.

        let nextObject := self next.
        nextObject = anObject ifTrue: {return: true}.

        position := position - 1.
        false
    }.

    method next: elementsToRead := {
        let result := collection species new: elementsToRead.
        1 to: (elementsToRead castTo: UIntPointer) do: {:i :: Void |
            result at: i put: self next
        }.
        result
    }.

    method positionOfSubCollection: subCollection
        := self positionOfSubCollection: subCollection ifAbsent: {| 0}.

    method positionOfSubCollection: subCollection ifAbsent: exceptionBlock := {
        let pattern := subCollection readStream.
        let startPosition := self position.
        until: pattern atEnd do: {
            self atEnd ifTrue: { return: exceptionBlock value }.
            self next = pattern next ifFalse:  {
                self position: self position - pattern position + 1.
                pattern reset
            }.
        }.

    	let currentPosition := self position.
    	self position: startPosition.
    	pattern atEnd
    		ifTrue: { currentPosition + 1 - subCollection size }
    		ifFalse: { exceptionBlock value }
    }.

    method match: subCollection := {
        let pattern := subCollection readStream.
        until: self atEnd || pattern atEnd do: {
            self skip: pattern position negated.
            pattern setToStart.
            (self skipTo: pattern next) ifFalse: {return: false}.
            while: pattern atEnd not && self next = pattern peek do: pattern next.
        }.

        pattern atEnd
    }.

    method upTo: anObject := {
        let newStream := (collection species new: 100) writeStream.
        let element mutable.
        until: self atEnd || (element := self next) = anObject do: {
            newStream nextPut: element
        }.
        newStream contents
    }.

    method upToAll: aCollection := {
        let startPos := position.
        (self match: aCollection) ifTrue: {
            let endMatch := position.
            position := startPos.
            let result := self upToPosition: endMatch - (aCollection size castTo: UIntPointer).
            position := endMatch.
            result
        } ifFalse: {
            position := startPos.
            self upToEnd
        }
    }.

    method upToPosition: anInteger
        := self next: anInteger - position.

    method upToEnd := {
        let newStream := (collection species new: 100) writeStream.
        until: self atEnd do: {
            newStream nextPut: self next
        }.
        newStream contents
    }.

    method setToEnd := {
        position := readLimit.
        self
    }.

    method setToStart
        := self reset.

}.

} ## End of namespace Smalltalk
