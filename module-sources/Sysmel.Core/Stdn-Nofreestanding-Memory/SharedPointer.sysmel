namespace Stdn definition: {

template SharedRefCounter(PT: Type)
    := struct definition: {
    compileTimeConstant PointedType := PT.
	compileTimeConstant PointerType := PointedType pointer.
    compileTimeConstant CounterType := SelfType.

    meta extend: {
        inline method for: (pointer: PointerType) ::=> CounterType pointer := {
            pointer ifNil: {
                nil
            } ifNotNil: {
                CounterType basicNativeNew _
                    initializeWith: pointer;
                    address.
            }
        }.
    }.

    private field strongCounter_ type: AtomicUIntPointer.
    private field weakCounter_ type: AtomicUIntPointer.
    private field pointer_ type: PointerType.

    inline method initializeWith: (pointer: PointerType) ::=> Void := {
        strongCounter_ store: 1 with: MemoryOrder Release.
        weakCounter_ store: 1 with: MemoryOrder Release.
        pointer_ := pointer
    }.

    inline const method getPointer => PointerType
        := pointer_.

    inline method strongRetain => Void := {
        strongCounter_ fetchAndAdd: 1 with: MemoryOrder AcquireAndRelease
    }.

    inline method strongRelease => Void := {
        let oldCount := strongCounter_ fetchAndSubtract: 1 with: MemoryOrder AcquireAndRelease.
        ##Stdn stdout << "Old strong release count " << oldCount; nl.
        oldCount == 1 ifTrue: {
            ##Stdn stdout << "No more strong counts delete the object " << pointer_; nl.
            pointer_ nativeDelete.
            self weakRelease.
        }.

    }.

    inline method weakRetain => Void := {
        weakCounter_ fetchAndAdd: 1 with: MemoryOrder AcquireAndRelease.
    }.

    inline method weakRelease => Void := {
        let oldCount := weakCounter_ fetchAndSubtract: 1 with: MemoryOrder AcquireAndRelease.
        ##Stdn stdout << "Old weak release count " << oldCount; nl.
        oldCount == 1 ifTrue: {
            ##Stdn stdout << "No more weak count, delete the counter " << self address; nl.
            self address nativeDelete
        }
    }.

    inline method weakLock => Boolean8 := {
        let oldCount mutable type: UIntPointer.
        while: (oldCount := strongCounter_ loadWith: MemoryOrder Acquire) ~= 0 do: {
            (strongCounter_ atomicCompare: oldCount andSet: oldCount + 1 with: MemoryOrder AcquireAndRelease) ifTrue: {
                return: true
            }
        }.

        return: false
    }.
}.

template SharedPointer(PT: Type)
    := struct definition: {
    compileTimeConstant PointedType := PT.
	compileTimeConstant PointerType := PointedType pointer.
    compileTimeConstant CounterType := SharedRefCounter(PT).
	compileTimeConstant SmartPointerType := SelfType.
	compileTimeConstant WeakPointerType := WeakPointer(PT).

    meta extend: {
        inline method for: (pointer: PointerType) ::=> SmartPointerType
            := SmartPointerType basicNewValue initializeWithNewCounter: (CounterType for: pointer) andPointer: pointer; yourself.
        macro method nil := ``(`,self basicNewValue).
    }.

    private field counter_ type: CounterType pointer.

    inline method finalize => Void := {
        counter_ ifNotNil: {
            counter_ _ strongRelease.
        }.
    }.

    inline method initializeWithNewCounter: (counter: CounterType pointer) andPointer: (pointer: PointerType)::=> Void := {
        counter_ := counter
    }.

    inline method initializeCopyingFrom: (o: SelfType const ref) ::=> Void := {
		counter_ := o __private counter_.
		counter_ ifNotNil: {
			counter_ _ strongRetain
		}.
	}.

	inline method initializeMovingFrom: (o: SelfType tempRef) ::=> Void := {
		counter_ := o __private counter_.
		o __private counter_ := nil
	}.

    const inline method = (other: SelfType const ref) ::=> Boolean8
        := counter_ = other __private counter_ .

    const inline method hash ::=> Hash
        := counter_ hash.

    inline const method _ => PointedType ref
        := self getPointer _.

    inline const method getCounter => CounterType pointer
        := counter_ .

    inline const method getPointer => PointerType := {
        counter_ ifNil: {
            return: nil
        }.

        return: counter_ _ getPointer.
    }.

    inline method initializeWithExistingCounter: (newCounter: CounterType pointer) andPointer: (newPointer: PointerType) ::=> Void := {
        newCounter ifNotNil: {
            newCounter _ strongRetain.
        }.

        counter_ := newCounter
	}.

    inline method reset: (newPointer: PointerType) ::=> Void := {
        counter_ ifNotNil: {
            counter_ _ strongRelease.
        }.

        counter_ := CounterType for: newPointer
	}.

	inline method reset => Void
		:=  self reset: nil.

    (inline method := (o: SelfType const ref)) ::=> SelfType const ref := {
		let newCounter := o __private counter_.
		newCounter ifNotNil: {
			newCounter _ strongRetain
		}.
        counter_ ifNotNil: {
			counter_ _ strongRelease
		}.

		counter_ := newCounter.
		self
	}.

	(inline method := (o: SelfType tempRef)) ::=> SelfType const ref := {
		let newCounter := o __private counter_.
		o __private counter_ := nil.
		counter_ ifNotNil: {
			counter_ _ strongRelease
		}.

		counter_ := newCounter.
		self
	}.

    inline method asWeakPointer => WeakPointerType
        := WeakPointerType for: self.

    macro method upCastFor: targetType := {
        let tempRef := __astBuilder gensym: #smartPointer.
        ``{
            let `,tempRef ref := `,self.

            Stdn SharedPointer(`,targetType) basicNewValue
                initializeWithExistingCounter: (`,tempRef getCounter reinterpretCastTo: Stdn SharedRefCounter(`,targetType) pointer)
                andPointer: `,tempRef getPointer;
                yourself
        } asSequenceWithoutLexicalScope
    }.

    macro method downCastFor: targetType := {
        let tempRef := __astBuilder gensym: #smartPointer.
        ``{
            let `,tempRef ref := `,self.

            Stdn SharedPointer(`,targetType) basicNewValue
                initializeWithExistingCounter: (`,tempRef getCounter reinterpretCastTo: Stdn SharedRefCounter(`,targetType) pointer)
                andPointer: (`,tempRef getPointer castTo: `,targetType);
                yourself
        } asSequenceWithoutLexicalScope
    }.

    ## Some convenience macros.
	macro method isNil := ``(`,self getPointer isNil).
	macro method isNotNil := ``(`,self getPointer isNotNil).

	macro method ifNil: nilAction := ``(`,self getPointer ifNil: `,nilAction).
	macro method ifNil: nilAction ifNotNil: notNilAction := ``(`,self getPointer ifNil: `,nilAction ifNotNil: `, notNilAction).
	macro method ifNotNil: notNilAction := ``(`,self getPointer ifNotNil: `,notNilAction).
	macro method ifNotNil: notNilAction ifNil: nilAction  := ``(`,self getPointer ifNotNil: `,notNilAction ifNil: `,nilAction).
}.

template WeakPointer(PT: Type)
    := struct definition: {
    compileTimeConstant PointedType := PT.
	compileTimeConstant PointerType := PointedType pointer.
    compileTimeConstant CounterType := SharedRefCounter(PT).
	compileTimeConstant WeakPointerType := SelfType.
	compileTimeConstant StrongPointerType := SharedPointer(PT).

    private field counter_ type: CounterType pointer.

    meta extend: {
        inline method for: (strongRef: StrongPointerType const ref) ::=> WeakPointerType
            := WeakPointerType basicNewValue initializeWith: strongRef __private counter_; yourself.
        macro method nil := ``(`,self basicNewValue).
    }.

    inline method finalize => Void := {
        counter_ ifNotNil: {
            counter_ _ weakRelease.
        }.
    }.

    inline method initializeWith: (theCounter: CounterType pointer) ::=> Void := {
        counter_ := theCounter.
        counter_ ifNotNil: {
            counter_ _ weakRetain.
        }.
    }.

    inline method initializeCopyingFrom: (o: SelfType const ref) ::=> Void := {
		self initializeWith: o __private counter_.
	}.

	inline method initializeMovingFrom: (o: SelfType tempRef) ::=> Void := {
		counter_ := o __private counter_.
		o __private counter_ := nil
	}.

    (inline method := (o: StrongPointerType const ref)) ::=> SelfType const ref := {
		let newCounter := o __private counter_.
		newCounter ifNotNil: {
			counter_ _ weakRetain
		}.
        counter_ ifNotNil: {
			counter_ _ weakRelease
		}.

		counter_ := newCounter.
		self
	}.

    (inline method := (o: SelfType const ref)) ::=> SelfType const ref := {
		let newCounter := o __private counter_.
		newCounter ifNotNil: {
			counter_ _ weakRetain
		}.
        counter_ ifNotNil: {
			counter_ _ weakRelease
		}.

		counter_ := newCounter.
		self
	}.

	(inline method := (o: SelfType tempRef)) ::=> SelfType const ref := {
		let newCounter := o __private counter_.
		o __private counter_ := nil.
		counter_ ifNotNil: {
			counter_ _ weakRelease
		}.

		counter_ := newCounter.
		self
	}.
}.

_NativeType meta macro method sharedPointer := ``(Stdn SharedPointer(`,self)).
_NativeType meta macro method weakPointer := ``(Stdn WeakPointer(`,self)).

_NativeType meta macro method sharedNew := ``(`,self sharedPointer for: `,self nativeNew).

}. ## End of namespace Stdn
