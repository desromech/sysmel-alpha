namespace Stdn definition: {
namespace GC definition: {

useNamespace: Stdn Reflection.

class NativeCollector definition: {
    compileTime constant CollectionStartThresholdIncrement := 2<<20 castTo: UIntPointer.

    field memoryHeap mutable type: Stdn Memory GarbageCollectableMemoryHeap.

    field collectorMutex type: Stdn Mutex.
    field moduleRootPointers type: Stdn Collections Vector(GCRootPointersDescriptor).
    field markingStack type: Stdn Collections Vector(GCObjectHeader pointer).
    field explicitRootSet type: Stdn Collections Vector(GCObjectHeader pointer pointer). ## FIME: use a set here.

    field whiteColor type: UInt32.
    field grayColor type: UInt32.
    field blackColor type: UInt32.

    field nextCollectionStartThreshold type: UIntPointer.
    field collectionThresholdIncrement type: UIntPointer.

    meta definition: {
        global singleton mutable type: NativeCollector; constructionPriority: Compiler compilationTarget gcInitializationPriority.

        inline method uniqueInstance => NativeCollector ref
            := singleton.
    }.

    method initialize => Void := {
        <nogc>
        whiteColor := 0u.
        grayColor := 1u.
        blackColor := 2u.

        collectionThresholdIncrement := CollectionStartThresholdIncrement.
        LibC getenv("SYSMEL_GC_THRESHOLD") ifNotNil: {:setting :: Void |
            collectionThresholdIncrement := LibC atoi(setting) castTo: UIntPointer.
            collectionThresholdIncrement > 0 ifTrue: {
                collectionThresholdIncrement := collectionThresholdIncrement max: 1024
            }
        }.

        nextCollectionStartThreshold := collectionThresholdIncrement.
    }.

    method finalize => Void := {
        collectorMutex withLock: {
            self garbageCollect
        }.
    }.

    method allocate: (objectSize: UIntPointer)
        variableDataSize: (variableDataSize: UIntPointer)
        initializingWith: (basicInitializer: Stdn Reflection BasicInitializeFunctionPointerType)
          ::=> Stdn Reflection GCObjectHeader pointer := {
        <nogc>

        ## Allocate the object memory.
        let allocatedObject := (self allocateMemoryForObjectOfSize: objectSize) reinterpretCastTo: Stdn Reflection GCObjectHeader pointer.
        LibC memset(allocatedObject, 0, objectSize).

        ## Set the allocated object class.
        allocatedObject value
            __variableDataSize: (variableDataSize castTo: UInt32);
            __gcColor: whiteColor.

        ## Perform the basic initialization. This sets the vtable pointers.
        basicInitializer _ (allocatedObject).

        return: allocatedObject
    }.

    method allocate: (objectSize: UIntPointer)
        variableDataSize: (variableDataSize: UIntPointer)
        initializingWith: (basicInitializer: Stdn Reflection BasicInitializeFunctionPointerType)
        copyingFrom: (originalObject: Void pointer) copyConstructor: (copyConstructor: Stdn Reflection CopyConstructorFunctionPointerType)
          ::=> Stdn Reflection GCObjectHeader pointer := {
        <nogc>

        ## Allocate the object memory.
        let allocatedObject := (self allocateMemoryForObjectOfSize: objectSize) reinterpretCastTo: Stdn Reflection GCObjectHeader pointer.
        copyConstructor ifNil: {
            LibC memcpy(allocatedObject, originalObject, objectSize).
            Stdn assert: allocatedObject _ __variableDataSize = variableDataSize.

            allocatedObject _
                __gcColor: whiteColor.
        } ifNotNil: {
            LibC memset(allocatedObject, 0, objectSize).

            allocatedObject _
                __variableDataSize: (variableDataSize castTo: UInt32);
                __gcColor: whiteColor.

            ## Perform the basic initialization and then invoke the copy constructor.
            basicInitializer _ (allocatedObject).
            copyConstructor(allocatedObject, originalObject).
        }.

        return: allocatedObject
    }.

    method allocate: (instanceSize: UIntPointer) instanceAlignment: (instanceAligment: UIntPointer)
		copyingFromPrototype: (prototype: Void pointer)
		  ::=> Stdn Reflection GCObjectHeader pointer := {
		<nogc>

        ## Allocate the object memory.
        let allocatedObject := (self allocateMemoryForObjectOfSize: instanceSize) reinterpretCastTo: Stdn Reflection GCObjectHeader pointer.

        ## Copy the data from the prototype
        LibC memcpy(allocatedObject, prototype, instanceSize).
        allocatedObject _ __gcColor: whiteColor.

        return: allocatedObject
	}.

    method allocateMemoryForObjectOfSize: (objectSize: UIntPointer) ::=> Void pointer := {
        <nogc>
        collectorMutex withLock: {
            memoryHeap totalAllocatedSize >= nextCollectionStartThreshold ifTrue: {
                self garbageCollect.
                collectionThresholdIncrement > 0 ifTrue: {
                    let newHeapAllocatedSize := memoryHeap totalAllocatedSize + objectSize.
                    newHeapAllocatedSize >= ((nextCollectionStartThreshold max: collectionThresholdIncrement) - collectionThresholdIncrement*80/100) ifTrue: {
                        nextCollectionStartThreshold := (newHeapAllocatedSize + collectionThresholdIncrement - 1) /collectionThresholdIncrement * collectionThresholdIncrement
                    }.
                }.
            }.
            (memoryHeap allocate: objectSize)
        }.
    }.

    method swapColors => Void := {
        <nogc>
        Stdn swapValue: whiteColor with: blackColor.
    }.

    method garbageCollect => Void := {
        <nogc>
        ## Mark phase
        self mark.

        ## Sweep phase.
        self sweep.

        ## Swap the colors.
        self swapColors.
    }.

    method registerModuleRoots: (descriptors: GCRootPointersDescriptor const arraySlice) ::=> Void := {
        <nogc>
        collectorMutex withLock: {
            ## FIXME: support the dynamic library loading case.
            moduleRootPointers addAll: descriptors.
        }.
    }.

    method mark => Void := {
        <nogc>

        Stdn assert: whiteColor ~= grayColor && grayColor ~= blackColor && blackColor ~= whiteColor.
        self markRoots.
        until: markingStack isEmpty do: {
            let currentObject := markingStack last.
            markingStack removeLast.
            self expandMarkingFrom: currentObject
        }.

        markingStack removeAll.
    }.

    method expandMarkingFrom: (object: GCObjectHeader pointer) ::=> Void := {
        <nogc>
        Stdn assert: object __isImmediateValue not.
        Stdn assert: object _ __gcColor = grayColor.

        let protoObject := object reinterpretCastTo: Smalltalk ProtoObject.
        let behavior := protoObject class.
        self enqueueNextObject: (behavior reinterpretCastTo: GCObjectHeader pointer).

        behavior __manipulateInstance: protoObject gcSlotsWith: {:(Smalltalk ProtoObject pointer)slotPointer :: Void |
            self enqueueNextObject: (slotPointer _ reinterpretCastTo: GCObjectHeader pointer)
        }.

        object _ __gcColor: blackColor
    }.

    method enqueueNextObject: (object: GCObjectHeader pointer) ::=> Void := {
        <nogc>
        Stdn assert: ((object reinterpretCastTo: Smalltalk ProtoObject) class reinterpretCastTo: UIntPointer) ~~ 16r657a.
        object __isImmediateValue not && object _ __gcColor = whiteColor ifTrue: {
            object _ __gcColor: grayColor.
            ##Stdn stdout << "enqueueNextObject " << object; nl.
            markingStack add: object
        }
    }.

    method markRoots => Void := {
        <nogc>
        self allRootsDo: {:root :: Void |
            self enqueueNextObject: root _.
        }.
    }.

    method sweep => Void := {
        <nogc>
        memoryHeap sweepAllocationsWhen: {:allocation :: Boolean8|
            let object := allocation reinterpretCastTo: GCObjectHeader pointer.
            let color := object _ __gcColor.
            Stdn assert: color ~= grayColor.
            #*color = whiteColor ifTrue: {
                Stdn stdout << "sweep ["
                    << ((allocation reinterpretCastTo: Smalltalk ProtoObject) class reinterpretCastTo: Void pointer)
                    << "] " << allocation; nl.
            }.*#

            color = whiteColor
        }
    }.

    method allRootsDo: (block: RootIterationBlock) ::=> Void := {
        <nogc>
        moduleRootPointers do: {:each :: Void |
            each rootsDo: block
        }.

        explicitRootSet do: {:each :: Void |
            block(each)
        }.

        self allStackRootsDo: block.
    }.

    method allModuleRootsDo: (iterationBlock: RootIterationBlock) ::=> Void := {
        moduleRootPointers do: {:each :: Void |
            each rootsDo: iterationBlock
        }
    }.

    method registerGCRootPointer: (rootPointer: GCObjectHeader pointer pointer) ::=> Void := {
        <nogc>
        collectorMutex withLock: {
            rootPointer _ := nil.
            explicitRootSet add: rootPointer
        }
    }.

    method unregisterGCRootPointer: (rootPointer: GCObjectHeader pointer pointer) ::=> Void := {
        <nogc>
        collectorMutex withLock: {
            explicitRootSet remove: rootPointer
        }
    }.
}.

}. ## End of namespace GC
}. ## End of namespace Stdn
