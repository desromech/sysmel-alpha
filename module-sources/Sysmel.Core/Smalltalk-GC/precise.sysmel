namespace Stdn definition: {
namespace GC definition: {

useNamespace: Stdn Reflection.

class NativeCollector definition: {
    field memoryHeap mutable type: Stdn Memory GarbageCollectableMemoryHeap.

    field collectorMutex type: Stdn Mutex.
    field moduleRootPointers type: Stdn Collections Vector(GCRootPointersDescriptor).
    field markingStack type: Stdn Collections Vector(GCObjectHeader pointer).
    field explicitRootSet type: Stdn Collections Vector(GCObjectHeader pointer pointer). ## FIME: use a set here.

    field whiteColor type: UInt32.
    field grayColor type: UInt32.
    field blackColor type: UInt32.

    meta definition: {
        global singleton mutable type: NativeCollector; constructionPriority: Compiler compilationTarget gcInitializationPriority.

        inline method uniqueInstance => NativeCollector ref
            := singleton.
    }.

    method initialize => Void := {
        <nogc>
        whiteColor := 0u.
        grayColor := 1u.
        blackColor := 2u.
    }.

    method finalize => Void := {
        self garbageCollect
    }.

    method allocate: (objectSize: UIntPointer)
        variableDataSize: (variableDataSize: UIntPointer)
        initializingWith: (basicInitializer: Stdn Reflection BasicInitializeFunctionPointerType)
          ::=> Stdn Reflection GCObjectHeader pointer := {
        <nogc>

        self checkForCollectionNeeded.
        ## Allocate the object memory.
        let allocatedObject := (memoryHeap allocate: objectSize) reinterpretCastTo: Stdn Reflection GCObjectHeader pointer.
        LibC memset(allocatedObject, 0, objectSize).

        ## Set the allocated object class.
        allocatedObject value
            __variableDataSize: (variableDataSize castTo: UInt32);
            __gcColor: whiteColor.

        ## Perform the basic initialization. This sets the vtable pointers.
        basicInitializer _ (allocatedObject).

        return: allocatedObject
    }.

    method allocate: (instanceSize: UIntPointer) instanceAlignment: (instanceAligment: UIntPointer)
		copyingFromPrototype: (prototype: Void pointer)
		  ::=> Stdn Reflection GCObjectHeader pointer := {
		<nogc>

        ## Allocate the object memory.
        self checkForCollectionNeeded.
        let allocatedObject := (memoryHeap allocate: instanceSize) reinterpretCastTo: Stdn Reflection GCObjectHeader pointer.

		## Copy the data from the prototype
        LibC memcpy(allocatedObject, prototype, instanceSize).
        allocatedObject _ __gcColor: whiteColor.

        return: allocatedObject
	}.

    method checkForCollectionNeeded => Void := {
        <nogc>
        self garbageCollect
    }.

    method swapColors => Void := {
        <nogc>
        Stdn swapValue: whiteColor with: blackColor.
    }.

    method garbageCollect => Void := {
        <nogc>
        collectorMutex withLock: {
            ## Mark phase
            self mark.

            ## Sweep phase.
            self sweep.

            ## Swap the colors.
            self swapColors.
        }.
    }.

    method registerModuleRoots: (descriptors: GCRootPointersDescriptor const arraySlice) ::=> Void := {
        <nogc>
        collectorMutex withLock: {
            ## FIXME: support the dynamic library loading case.
            moduleRootPointers addAll: descriptors.
        }.
    }.

    method mark => Void := {
        <nogc>

        Stdn assert: whiteColor ~= grayColor && grayColor ~= blackColor && blackColor ~= whiteColor.
        self markRoots.
        until: markingStack isEmpty do: {
            let currentObject := markingStack last.
            markingStack removeLast.
            self expandMarkingFrom: currentObject
        }.

        markingStack removeAll.
    }.

    method expandMarkingFrom: (object: GCObjectHeader pointer) ::=> Void := {
        <nogc>
        Stdn assert: object __isImmediateValue not.
        Stdn assert: object _ __gcColor = grayColor.

        let protoObject := object reinterpretCastTo: Smalltalk ProtoObject.
        let behavior := protoObject class.
        self enqueueNextObject: (behavior reinterpretCastTo: GCObjectHeader pointer).

        behavior __manipulateInstance: protoObject gcSlotsWith: {:(Smalltalk ProtoObject pointer)slotPointer :: Void |
            self enqueueNextObject: (slotPointer _ reinterpretCastTo: GCObjectHeader pointer)
        }.

        object _ __gcColor: blackColor
    }.

    method enqueueNextObject: (object: GCObjectHeader pointer) ::=> Void := {
        <nogc>
        Stdn assert: ((object reinterpretCastTo: Smalltalk ProtoObject) class reinterpretCastTo: UIntPointer) ~~ 16r657a.
        object __isImmediateValue not && object _ __gcColor = whiteColor ifTrue: {
            object _ __gcColor: grayColor.
            ##Stdn stdout << "enqueueNextObject " << object; nl.
            markingStack add: object
        }
    }.

    method markRoots => Void := {
        <nogc>
        self allRootsDo: {:root :: Void |
            self enqueueNextObject: root _.
        }.
    }.

    method sweep => Void := {
        <nogc>
        memoryHeap sweepAllocationsWhen: {:allocation :: Boolean8|
            let object := allocation reinterpretCastTo: GCObjectHeader pointer.
            let color := object _ __gcColor.
            Stdn assert: color ~= grayColor.
            #*color = whiteColor ifTrue: {
                Stdn stdout << "sweep ["
                    << ((allocation reinterpretCastTo: Smalltalk ProtoObject) class reinterpretCastTo: Void pointer)
                    << "] " << allocation; nl.
            }.*#

            color = whiteColor
        }
    }.

    method allRootsDo: (block: RootIterationBlock) ::=> Void := {
        <nogc>
        moduleRootPointers do: {:each :: Void |
            each rootsDo: block
        }.

        explicitRootSet do: {:each :: Void |
            block(each)
        }.

        self allStackRootsDo: block.
    }.

    method allModuleRootsDo: (iterationBlock: RootIterationBlock) ::=> Void := {
        moduleRootPointers do: {:each :: Void |
            each rootsDo: iterationBlock
        }
    }.

    method registerGCRootPointer: (rootPointer: GCObjectHeader pointer pointer) ::=> Void := {
        <nogc>
        collectorMutex withLock: {
            rootPointer _ := nil.
            explicitRootSet add: rootPointer
        }
    }.

    method unregisterGCRootPointer: (rootPointer: GCObjectHeader pointer pointer) ::=> Void := {
        <nogc>
        collectorMutex withLock: {
            explicitRootSet remove: rootPointer
        }
    }.
}.

}. ## End of namespace GC
}. ## End of namespace Stdn
