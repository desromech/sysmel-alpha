namespace Stdn definition: {
namespace Collections definition: {

#**
 * I am a mutable string
 *#
 sealed template BasicString(CT: Type)
 	:= class definition: {
    compileTime constant ValueType := CT.
    compileTime constant LiteralType := FixedArray(ValueType) const ref.
    compileTime constant PositionNotFound := UIntPointer maxValue.

    ## Mutable field for asCString.
    private field capacity_ mutable type: UIntPointer.
    private field size_ mutable type: UIntPointer.
    private field data_ mutable type: ValueType pointer.

    meta method computeCStringLength: (cstring: ValueType const pointer) ::=> UIntPointer := {
        cstring ifNil: { return: 0 }.

        let result mutable type: UIntPointer.
        while: cstring[result] ~= 0 do: {
            result := result + 1
        }.

        return: result.
    }.

    meta macro method fromCString: cstring := ``(`,self basicNewValue initializeFromCString: `,cstring; yourself).
    meta macro method fromLiteral: literalString := ``(`,self basicNewValue initializeFromLiteral: `,literalString; yourself).

    const inline method hash => UIntPointer := {
        let result mutable type: UIntPointer := 0.
        result
    }.

    const inline method = (other: SelfType const ref) ::=> Boolean8 := {
        let otherSize := other __private size_.
        let otherData := other __private data_.

        size_ == otherSize && memcmp(data_ , otherData, size_ * ValueType instanceSize) == 0
    }.

    inline method initializeFromCString: (cstring: ValueType const pointer) ::=> Void := {
        self := cstring
    }.

    inline method initializeFromLiteral: (literalString: LiteralType) ::=> Void := {
        self := literalString
    }.

    inline method finalize => Void := {
        data_ ifNotNil: {
            Stdn free(data_)
        }
    }.

    const inline method data => ValueType pointer
        := data_.

    const inline method size => UIntPointer
        := size_.

    const inline method capacity => UIntPointer
        := capacity_.

    const inline method asCString => ValueType const pointer := {
        size_ == 0 ifTrue: { return: "" }.

        capacity_ == size_ ifTrue: {
            self setCapacityTo: size_ + 1
        }.

        return: data_
    }.

    inline method add: (element: ValueType) ::=> Void
        := self addLast: element.

    inline method addLast: (element: ValueType) ::=> Void := {
        size_ >= capacity_ ifTrue: {
            self increaseCapacity
        }.

        data_[size_] := element.
        size_ := size_ + 1
    }.

    inline method removeLast: (element: ValueType) ::=> Void := {
        assert: size_ > 0.
        size_ := size_ - 1.
        data_[size_] := 0.
    }.

    inline method increaseCapacity => Void := {
        let newCapacity := capacity_ * 2u max: 10u.
        self setCapacityTo: newCapacity.
    }.

    const inline method setCapacityTo: (newCapacity: UIntPointer) ::=> Void := {
        let copySize := size_ min: newCapacity.
        let newData := Stdn zmalloc(newCapacity) reinterpretCastTo: ValueType pointer.
        Stdn memcpy(newData, data_, copySize * ValueType instanceSize).
        data_ ifNotNil: {
            Stdn free(data_)
        }.

        size_ := copySize.
        capacity_ := newCapacity.
        data_ := newData.
    }.

    (inline method := (other: SelfType const ref)) => SelfType ref := {
        self address ~~ other address ifTrue: {
            self setSizeNoCopy: other __private size_.
            Stdn memcpy(data_, other __private data_, size_ * ValueType instanceSize).
            self clearCapacityTail.
        }.

        self
    }.

    (inline method := (other: SelfType tempRef)) => SelfType ref := {
        self address ~~ other address ifTrue: {
            capacity_ := other __private capacity_.
            size_ := other __private size_.
            data_ := other __private data_.

            other __private capacity_ := 0.
            other __private size_ := 0.
            other __private data_ := nil.
        }.

        self
    }.

    (inline method := (cstring: ValueType const pointer)) => SelfType ref := {
        let newSize := SelfType computeCStringLength: cstring.
        self setSizeNoCopy: newSize.
        Stdn memcpy(data_, cstring, newSize * ValueType instanceSize).
        self
    }.

    (inline method := (literalString: LiteralType)) => SelfType ref := {
        self setSizeNoCopy: literalString size.
        Stdn memcpy(data_, literalString elements[0] address, literalString size * ValueType instanceSize).
        self
    }.

    inline method setSizeNoCopy: (newSize: UIntPointer) ::=> Void := {
        size_ := 0.
        capacity_ < newSize ifTrue: {
            self setCapacityTo: newSize
        }.
        size_ := newSize.

        self clearCapacityTail.
    }.

    inline method clearCapacityTail => Void := {
        let tailSize := capacity_ - size_.
        Stdn memset(data_[size_] address, 0, tailSize * ValueType instanceSize)
    }.

    method indexOf: (element: ValueType) ::=> UIntPointer := {
        0 until: size_ do: {:(UIntPointer)i :: Void |
            data_[i] == element ifTrue: {
                return: i
            }
        }.
        PositionNotFound
    }.

    method lastIndexOf: (element: ValueType) ::=> UIntPointer := {
        let lastFound mutable type: UIntPointer := PositionNotFound.
        0 until: size_ do: {:(UIntPointer)i :: Void |
            data_[i] == element ifTrue: {
                lastFound := i.
            }
        }.
        lastFound
    }.

    method copyFrom: (startIndex: UIntPointer) until: (endIndex: UIntPointer) ::=> SelfType := {
        let clippedStartIndex := startIndex min: size_.
        let clippedEndIndex := endIndex min: size_.

        let copySize := clippedEndIndex - clippedStartIndex.
        let result mutable type: SelfType.
        copySize > 0 ifTrue: {
            let copyByteSize := copySize * ValueType instanceSize.
            result __private capacity_ := copyByteSize + 1.
            result __private size_ := copyByteSize.
            result __private data_ := Stdn malloc(copyByteSize + ValueType instanceSize) reinterpretCastTo: ValueType pointer.
            Stdn memcpy(result __private data_, data_[clippedStartIndex] address, copyByteSize).
            ## FIXME: Fix this code generator backend bug.
            void
        }.

        result asMoveReference
    }.

    method allButFirst: (ignoredCount: UIntPointer) ::=> SelfType
        := self copyFrom: ignoredCount until: size_.

    method first: (extractedCount: UIntPointer) ::=> SelfType
        := self copyFrom: 0 until: extractedCount.
}.

compileTime constant String := BasicString(Char8).
compileTime constant WString := BasicString(Char16). ## Used in multiple Win32 APIs
compileTime constant LString := BasicString(Char32). ## Provided for utf8.

_LiteralString macro method asMutableString := ``(Stdn String fromLiteral: `,self).
_LiteralString macro method asMutableWString := ``(Stdn WString fromLiteral: `,self).
_LiteralString macro method asMutableLString := ``(Stdn LString fromLiteral: `,self).

Stdn IO TextStreamWriter extend: {
    method nextPutAll: (string: String const ref) ::=> Boolean8 := {
        (stream _ write: string data size: string size) == (string size castTo: IntPointer)
    }.

    inline method << (string: String const ref) ::=> SelfType ref := {
        self nextPutAll: string.
        self
    }.
}.

}. ## End of namespace Collections

compileTime constant String := Collections String.
compileTime constant WString := Collections WString.
compileTime constant LString := Collections LString.

}. ## End of namespace Stdn
