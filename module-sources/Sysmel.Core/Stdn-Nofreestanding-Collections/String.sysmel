namespace Stdn definition: {
namespace Collections definition: {

#**
 * I am a mutable string
 *#
 sealed template BasicString(CT: Type)
 	:= class definition: {
    compileTime constant ValueType := CT.
    compileTime constant LiteralType := FixedArray(ValueType) const ref.

    ## Mutable field for asCString.
    private field capacity_ mutable type: UIntPointer.
    private field size_ mutable type: UIntPointer.
    private field data_ mutable type: ValueType pointer.

    meta method computeCStringLength: (cstring: ValueType const pointer) ::=> UIntPointer := {
        cstring ifNil: { return: 0 }.

        let result mutable type: UIntPointer.
        while: cstring[result] ~= 0 do: {
            result := result + 1
        }.

        return: result.
    }.

    meta macro method fromCString: cstring := ``(`,self basicNewValue initializeFromCString: `,cstring; yourself).
    meta macro method fromLiteral: literalString := ``(`,self basicNewValue initializeFromLiteral: `,literalString; yourself).

    const inline method hash => UIntPointer := {
        let result mutable type: UIntPointer := 0.
        0 until: size_ do: {:(UIntPointer)i :: Void |
            result := (result + data_[i]) * 1664525
        }.
        result
    }.

    const inline method = (other: SelfType const ref) ::=> Boolean8 := {
        let otherSize := other __private size_.
        let otherData := other __private data_.

        size_ == otherSize && memcmp(data_ , otherData, size_ * ValueType instanceSize) == 0
    }.

    inline method initializeCopyingFrom: (other: SelfType const ref) ::=> Void := {
        self := other
    }.

    inline method initializeMovingFrom: (other: SelfType tempRef) ::=> Void := {
        self := other
    }.

    inline method initializeFromCString: (cstring: ValueType const pointer) ::=> Void := {
        self := cstring
    }.

    inline method initializeFromLiteral: (literalString: LiteralType) ::=> Void := {
        self := literalString
    }.

    inline method finalize => Void := {
        data_ ifNotNil: {
            Stdn free(data_)
        }
    }.

    const inline method data => ValueType pointer
        := data_.

    const inline method size => UIntPointer
        := size_.

    const inline method capacity => UIntPointer
        := capacity_.

    inline method [index: UIntPointer] ::=> ValueType ref := {
		assert: index < size_.
		data_[index].
	}.

    const inline method [index: UIntPointer] ::=> ValueType const ref := {
		assert: index < size_.
		data_[index].
	}.

    const inline method asCString => ValueType const pointer := {
        size_ == 0 ifTrue: { return: "" }.

        capacity_ == size_ ifTrue: {
            self setCapacityTo: size_ + 1
        }.

        return: data_
    }.

    inline method add: (element: ValueType) ::=> Void
        := self addLast: element.

    inline method addLast: (element: ValueType) ::=> Void := {
        size_ >= capacity_ ifTrue: {
            self increaseCapacity
        }.

        data_[size_] := element.
        size_ := size_ + 1
    }.

    inline method removeLast: (element: ValueType) ::=> Void := {
        assert: size_ > 0.
        size_ := size_ - 1.
        data_[size_] := 0.
    }.

    inline method reserve: (reservationSize: UIntPointer) ::=> Void := {
        let requiredCapacity := size_ + reservationSize.
        capacity_ < requiredCapacity ifTrue: {
            self setCapacityTo: requiredCapacity + 1
        }.
    }.

    inline method increaseCapacity => Void := {
        let newCapacity := capacity_ * 2u max: 10u.
        self setCapacityTo: newCapacity.
    }.

    const inline method setCapacityTo: (newCapacity: UIntPointer) ::=> Void := {
        let copySize := size_ min: newCapacity.
        let newData := Stdn zmalloc(newCapacity * ValueType instanceSize) reinterpretCastTo: ValueType pointer.
        Stdn memcpy(newData, data_, copySize * ValueType instanceSize).
        data_ ifNotNil: {
            Stdn free(data_)
        }.

        size_ := copySize.
        capacity_ := newCapacity.
        data_ := newData.
    }.

    (inline method := (other: SelfType const ref)) => SelfType ref := {
        self address ~~ other address ifTrue: {
            self setSizeNoCopy: other __private size_.
            Stdn memcpy(data_, other __private data_, size_ * ValueType instanceSize).
            self clearCapacityTail.
        }.

        self
    }.

    (inline method := (other: SelfType tempRef)) => SelfType ref := {
        self address ~~ other address ifTrue: {
            capacity_ := other __private capacity_.
            size_ := other __private size_.
            data_ := other __private data_.

            other __private capacity_ := 0.
            other __private size_ := 0.
            other __private data_ := nil.
        }.

        self
    }.

    (inline method := (cstring: ValueType const pointer)) => SelfType ref := {
        let newSize := SelfType computeCStringLength: cstring.
        self setSizeNoCopy: newSize.
        Stdn memcpy(data_, cstring, newSize * ValueType instanceSize).
        self
    }.

    (inline method := (literalString: LiteralType)) => SelfType ref := {
        self setSizeNoCopy: literalString size.
        Stdn memcpy(data_, literalString elements[0] address, literalString size * ValueType instanceSize).
        self
    }.

    inline method setSizeNoCopy: (newSize: UIntPointer) ::=> Void := {
        size_ := 0.
        capacity_ < newSize ifTrue: {
            self setCapacityTo: newSize
        }.
        size_ := newSize.

        self clearCapacityTail.
    }.

    inline method clearCapacityTail => Void := {
        let tailSize := capacity_ - size_.
        Stdn memset(data_[size_] address, 0, tailSize * ValueType instanceSize)
    }.

    macro method doWithIndex: aBlock := {
		let collection := __astBuilder gensym: #collection.
		let index := __astBuilder gensym: #index.
		``{
			let `,collection ref := `,self.
			0 until: `,self size do: {:(UIntPointer)`,index :: Void |
				`,aBlock __macroInlineBlock: `,collection[`,index] with: `,index
			}
		}
	}.

    macro method do: aBlock := {
		let collection := __astBuilder gensym: #collection.
		let index := __astBuilder gensym: #index.
		``{
			let `,collection ref := `,self.
			0 until: `,self size do: {:(UIntPointer)`,index :: Void |
				`,aBlock __macroInlineBlock: `,collection[`,index]
			}
		}
	}.

    Stdn Collections SequenceableCollectionMixin.
}.

compileTime constant String := BasicString(Char8).
compileTime constant WString := BasicString(Char16). ## Used in multiple Win32 APIs
compileTime constant LString := BasicString(Char32). ## Provided for utf8.

_LiteralString macro method asMutableString := ``(Stdn String fromLiteral: `,self).
_LiteralString macro method asMutableWString := ``(Stdn WString fromLiteral: `,self).
_LiteralString macro method asMutableLString := ``(Stdn LString fromLiteral: `,self).

Stdn IO TextStreamWriter extend: {
    method nextPutAll: (string: String const ref) ::=> Boolean8 := {
        (stream _ write: string data size: string size) == (string size castTo: IntPointer)
    }.

    inline method << (string: String const ref) ::=> SelfType ref := {
        self nextPutAll: string.
        self
    }.
}.

}. ## End of namespace Collections

compileTime constant String := Collections String.
compileTime constant WString := Collections WString.
compileTime constant LString := Collections LString.

}. ## End of namespace Stdn
