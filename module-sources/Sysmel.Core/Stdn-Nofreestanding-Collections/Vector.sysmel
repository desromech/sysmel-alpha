namespace Stdn definition: {
namespace Collections definition: {

template Vector(ET: Type)
	:= class definition: {
    compileTime constant ElementType := ET.

    private field capacity_ type: UIntPointer.
	private field size_ type: UIntPointer.
    private field storage_ type: ElementType pointer.

    method finalize => Void := {
        0 until: size_ do: {:(UIntPointer)i :: Void |.
            storage_[i] finalize
        }.
    }.

    const inline method capacity => UIntPointer
        := capacity_.
    const inline method size => UIntPointer
        := size_.
    const inline method data => ElementType pointer
        := storage_.

    const inline method isEmpty => Boolean8
        := size_ == 0.
    const inline method isNotEmpty => Boolean8
        := size_ ~= 0.

	inline method first => ElementType ref := {
		assert: size_ > 0.
		storage_[0].
	}.

	inline method second => ElementType ref := {
		assert: size_ > 0.
		storage_[1].
	}.

	inline method third => ElementType ref := {
		assert: size_ > 0.
		storage_[2].
	}.

	inline method last => ElementType ref := {
		assert: size_ > 0.
		storage_[size_ - 1].
	}.

	inline method at: (index: UIntPointer) ::=> ElementType ref := {
		assert: index >= 1.
		assert: index <= size_.
		storage_ at: index.
	}.

	inline method subscriptAt: (index: UIntPointer) ::=> ElementType ref := {
		assert: index < size_.
		storage_[index].
	}.

    method increaseCapacityToAtLeast: (requiredCapacity: UIntPointer) ::=> Void := {
		let newCapacity := requiredCapacity asLargerPowerOfTwo max: 16.
		newCapacity <= capacity_ ifTrue: {return: nil}.

		let newStorageSize := newCapacity * ElementType instanceSize.
		let newStorage := Stdn zmalloc(newStorageSize) reinterpretCastTo: ElementType pointer.

        0 until: size_ do: {:(UIntPointer)i :: Void |.
            newStorage[i]
				basicInitialize;
				initializeMovingFrom: storage_[i] asMoveReference.
			storage_[i] finalize.
        }.

		storage_ := newStorage.
		capacity_ := newCapacity.
    }.

    inline method add: (newElement: ElementType const ref) ::=> Void
        := self addLast: newElement.

    inline method addLast: (newElement: ElementType const ref) ::=> Void := {
        size_ >= capacity_ ifTrue: {
            self increaseCapacityToAtLeast: size_ + 1.
        }.

        storage_[size_]
            basicInitialize;
            initializeCopyingFrom: newElement.
        size_ := size_ + 1.
    }.

    inline method removeLast => Void := {
        assert: self isNotEmpty.
        size_ := size_ - 1.
        storage_[size_] finalize.
    }.

	method reserve: (reservedElements: UIntPointer) ::=> Void := {
		self increaseCapacityToAtLeast: size_ + reservedElements
	}.

	method resizeTo: (newSize: UIntPointer) ::=> Void := {
		## Same size, nothing is required.
		newSize = size_ ifTrue: {return: nil}.

		## Increase size, we may need to increase the, and basic initialize
		newSize > size_ ifTrue: {
			newSize > capacity_ ifTrue: {
				self increaseCapacityToAtLeast: newSize.
			}.

			## Initialize the new elements
			size_ until: newSize do: {:(UIntPointer)i :: Void |
				storage_[i] basicInitialize; initialize.
			}.

		} ifFalse: {
			assert: newSize < size_.

			## Invoke the finalizer of the removed elements.
			size_ until: newSize do: {:(UIntPointer)i :: Void |
				storage_[i] finalize
			}.
		}.

		size_ := newSize
	}.

	macro method do: aBlock := {
		let collection := __astBuilder gensym: #collection.
		let index := __astBuilder gensym: #index.
		``{
			let `,collection ref := `,self.
			0 until: `,self size do: {:(UIntPointer)`,index :: Void |
				`,aBlock __macroInlineBlock: `,collection[`,index]
			}
		}
	}.

	macro method select: aPredicate thenDo: aBlock := {
		let collection := __astBuilder gensym: #collection.
		let index := __astBuilder gensym: #index.
		``{
			let `,collection ref := `,self.
			0 until: `,self size do: {:(UIntPointer)`,index :: Void |
				if: (`,aPredicate __macroInlineBlock: `,collection[`,index]) then: {
					`,aBlock __macroInlineBlock: `,collection[`,index]
				}.
			}
		}
	}.

	inline method swapWith: (other: SelfType ref) ::=> Void := {
		Stdn swapValue: capacity_ with: other __private capacity_.
		Stdn swapValue: size_ with: other __private size_.
		Stdn swapValue: storage_ with: other __private storage_.
	}.
}.

}. ## End of namespace Collections
}. ## End of namespace Stdn
