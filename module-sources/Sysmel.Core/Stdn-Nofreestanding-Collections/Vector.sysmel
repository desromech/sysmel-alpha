namespace Stdn definition: {
namespace Collections definition: {

template Vector(ET: Stdn Concepts Copyable)
	:= class definition: {
    compileTime constant ElementType := ET.
    compileTime constant PositionNotFound := UIntPointer maxValue.
	compileTime constant PredicateType := ((ElementType const ref) => Boolean8) nativeBlockClosure.

    private field capacity_ type: UIntPointer.
	private field size_ type: UIntPointer.
    private field storage_ type: ElementType pointer.

    method finalize => Void := {
        0 until: size_ do: {:(UIntPointer)i :: Void |.
            storage_[i] finalize
        }.
    }.

    const inline method capacity => UIntPointer
        := capacity_.
    const inline method size => UIntPointer
        := size_.
    const inline method data => ElementType pointer
        := storage_.

    const inline method isEmpty => Boolean8
        := size_ == 0.
    const inline method isNotEmpty => Boolean8
        := size_ ~= 0.

	inline method first => ElementType ref := {
		assert: size_ > 0.
		storage_[0].
	}.

	inline method second => ElementType ref := {
		assert: size_ > 0.
		storage_[1].
	}.

	inline method third => ElementType ref := {
		assert: size_ > 0.
		storage_[2].
	}.

	inline method last => ElementType ref := {
		assert: size_ > 0.
		storage_[size_ - 1].
	}.

	inline method at: (index: UIntPointer) ::=> ElementType ref := {
		assert: index >= 1.
		assert: index <= size_.
		storage_ at: index.
	}.

	inline method subscriptAt: (index: UIntPointer) ::=> ElementType ref := {
		assert: index < size_.
		storage_[index].
	}.

    method increaseCapacityToAtLeast: (requiredCapacity: UIntPointer) ::=> Void := {
		let newCapacity := requiredCapacity asLargerPowerOfTwo max: 16.
		newCapacity <= capacity_ ifTrue: {return: nil}.

		let newStorageSize := newCapacity * ElementType instanceSize.
		let newStorage := Stdn zmalloc(newStorageSize) reinterpretCastTo: ElementType pointer.

        0 until: size_ do: {:(UIntPointer)i :: Void |.
            newStorage[i]
				basicInitialize;
				initializeMovingFrom: storage_[i] asMoveReference.
			storage_[i] finalize.
        }.

		storage_ := newStorage.
		capacity_ := newCapacity.
    }.

    inline method add: (newElement: ElementType const ref) ::=> Void
        := self addLast: newElement.

    inline method addLast: (newElement: ElementType const ref) ::=> Void := {
        size_ >= capacity_ ifTrue: {
            self increaseCapacityToAtLeast: size_ + 1.
        }.

        storage_[size_]
            basicInitialize;
            initializeCopyingFrom: newElement.
        size_ := size_ + 1.
    }.

    inline method removeLast => Void := {
        assert: self isNotEmpty.
        size_ := size_ - 1.
        storage_[size_] finalize.
    }.

	method reserve: (reservedElements: UIntPointer) ::=> Void := {
		self increaseCapacityToAtLeast: size_ + reservedElements
	}.

	method resizeTo: (newSize: UIntPointer) ::=> Void := {
		## Same size, nothing is required.
		newSize = size_ ifTrue: {return: nil}.

		## Increase size, we may need to increase the, and basic initialize
		newSize > size_ ifTrue: {
			newSize > capacity_ ifTrue: {
				self increaseCapacityToAtLeast: newSize.
			}.

			## Initialize the new elements
			size_ until: newSize do: {:(UIntPointer)i :: Void |
				storage_[i] basicInitialize; initialize.
			}.

		} ifFalse: {
			assert: newSize < size_.

			## Invoke the finalizer of the removed elements.
			size_ until: newSize do: {:(UIntPointer)i :: Void |
				storage_[i] finalize
			}.
		}.

		size_ := newSize
	}.

	macro method do: aBlock := {
		let collection := __astBuilder gensym: #collection.
		let index := __astBuilder gensym: #index.
		``{
			let `,collection ref := `,self.
			0 until: `,self size do: {:(UIntPointer)`,index :: Void |
				`,aBlock __macroInlineBlock: `,collection[`,index]
			}
		}
	}.

	macro method select: aPredicate thenDo: aBlock := {
		let collection := __astBuilder gensym: #collection.
		let index := __astBuilder gensym: #index.
		``{
			let `,collection ref := `,self.
			0 until: `,self size do: {:(UIntPointer)`,index :: Void |
				if: (`,aPredicate __macroInlineBlock: `,collection[`,index]) then: {
					`,aBlock __macroInlineBlock: `,collection[`,index]
				}.
			}
		}
	}.

	inline method swapWith: (other: SelfType ref) ::=> Void := {
		Stdn swapValue: capacity_ with: other __private capacity_.
		Stdn swapValue: size_ with: other __private size_.
		Stdn swapValue: storage_ with: other __private storage_.
	}.

	inline method removeAt: (index: UIntPointer) ::=> Void := {
		size_ == 0 || index >= size_ ifTrue: {
			return: void
		}.

		index until: size_ - 1 do: {:(UIntPointer)destIndex :: Void |
			storage_[destIndex] := storage_[destIndex + 1] asMoveReference
		}.

		size_ := size_ - 1.
		storage_[size_] finalize
	}.

	inline method removeAllSuchThat: (predicate: PredicateType) ::=> Void := {
		let destIndex mutable type: UIntPointer := 0.
		0 until: size_ do: {:(UIntPointer)i :: Void |
			predicate(storage_[i]) ifFalse: {
				destIndex ~~ i ifTrue: {
					storage_[destIndex] := storage_[i] asMoveReference.
					destIndex := destIndex + 1
				}
			}
		}.

		destIndex until: size_ do: {:(UIntPointer)i :: Void |
			storage_[i] finalize.
		}.

		size_ := destIndex.
	}.

	Stdn Concepts Equalable ifType: ElementType complies: {
		method = (other: SelfType const ref) ::=> Boolean8 := {
			size_ = other __private size_ ifFalse: { return: false }.
			0 until: size_ do: {:(UIntPointer)i :: Void |
				storage_[i] = other __private storage_[i] ifFalse: {
					return: false
				}
			}.

			true
		}.

		inline method indexOf: (value: ElementType const ref) ::=> UIntPointer := {
			0 until: size_ do: {:(UIntPointer)i :: Void |
				storage_[i] = value ifTrue: {
					return: i
				}
			}.

			return: PositionNotFound
		}.

		inline method remove: (value: ElementType const ref) ifAbsent: (absentBlock: (Void => Void) nativeBlockClosure) ::=> Void := {
			let elementIndex := self indexOf: value.
			elementIndex == PositionNotFound ifTrue: {
				return: absentBlock()
			}.

			self removeAt: elementIndex
		}.

		inline method remove: (value: ElementType const ref) ::=> Void := {
			self remove: value ifAbsent: {:: Void | Stdn raiseError("Failed to find element in Vector"). }
		}.
	}.

	Stdn Concepts HashKey ifType: ElementType complies: {
		method hash => UIntPointer := {
			let result mutable  := size_ hash.
			0 until: size_ do: {:(UIntPointer)i :: Void |
				result := (result + storage_[i] hash) * 1664525 ## TODO: Find a more suitable constant here.
			}.

			result
		}.
	}.
}.

}. ## End of namespace Collections
}. ## End of namespace Stdn
