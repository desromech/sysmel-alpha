namespace Stdn definition: {
namespace Collections definition: {

template Dictionary(KT: Type, VT: Type)
    := class definition: {
    compileTimeConstant KeyType := KT.
    compileTimeConstant ValueType := VT.
    compileTimeConstant AssociationType := Association(KeyType, ValueType).
    compileTimeConstant StorageElementType := Optional(AssociationType).
    compileTimeConstant StorageType := Vector(StorageElementType).

    private field size_ type: UIntPointer.
    private field storage_ type: StorageType.

    const inline method scanFor: (key: KeyType const ref) withHash: (hash: UIntPointer)::=> UIntPointer := {
        let currentCapacity := storage_ size.
        currentCapacity == 0 ifTrue: {
            return: currentCapacity.
        }.

        let slotIndex := hash % currentCapacity.

        ## Linear scan forward.
        slotIndex until: currentCapacity do: {:(UIntPointer)i :: Void |
            let slot ref := storage_[i].
            slot isPresent not || slot _ key = key ifTrue: {
                return: i
            }.
        }.

        ## Linear scan wrap-around. Avoid the expensive module % by breaking the loop in two parts.
        0 until: slotIndex do: {:(UIntPointer)i :: Void |
            let slot ref := storage_[i].
            slot isPresent not || slot _ key = key ifTrue: {
                return: i
            }.
        }.

        return: currentCapacity
    }.

    const inline method isValidIndex: (slotIndex: UIntPointer) ::=> Boolean8
        := slotIndex < storage_ size.

    const inline method scanFor: (key: KeyType const ref) ::=> UIntPointer
        := self scanFor: key withHash: key hash.

    const inline method includesKey: (key: KeyType const ref) ::=> Boolean8 := {
        let slotIndex := self scanFor: key.
        return: (self isValidIndex: slotIndex) && (storage_[slotIndex] isPresent)
    }.

    inline method at: (key: KeyType const ref) put: (value: ValueType const ref) ::=> Boolean8 := {
        let slotIndex mutable := self scanFor: key.
        (self isValidIndex: slotIndex) ifFalse: {
            self increaseCapacity.
            slotIndex := self scanFor: key.
        }.

        Stdn assert: (self isValidIndex: slotIndex).
        let isNewElement := storage_[slotIndex] isPresent not.
        isNewElement ifTrue: {
            storage_[slotIndex] := AssociationType newValue
                key: key;
                value: value;
                yourself.
            size_ := size_ + 1.
            self checkFullCapacityCondition.
        } ifFalse: {
            storage_[slotIndex] _ value := value
        }.

        isNewElement
    }.

    inline method at: (key: KeyType const ref) ifAbsentPut: (absentBlock: (Void => ValueType) nativeBlockClosure) ::=> ValueType ref := {
        let slotIndex mutable := self scanFor: key.
        (self isValidIndex: slotIndex) ifFalse: {
            self increaseCapacity.
            slotIndex := self scanFor: key.
        }.

        Stdn assert: (self isValidIndex: slotIndex).
        let isNewElement := storage_[slotIndex] isPresent not.
        isNewElement ifTrue: {
            ## FIXME: Make this first version working.
            #*storage_[slotIndex] := AssociationType newValue
                key: key;
                value: absentBlock();
                yourself.*#
            storage_[slotIndex] := AssociationType newValue.
            storage_[slotIndex] _
                key: key;
                value: absentBlock().

            size_ := size_ + 1.
            self checkFullCapacityCondition.
            slotIndex := self scanFor: key. ## In case the capacity changes.
        }.

        return: storage_[slotIndex] _ value
    }.

    const inline method at: (key: KeyType const ref)
        ifPresent: (presentBlock: ((ValueType ref) => Void) nativeBlockClosure)
        ifAbsent: (absentBlock: (Void => Void) nativeBlockClosure) ::=> Void := {

        let slotIndex mutable := self scanFor: key.
        (self isValidIndex: slotIndex) && (storage_[slotIndex] isPresent) ifTrue: {
            presentBlock(storage_[slotIndex] _ value)
        } ifFalse: {
            absentBlock()
        }
    }.

    inline method at: (key: KeyType const ref)
        ifPresent: (presentBlock: ((ValueType ref) => Void) nativeBlockClosure)
        ifAbsentPut: (absentBlock: (Void => ValueType) nativeBlockClosure) ::=> Void := {
        self at: key ifPresent: presentBlock ifAbsent: {:: Void |
            self at: key put: absentBlock()
        }
    }.

    method increaseCapacity => Void := {
        let newCapacity := storage_ size * 2u max: 16u.
        ## Create the new storage
        let newStorage mutable type: StorageType.
        newStorage resizeTo: newCapacity.

        ## Swap the storage with the old storage.
        storage_ swapWith: newStorage.
        let oldStorage ref := newStorage.

        ## Reinsert all of the present elements.
        oldStorage do: {:(StorageElementType ref) element :: Void |
            element isPresent ifTrue: {
                let slotIndex := self scanFor: element _ key.
                Stdn assert: (self isValidIndex: slotIndex).
                storage_[slotIndex] := element asMoveReference.
                Stdn stdout << "Reinsert old element " << element _ key; nl
            }
        }.
    }.

    method checkFullCapacityCondition => Void := {
        let capacity := storage_ capacity.
        let remainingCapacity := capacity - size_.
        let threshold := capacity / 4.
        remainingCapacity < threshold ifTrue: {
            self increaseCapacity
        }
    }.

    method keysDo: (aBlock: ((KeyType const ref) => Void) nativeBlockClosure) ::=> Void := {
        storage_ do: {:(StorageElementType ref)each :: Void |
            each isPresent ifTrue: {
                aBlock(each _ key)
            }
        }
    }.

    method valuesDo: (aBlock: ((ValueType ref) => Void) nativeBlockClosure) ::=> Void := {
        storage_ do: {:(StorageElementType ref)each :: Void |
            each isPresent ifTrue: {
                aBlock(each _ value)
            }
        }
    }.

    method removeAll => Void := {
        size_ := 0.
        storage_ do: {:(StorageElementType ref)each :: Void |
            each reset
        }
    }.
}.

}. ## End of namespace Collections
}. ## End of namespace Stdn
