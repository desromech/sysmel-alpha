namespace Smalltalk definition: {

BoxedFloat64 definition: {
	public field __float64Value type: Float64.
}.

namespace ObjectModel definition: {
compileTime if: UIntPointer instanceSize = 4 then: {
	compileTime constant SmallIntegerMinValue := #*(1<<31) negated*# -1073741824.
	compileTime constant SmallIntegerMaxValue := #*(1<<31)-1*# 1073741823.

	function encodeSmallInteger(v: IntPointer) => SmallInteger
		:= (v << 1) | 1 reinterpretCastTo: SmallInteger.

	function uint32ToCharacter(v: UInt32) => Character
		:= (v << 2) | 2 reinterpretCastTo: Character.

	function int32ToInteger(v: Int32) => Integer := {
		SmallIntegerMinValue <= v && v <= SmallIntegerMaxValue ifTrue: {
			return: encodeSmallInteger(v castTo: IntPointer)
		}.

		v < 0 ifTrue: {
			let largeNegativeInteger := LargeNegativeInteger basicNew: 4.
			let spilledValue mutable := v negated.
			Stdn memcpy(largeNegativeInteger __data[0] address, spilledValue address, 4).
			return: largeNegativeInteger
		} ifFalse: {
			let largePositiveInteger := LargePositiveInteger basicNew: 4.
			let spilledValue mutable := v.
			Stdn memcpy(largePositiveInteger __data[0] address, spilledValue address, 8).
			return: largePositiveInteger
		}.
	}.

	function uint32ToInteger(v: UInt32) => Integer := {
		v <= SmallIntegerMaxValue ifTrue: {
			return: encodeSmallInteger(v castTo: IntPointer)
		}.

		return: nil
	}.

	function float64ToFloat(v: Float64) => Float
		:= BoxedFloat64 basicNew
			__float64Value: v;
			yourself
} else: {
	compileTime constant SmallIntegerMinValue := #*(1<<60) negated*# -1152921504606846976.
	compileTime constant SmallIntegerMaxValue := #*(1<<60)-1*# 1152921504606846975.

	compileTime constant SmallFloatExponentOffset := 896.

	function encodeSmallInteger(v: IntPointer) => SmallInteger
		:= (v << 3) | 1 reinterpretCastTo: SmallInteger.

	function uint32ToCharacter(v: UInt32) => Character
		:= ((v castTo: UIntPointer) << 3) | 2 reinterpretCastTo: Character.

	function int32ToInteger(v: Int32) => Integer
		:= encodeSmallInteger(v).

	function uint32ToInteger(v: UInt32) => Integer
		:= encodeSmallInteger(v).

	function float64ToFloat(v: Float64) => Float := {
		let data := v reinterpretCastTo: UInt64.

		## FIXME: use a rotate left here.
		let bits mutable := (data << 1) | (data >> 63).
		let subtractedExponent := SmallFloatExponentOffset << 53 castTo: UInt64.

		## If this is a small float, then we should be able to perform this subtraction.
		bits < subtractedExponent ifTrue: {
			return: (BoxedFloat64 basicNew
				__float64Value: v;
				yourself)
		}.

		bits := bits - subtractedExponent.
		((bits << 3) | 4) reinterpretCastTo: Float
	}.
}.

function int64ToInteger(v: Int64) => Integer := {
	SmallIntegerMinValue <= v && v <= SmallIntegerMaxValue ifTrue: {
		return: encodeSmallInteger(v castTo: IntPointer)
	}.

	v < 0 ifTrue: {
		let largeNegativeInteger := LargeNegativeInteger basicNew: 8.
		let spilledValue mutable := v negated.
		Stdn memcpy(largeNegativeInteger __data[0] address, spilledValue address, 8).
		return: largeNegativeInteger
	} ifFalse: {
		let largePositiveInteger := LargePositiveInteger basicNew: 8.
		let spilledValue mutable := v.
		Stdn memcpy(largePositiveInteger __data[0] address, spilledValue address, 8).
		return: largePositiveInteger
	}.
}.

function uint64ToInteger(v: UInt64) => Integer := {
	v <= SmallIntegerMaxValue ifTrue: {
		return: encodeSmallInteger(v castTo: IntPointer)
	}.

	let largePositiveInteger := LargePositiveInteger basicNew: 8.
	let spilledValue mutable := v.
	Stdn memcpy(largePositiveInteger __data[0] address, spilledValue address, 8).
	return: largePositiveInteger
}.

function objectToUInt32(object: ProtoObject) => UInt32
	:= object asUInt32.

function objectToInt32(object: ProtoObject) => Int32
	:= object asInt32.

function objectToUInt64(object: ProtoObject) => UInt64
	:= object asUInt64.

function objectToInt64(object: ProtoObject) => Int64
	:= object asInt64.

function objectToChar32(object: ProtoObject) => Char32
	:= object asChar32.

function objectToFloat64(object: ProtoObject) => Float64
	:= object asFloat64.

Compiler compilationTarget managedObjectModel
    ## Primitive integer <-> Integer object.
	int32ToIntegerFunction: int32ToInteger;
	uint32ToIntegerFunction: uint32ToInteger;
	int64ToIntegerFunction: int64ToInteger;
	uint64ToIntegerFunction: uint64ToInteger;

	objectToUInt32Function: objectToUInt32;
	objectToInt32Function: objectToInt32;
	objectToUInt64Function: objectToUInt64;
	objectToInt64Function: objectToInt64;

    ## Primitive character <-> Integer object.
	uint32ToCharacterFunction: uint32ToCharacter;
	objectToChar32Function: objectToChar32;

    ## Primitive float <-> Float object.
	float64ToFloatFunction: float64ToFloat;
	objectToFloat64Function: objectToFloat64;
	yourself.
}.


ProtoObject extend: {
	method asInt32 => Int32 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asUInt32 => UInt32 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asInt64 => Int64 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asUInt64 => UInt64 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asFloat64 => Float64 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asChar32 => Char32 := {
		CannotPerformCastError new signal.
		return: 0
	}.

}.

Object extend: {
    method isNumber := false.
    method isInteger := false.
    method isFraction := false.
    method isFloat := false.
}.

Magnitude extend: {
	method < other
		:= self subclassResponsibility.

	method = other
		:= self subclassResponsibility.

	method <= other
		:= (other < self) not.

	method > other
		:= other < self.

	method >= other
		:= (self < other) not.

    method min: other
		:= self < other ifTrue: self ifFalse: other.

	method max: other
		:= self > other ifTrue: self ifFalse: other.

	method compareWith: anotherMagnitude ifLesser: lesserBlock ifEqual: equalBlock ifGreater: greaterBlock
		:= self < anotherMagnitude
			ifTrue: lesserBlock
			ifFalse: {
				self = anotherMagnitude
					ifTrue: equalBlock
					ifFalse: greaterBlock }.

	method beBetween: minValue and: maxValue
		:= minValue <= maxValue
			ifTrue: {(self min: maxValue) max: minValue}
			ifFalse: {(self min: minValue) max: maxValue}.

	method between: min and: max
		:= self >= min && self <= max.

	method min: maxValue max: minValue
		:= (self min: maxValue) max: minValue.
}.

}. ## End of namespace Smalltalk
