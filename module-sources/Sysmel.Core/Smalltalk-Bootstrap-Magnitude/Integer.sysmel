namespace Smalltalk definition: {

Integer extend: {
    meta definition: {
        method new: length neg: neg
            := neg
                ifTrue: { return: (LargeNegativeInteger new: length) }
                ifFalse: { return: (LargePositiveInteger new: length) }.
    }.

    method isInteger := true.
	method asInteger := self.
    method isLiteral := true.

    method asFraction
        := self.

	method floor := self.
	method ceiling := self.
	method truncated := self.
	method rounded := self.
	method fract := 0.
	method fractionPart := 0.
    method integerPart := self.

    method round: numberOfWishedDecimal
        := self.

    method bitInvert
        := -1 - self.

    method bitInvert32
        := self bitXor: 16rFFFFFFFF.

    method highBit
        := self subclassResponsibility.

    method highBitOfMagnitude
        := self subclassResponsibility.

    method lowBit
        := self subclassResponsibility.

    method timesRepeat: aBlock := {
        1 to: self do: {
            aBlock value
        }.
        self
    }.

    method byteAt: (index: UIntPointer)
        := self subclassResponsibility.

    method byteAt: (index: UIntPointer) put: (value: UInt8)
        := self subclassResponsibility.

    method bytesCount => UIntPointer := {
        self subclassResponsibility.
        0
    }.

    method replaceFrom: start to: stop with: replacement startingAt: repStart := {
        let j mutable := repStart castTo: UIntPointer.
        (start castTo: UIntPointer) to: (stop castTo: UIntPointer) do: {:i :: Void |
            self byteAt: i put: ((replacement byteAt: j) castTo: UInt8).
            j := j + 1u.
        }.

        self
    }.

    method * aNumber := {
        aNumber isInteger ifTrue: {
            return: (self digitMultiply: aNumber neg: self negative ~~ aNumber negative)
        }.

        aNumber adaptToInteger: self andSend: #*
    }.

    method + aNumber := {
        aNumber isInteger ifTrue: {
            self negative == aNumber negative
                ifTrue: {return: (self digitAdd: aNumber) normalize}
                ifFalse: {return: (self digitSubtract: aNumber)}
        }.
        aNumber isFraction ifTrue: {
            return: (Fraction numerator: self * aNumber denominator + aNumber numerator denominator: aNumber denominator)
        }.

        aNumber adaptToInteger: self andSend: #+
    }.

    method - aNumber := {
        aNumber isInteger ifTrue: {
            self negative == aNumber negative
                ifTrue: {return: (self digitSubtract: aNumber)}
                ifFalse: {return: (self digitAdd: aNumber) normalize}
        }.
        aNumber isFraction ifTrue: {
            return: (Fraction numerator: self * aNumber denominator - aNumber numerator denominator: aNumber denominator)
        }.

        aNumber adaptToInteger: self andSend: #-
    }.

    method / aNumber := {
        aNumber isInteger ifTrue: {
            let quoRem := self digitDiv: aNumber neg: self negative ~~ aNumber negative.
            (quoRem at: 2) = 0
                ifTrue: {return: (quoRem at: 1) normalize }
			    ifFalse: {return: (Fraction numerator: self denominator: aNumber) reduced }
        }.

        aNumber adaptToInteger: self andSend: #/
    }.

    method factorial := {
        self = 0 ifTrue: { return: 1}.
        self > 0 ifTrue: { return: self * (self - 1) factorial }.
        self error: "Not valid for negative integers"
    }
}.

}. ## End of namespace Smalltalk
