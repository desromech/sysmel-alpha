namespace Smalltalk definition: {

Number extend: {
    method isNumber := true.

	method floor := self asFloat floor.
	method ceiling := self asFloat ceiling.
	method truncated := self asFloat truncated.
	method rounded := self asFloat rounded.
	method fract := self asFloat fract.
	method fractionPart := self asFloat fractionPart.

	method abs := {
		self < 0
			ifTrue: {self negated}
			ifFalse: {self}
	}.

	method negative := self < 0.
    method positive := self >= 0.
    method isZero := self = 0.

	method sign := {
		self < 0 ifTrue: {return: -1}.
		self > 0 ifTrue: {return: 1}.
		return: 0
	}.

    method + aNumber
        := self subclassResponsibility.

    method - aNumber
        := self subclassResponsibility.

    method * aNumber
        := self subclassResponsibility.

    method / aNumber
        := self subclassResponsibility.

    method // aNumber
        := (self / aNumber) floor.

    method \\ aNumber
        := self - ((self // aNumber) * aNumber).

    method % aNumber
        := self \\ aNumber.

    method asInteger
        := self truncated.

    method to: stop
        := Interval from: self to: stop by: 1.

    method to: stop by: step
        := Interval from: self to: stop by: step.

    method to: stop by: step do: aBlock := {
        let nextValue mutable type: ProtoObject := self.
        step = 0 ifTrue: {self error: 'step must be non-zero'}.
        step < 0 ifTrue: {
            while: nextValue >= stop do: {
                aBlock value: nextValue.
                nextValue := nextValue + step
            }.
        } ifFalse: {
            while: nextValue <= stop do: {
                aBlock value: nextValue.
                nextValue := nextValue + step
            }.
        }.

        self
    }.

    method to: stop do: aBlock := {
        let nextValue mutable type: ProtoObject  := self.
        while: nextValue <= stop do: {
            aBlock value: nextValue.
            nextValue := nextValue + 1
        }.

        self
    }.

    method raisedTo: aNumber := {
    	aNumber isInteger ifTrue: {
            ## Do the special case of integer power"
            return: (self raisedToInteger: aNumber)
        }.

    	aNumber isFraction ifTrue: {
    		## Special case for fraction power
    		return: (self raisedToFraction: aNumber)
        }.

        self < 0 ifTrue: {
            return: (ArithmeticError signal: "Negative numbers can't be raised to float powers.")
        }.

        0 = aNumber ifTrue: {return: 1}.
        1 = aNumber ifTrue: {return: self}.
        0 = self ifTrue: {
            aNumber < 0 ifTrue: {
                return: {return: (ZeroDivide dividend: 1) signal}
            } ifFalse: {
                return: self
            }
        }.

        (aNumber * self ln) exp
    }.

    method ** aNumber
        := self raisedTo: aNumber.

    method even
        := (self \\ 2) = 0.

    method odd
        := (self \\ 2) = 1.

    method raisedToInteger: anInteger := {

        let result mutable type: ProtoObject := 1.
        let n mutable := anInteger >= 0 ifTrue: anInteger ifFalse: anInteger negated.
        let factor mutable type: ProtoObject := self.
        while: n > 0 do: {
            n even ifTrue: {
                factor := factor * factor.
                n := n / 2
            } ifFalse: {
                result := result * factor.
                n := n - 1
            }
        }.

        anInteger < 0 ifTrue: {
            result := result reciprocal
        }.

        result
    }.

    method quo: aNumber
        := (self / aNumber) truncated.

    method reciprocal
        := 1 / self.
}.

Stdn BasicValuePrinter extend: {
    method printOn: (aStream: __global Smalltalk ProtoObject) ::=> Void := {
        0 until: bufferSize do: {:(UIntPointer)i :: Void |
            aStream nextPut: buffer[i]
        }
    }.
}.

}. ## End of namespace Smalltalk
