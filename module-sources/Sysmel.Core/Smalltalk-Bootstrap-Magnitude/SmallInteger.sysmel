namespace Smalltalk definition: {

SmallInteger extend: {
	meta definition: {
		method basicNew
			:= self error: "SmallIntegers can only be created by performing arithmetic".

		method new
			:= self basicNew.

		method maxVal
			:= ObjectModel SmallIntegerMaxValue.

		method minVal
			:= ObjectModel SmallIntegerMaxValue.
	}.

	method asInt32 => Int32
		:= self __decodeSmallInteger castTo: Int32.

	method asUInt32 => UInt32
		:= self __decodeSmallInteger castTo: UInt32.

	method asInt64 => Int64
		:= self __decodeSmallInteger castTo: Int64.

	method asUInt64 => UInt64
		:= self __decodeSmallInteger castTo: UInt64.

	method asFloat64 => Float64
		:= self __decodeSmallInteger castTo: Float64.

	method asChar32 => Char32
		:= self __decodeSmallInteger castTo: Char32.

	method asCharacter
		:= self __decodeSmallInteger castTo: Char32.

	method asFloat
		:= self __decodeSmallInteger castTo: Float64.

	method negated
		:= self __decodeSmallInteger negated.

	method isLarge
		:= false.

	method sqrt := {
		let selfValue := self __decodeSmallInteger.
		selfValue <= 0 ifTrue: {
			selfValue < 0 ifTrue: {
				return: (DomainError signal: "sqrt is undefined for negative numbers.")
			} ifFalse: {
				return: 0
			}
		}.

		(selfValue castTo: Float64) sqrt floor castTo: IntPointer.
	}.

	method = aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a = b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a = b
		}.

        super = aNumber
    }.

	method ~= aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a ~= b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a ~= b
		}.

        super ~= aNumber
    }.

	method < aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a < b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a < b
		}.

        super < aNumber
    }.

	method <= aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a <= b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a <= b
		}.

        super <= aNumber
    }.

	method > aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a > b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a > b
		}.

        super > aNumber
    }.

	method >= aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a >= b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a >= b
		}.

        super >= aNumber
    }.

	method <=> aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a <=> b
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a <=> b
		}.

		super <=> aNumber
	}.

	method bitAnd: aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: (a bitAnd: b)
		}.

        super bitAnd: aNumber
    }.

	method & aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: (a & b)
		}.

        super & aNumber
    }.

	method bitOr: aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: (a bitOr: b)
		}.

        super bitOr: aNumber
    }.

	method | aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: (a bitOr: b)
		}.

        super | aNumber
    }.

	method bitXor: aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: (a bitXor: b)
		}.

		super bitXor: aNumber
	}.

	method ^ aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: (a ^ b)
		}.

		super ^ aNumber
	}.

	method bitShift: aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			b >= 0 ifTrue: {
				## FIXME: Support the case with overflow.
				return: a << b
			} ifFalse: {
				return: a >> b negated
			}
		}.

        super bitAnd: aNumber
    }.

	method << aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			## FIXME: Support the case with overflow.
			return: a << b
		}.

        super << aNumber
    }.

	method >> aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a >> b
		}.

		super >> aNumber
	}.

	method bitInvert32 := {
		self __decodeSmallInteger ^ 16rFFFFFFFF
    }.

    method + aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a + b
		}.

		aNumber __isCharacter ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeCharacter.
			return: (a + b castTo: Char32)
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a + b
		}.

        super + aNumber
    }.

    method - aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a - b
		}.

		aNumber __isCharacter ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeCharacter.
			return: (a - b castTo: Char32)
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a - b
		}.

        super - aNumber
    }.

	method * aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			b == 0 || a <= (IntPointer maxValue / b) ifTrue: {
				return: a * b
			}.
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			return: a * b
		}.

		super * aNumber
	}.

	method / aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			b = 0 ifTrue: {
				(ZeroDivide dividend: aNumber) signal
			}.

			(a % b) = 0 ifTrue: {
				return: a / b
			} ifFalse: {
				return: (Fraction numerator: a denominator: b)
			}.
		}.

		aNumber __isSmallOrBoxedFloat ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallOrBoxedFloat.
			b = 0 ifTrue: {
				(ZeroDivide dividend: aNumber) signal
			}.

			return: a / b
		}.

		super / aNumber
	}.

	method % aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			b = 0 ifTrue: {
				(ZeroDivide dividend: aNumber) signal
			}.

			return: a % b
		}.

		super % aNumber
	}.

	method \\ aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			b = 0 ifTrue: {
				(ZeroDivide dividend: aNumber) signal
			}.

			return: a \\ b
		}.

		super \\ aNumber
	}.

	method // aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			b = 0 ifTrue: {
				(ZeroDivide dividend: aNumber) signal
			}.

			return: a // b
		}.

		super // aNumber
	}.

	method printOn: aStream := {
        let integerPrinter mutable type: Stdn BasicValueIntegerPrinter.
        integerPrinter nextPutInteger: self __decodeSmallInteger.
        integerPrinter printOn: aStream.

        self
    }.

    method printOnNativeTextStreamWriter: (writer: Stdn IO TextStreamWriter ref) := {
        writer << self __decodeSmallInteger.
		self
    }.

	method byteAt: (index: UIntPointer) := {
		let s := self __decodeSmallInteger.
		((s < 0
			ifTrue: { s negated castTo: UIntPointer }
			ifFalse: { s castTo: UIntPointer }) >> ((index - 1u) * 8u)) & 16rFFu
	}.

	method byteAt: (index: UIntPointer) put: (value: UInt8)
		:= self error: "You can't store in a SmallInteger".

	method bytesCount => UIntPointer := {
		let s mutable := self __decodeSmallInteger.
		s < 0 ifTrue: {s := s negated}.
		((s castTo: UIntPointer) highBit + 7u) / 8u max: 1u
	}.
}.

}. ## End of namespace Smalltalk
