namespace Stdn definition: {
namespace IO definition: {

#**
 * Text stream reader
 *#
class TextStreamReader definition: {
    compileTime constant AtomicTokenBufferCapacity := 256.

    public field stream type: Stream pointer.
    field characterBuffer type: Int32.

    meta method for: (stream: Stream pointer) ::=> SelfType
        := SelfType newValue
            stream: stream;
            yourself.

    method initialize => Void := {
        characterBuffer := -1
    }.

    method peekChar8 => Int32 := {
        characterBuffer < 0 ifTrue: {
            let fetchedCharacter mutable type: Char8.
            (stream _ read: fetchedCharacter address size: 1) = 1 ifTrue: {
                characterBuffer := fetchedCharacter
            }.
        }.

        characterBuffer
    }.

    method nextChar8 => Int32 := {
        let result := self peekChar8.
        characterBuffer := -1.
        result.
    }.

    method skipWhite => Void := {
        while: (self isWhite: self peekChar8) do: {
            self nextChar8
        }
    }.

    const inline method isWhite: (c: Int32) ::=> Boolean8
        := 0 <= c && c <= ' '.

    method nextTokenInto: (tokenBuffer: Char8 pointer) maxCapacity: (maxTokenSize: UIntPointer)  ::=> UIntPointer := {
        self skipWhite.
        0 until: maxTokenSize - 1 do: {:(UIntPointer)i ::  Void|
            let c := self peekChar8.
            c >= 0 && (self isWhite: c) not ifTrue: {
                tokenBuffer[i] := c castTo: Char8.
                self nextChar8
            } ifFalse: {
                tokenBuffer[i] := 0.
                return: i
            }
        }.

        tokenBuffer[maxTokenSize] := 0.
        maxTokenSize
    }.

    method nextInt64 => Int64 := {
        let tokenBuffer mutable type: (Char8 array: AtomicTokenBufferCapacity).
        let tokenSize := self nextTokenInto: tokenBuffer[0] address maxCapacity: AtomicTokenBufferCapacity.

        Stdn parseInt64(tokenBuffer[0] address, tokenSize)
    }.

    method nextUInt64 => UInt64 := {
        let tokenBuffer mutable type: (Char8 array: AtomicTokenBufferCapacity).
        let tokenSize := self nextTokenInto: tokenBuffer[0] address maxCapacity: AtomicTokenBufferCapacity.

        Stdn parseUInt64(tokenBuffer[0] address, tokenSize)
    }.

    method nextFloat64 => Float64 := {
        let tokenBuffer mutable type: (Char8 array: AtomicTokenBufferCapacity).
        let tokenSize := self nextTokenInto: tokenBuffer[0] address maxCapacity: AtomicTokenBufferCapacity.

         ## Parse the null terminator as part of the string, so that we can just use libc for this. 
        Stdn parseFloat64(tokenBuffer[0] address, tokenSize + 1)
    }.

}.

}. ## End of namespace IO
}. ## End of namespace Stdn
