namespace Stdn definition: {

struct _NativeStackBlockClosureHeader definition: {
    public field vtable type: Stdn Reflection TypeInformation pointer pointer.
    public field functionPointer type: (Void => Void) pointer.
    public field captures type: Void pointer array.

    inline method typeInfo => Stdn Reflection TypeInformation pointer
        := vtable[-1].
}.

template Function(FT: Type)
	:= struct definition: {
    compileTime constant FunctionType := FT.
    compileTime constant ArgumentTypesTuple := FunctionType argumentTypesTuple.
    compileTime constant ReturnType := FunctionType returnType.

    compileTime constant NativeStackBlockClosureType := FT nativeStackBlockClosure.
    compileTime constant InlineStorageType := Void pointer array: 4.

    enum WrapperType valueType: UInt8; values: #{
        Invalid: 0.
        FunctionPointer: 1.
        InlineNativeClosure: 2.
        HeapNativeClosure: 3.
        GCClosure: 4
    }.

    ## Inline storage for typical closures.
    field type type: WrapperType.
    field inlineStorage type: InlineStorageType.

    method initializeCopyingFrom: (other: SelfType const ref) ::=> Void := {
        self := other.
    }.

    method initializeMovingFrom: (other: SelfType tempRef) ::=> Void := {
        self := other.
    }.

    (method := (blockClosure: NativeStackBlockClosureType)) => SelfType ref := {
        self finalize.

        let blockClosureHeader := blockClosure reinterpretCastTo: _NativeStackBlockClosureHeader pointer.
        let typeInfo := blockClosureHeader _ typeInfo.
        let instanceSize := typeInfo _ instanceDataSize.
        let instanceAlignment := typeInfo _ instanceDataAlignment.
        let storagePointer mutable type: Void pointer := inlineStorage [0] address.

        instanceSize <= InlineStorageType instanceSize && instanceAlignment <= InlineStorageType instanceAlignment ifTrue: {
            type := WrapperType InlineNativeClosure.
        } ifFalse: {
            type := WrapperType HeapNativeClosure.
            storagePointer := Stdn malloc(instanceSize).
            inlineStorage[0] := storagePointer.
        }.

        typeInfo _ copyConstructorFunctionPointer ifNil: {
            Stdn memcpy(storagePointer, blockClosureHeader, instanceSize)
        } ifNotNil: {
            typeInfo _ copyConstructorFunctionPointer(storagePointer, blockClosureHeader)
        }.

        self
    }.

    compileTime if: Compiler hasRuntimeTypeInformation && Compiler hasGarbageCollectionSupport then: {
        compileTime constant GCBlockClosureType := FT gcBlockClosure.

        (method := (blockClosure: GCBlockClosureType)) => SelfType ref := {
            self finalize.

            type := WrapperType GCClosure.
            (inlineStorage [0] address reinterpretCastTo: GCBlockClosureType pointer) _ := blockClosure.

            self
        }.

    }.

    method finalize => Void := {
        type selectCase: #{
        WrapperType InlineNativeClosure : {
            let closure := inlineStorage[0] address reinterpretCastTo: _NativeStackBlockClosureHeader pointer.
            let finalizerMethod := closure _ typeInfo _ finalizeFunctionPointer.
            finalizerMethod ifNotNil: {
                finalizerMethod(closure)
            }.
        }.

        WrapperType HeapNativeClosure : {
            let closure := inlineStorage[0] reinterpretCastTo: _NativeStackBlockClosureHeader pointer.
            let finalizerMethod := closure _ typeInfo _ finalizeFunctionPointer.
            finalizerMethod ifNotNil: {
                finalizerMethod(closure)
            }.

            free(closure)
        }.

        WrapperType GCClosure : {
            compileTime if: Compiler hasRuntimeTypeInformation && Compiler hasGarbageCollectionSupport then: {
                inlineStorage [0] := nil.
            }.
        }.
        _ : {}
        }.

        type := WrapperType Invalid.
    }.

    (method := (functionPointer: FunctionType pointer)) ::=> SelfType ref := {
        self finalize.

        type := WrapperType FunctionPointer.
        inlineStorage[0] := functionPointer.
        self
    }.

    (method := (other: SelfType const ref)) ::=> SelfType ref := {
        self address ~~ other address ifTrue: {
            other __private type selectCase: #{
            WrapperType InlineNativeClosure : {
                let closure := other __private inlineStorage[0] address reinterpretCastTo: NativeStackBlockClosureType.
                self := closure.
                void.
            }.

            WrapperType HeapNativeClosure : {
                let closure := other __private inlineStorage[0] reinterpretCastTo: NativeStackBlockClosureType.
                self := closure.
                void.
            }.
            _ : {
                error: "Unsupported function wrapper type for copy assignment."
            }
            }.
        }.

        self
    }.

    inline method applyWithArguments: (arguments: ArgumentTypesTuple) ::=> ReturnType := {
        type selectCase: #{
        WrapperType FunctionPointer : {
            let fp := inlineStorage[0] reinterpretCastTo: FunctionType pointer.
            return: (fp applyWithArguments: arguments).
        }.

        WrapperType InlineNativeClosure : {
            let closure := inlineStorage[0] address reinterpretCastTo: NativeStackBlockClosureType.
            let blockClosureHeader := closure reinterpretCastTo: _NativeStackBlockClosureHeader pointer.

            return: (closure applyWithArguments: arguments).
        }.

        WrapperType HeapNativeClosure : {
            let closure := inlineStorage[0] reinterpretCastTo: NativeStackBlockClosureType.
            return: (closure applyWithArguments: arguments).
        }.

        WrapperType GCClosure : {
            compileTime if: Compiler hasRuntimeTypeInformation && Compiler hasGarbageCollectionSupport then: {
                let closure := inlineStorage[0] reinterpretCastTo: GCBlockClosureType.
                return: (closure applyWithArguments: arguments).
            }
            else: {
                error: "Trying to call invalid Stdn Function wrapper."
            }
        }.

        _ : {
            error: "Trying to call invalid Stdn Function wrapper."
        }
        }.
    }.
}.

}. ## End of namespace Stdn
