namespace Stdn definition: {
namespace Graphics definition: {
namespace DriverAGPU definition: {

useNamespace: Stdn Graphics Core.

#**
 * I am a agpu based device.
 *#
sealed class AgpuRenderingDevice superclass: RenderingDevice; definition: {
    public field handle type: AGPU DeviceRef.

    private field defaultCommandQueue type: CommandQueuePtr.
    private field defaultShaderSignatureCache type: ShaderSignatureCachePtr.
    private field defaultVertexLayoutCache type: VertexLayoutCachePtr.
    private field defaultShaderCache type: ShaderCachePtr.
    private field defaultPipelineStateCache type: PipelineStateCachePtr.
    private field defaultFontCache type: RenderingDeviceFontCachePtr.

    private field nonCoherentAtomSize type: UIntPointer.
    private field minMemoryMapAlignment type: UIntPointer.
    private field minTexelBufferOffsetAlignment type: UIntPointer.
    private field minUniformBufferOffsetAlignment type: UIntPointer.
    private field minStorageBufferOffsetAlignment type: UIntPointer.

    method initializeWithHandle: (theHandle: AGPU DeviceRef const ref) ::=> Void := {
        handle := theHandle.

        nonCoherentAtomSize := (handle _ getLimitValue: AGPU Limit NonCoherentAtomSize) castTo: UIntPointer.
        minMemoryMapAlignment := (handle _ getLimitValue: AGPU Limit MinMemoryMapAlignment) castTo: UIntPointer.
        minTexelBufferOffsetAlignment := (handle _ getLimitValue: AGPU Limit MinTexelBufferOffsetAlignment) castTo: UIntPointer.
        minUniformBufferOffsetAlignment := (handle _ getLimitValue: AGPU Limit MinUniformBufferOffsetAlignment) castTo: UIntPointer.
        minStorageBufferOffsetAlignment := (handle _ getLimitValue: AGPU Limit MinStorageBufferOffsetAlignment) castTo: UIntPointer.

        {
            let defaultCommandQueueHandle := handle _ getDefaultCommandQueue.
            let wrapper := AgpuCommandQueue sharedNew.
            wrapper _ handle: defaultCommandQueueHandle.
            defaultCommandQueue := wrapper upCastFor: CommandQueue.
        }.

        defaultShaderSignatureCache := self createShaderSignatureCache.
        defaultVertexLayoutCache := self createVertexLayoutCache.
        defaultShaderCache := self createShaderCache.
        defaultPipelineStateCache := self createPipelineStateCache.
        defaultFontCache := self createFontCache.
    }.

    override method createShaderSignatureBuilder ::=> ShaderSignatureBuilderPtr := {
        let builderHandle := handle _ createShaderSignatureBuilder.
        builderHandle ifNil: {
            return: ShaderSignatureBuilderPtr nil.
        }.

        let result := AgpuShaderSignatureBuilder sharedNew.
        result _ handle := builderHandle.
        result upCastFor: ShaderSignatureBuilder
    }.

    override method createBuffer: (description: BufferDescription const ref) initialData: (initialData: Void const pointer) ::=> BufferPtr := {
        let convertedDescription mutable := AGPU BufferDescription()
            size: (description size castTo: UInt32);
            heap_type: (description heapType castTo: AGPU MemoryHeapType);
            usage_modes: (description usageModes castTo: AGPU BufferUsageMask);
            main_usage_mode: (description mainUsageMode castTo: AGPU BufferUsageMask);
            mapping_flags: (description mappingFlags castTo: UInt32);
            stride: (description stride castTo: UInt32);
            yourself.
        let bufferHandle := handle _ createBuffer: convertedDescription address initialData: (initialData reinterpretCastTo: Void pointer).
        bufferHandle ifNil: {
            return: BufferPtr nil.
        }.

        let result := AgpuBuffer sharedNew.
        result _
            handle: bufferHandle;
            creationDescription: description.
        result upCastFor: Buffer
    }.

    override method createTexture: (description: TextureDescription const ref) ::=> TexturePtr := {
        let convertedDescription mutable := AGPU TextureDescription()
            type: (description type castTo: AGPU TextureType);
            width: (description width castTo: UInt32);
            height: (description height castTo: UInt32);
            depth: (description depth castTo: UInt32);
            layers: (description layers castTo: UInt32);
            miplevels: (description miplevels castTo: UInt16);
            format: (description format castTo: AGPU TextureFormat);
            heap_type: (description heapType castTo: AGPU MemoryHeapType);
            usage_modes: (description usageModes castTo: AGPU TextureUsageModeMask);
            main_usage_mode: (description mainUsageMode castTo: AGPU TextureUsageModeMask);
            sample_count: (description sampleCount castTo: UInt32);
            sample_quality: (description sampleQuality castTo: UInt32);
            yourself.

        let textureHandle := handle _ createTexture: convertedDescription address.
        textureHandle ifNil: {
            return: TexturePtr nil.
        }.

        let result := AgpuTexture sharedNew.
        result _
            handle: textureHandle;
            creationDescription: description.
        result upCastFor: Texture
    }.

    override method createColorTextureWithData: (textureData: TextureData const ref) ::=> TexturePtr := {
        let bytesPerPixel := textureData format bytesPerPixel.
        bytesPerPixel = 3 || bytesPerPixel = 6 ifTrue: {
            let expandedTexture := textureData asTextureDataWithExpandedUnalignedRGBFormats.
            expandedTexture ifNil: {return: TexturePtr nil}.
            return: (super createColorTextureWithData: expandedTexture _)
        }.

        super createColorTextureWithData: textureData
    }.

    override method createTextureWithData: (textureData: TextureData const ref) ::=> TexturePtr := {
        let bytesPerPixel := textureData format bytesPerPixel.
        bytesPerPixel = 3 || bytesPerPixel = 6 ifTrue: {
            let expandedTexture := textureData asTextureDataWithExpandedUnalignedRGBFormats.
            expandedTexture ifNil: {return: TexturePtr nil}.
            return: (super createTextureWithData: expandedTexture _)
        }.

        super createTextureWithData: textureData
    }.

    override method createSampler: (description: SamplerDescription const ref) ::=> SamplerPtr := {
        let convertedDescription mutable := AGPU SamplerDescription()
            filter: (description filter castTo: AGPU Filter);
            address_u: (description addressU castTo: AGPU TextureAddressMode);
            address_v: (description addressV castTo: AGPU TextureAddressMode);
            address_w: (description addressW castTo: AGPU TextureAddressMode);
            mip_lod_bias: description mipLodBias;
            maxanisotropy: description maxAnisotropy;
            comparison_enabled: (description comparisonEnabled asBit);
            comparison_function: (description comparisonFunction castTo: AGPU CompareFunction);
            border_color: (AGPU Color4f()
                r: description borderColor r;
                g: description borderColor g;
                b: description borderColor b;
                a: description borderColor a;
                yourself);
            min_lod: description minLod;
            max_lod: description maxLod;
            yourself.

        let samplerHandle := handle _ createSampler: convertedDescription address.
        samplerHandle ifNil: {
            return: SamplerPtr nil.
        }.

        let result := AgpuSampler sharedNew.
        result _
            handle: samplerHandle.
        result upCastFor: Sampler
    }.

    override method createComputePipelineState: (description: ComputePipelineStateDescription const ref) ::=> PipelineStatePtr := {
        let builder := handle _ createComputePipelineBuilder.
        builder ifNil: {
            return: PipelineStatePtr nil.
        }.

        (description shaderSignature getPointer castTo: AgpuShaderSignature pointer) ifNotNil: {:shaderSignature :: Void |
            builder _ setShaderSignature: shaderSignature _ handle
        }.

        (description computeShader getPointer castTo: AgpuShaderStageHandle pointer) ifNotNil: {:shader :: Void |
            shader _ attachTo: builder
        }.

        let pso := builder _ build.
        pso ifNil: {
            return: PipelineStatePtr nil.
        }.

        let result := AgpuComputePipelineState sharedNew.
        result _ handle: pso.
        result upCastFor: PipelineState
    }.

    override method createGraphicsPipelineState: (description: GraphicsPipelineStateDescription const ref) ::=> PipelineStatePtr := {
        let builder := handle _ createPipelineBuilder.
        builder ifNil: {
            return: PipelineStatePtr nil.
        }.

        (description shaderSignature getPointer castTo: AgpuShaderSignature pointer) ifNotNil: {:shaderSignature :: Void |
            builder _ setShaderSignature: shaderSignature _ handle
        }.

        (description vertexLayout getPointer castTo: AgpuVertexLayout pointer) ifNotNil: {:vertexLayout :: Void |
            builder _ setVertexLayout: vertexLayout _ handle
        }.

        (description vertexShader getPointer castTo: AgpuShaderStageHandle pointer) ifNotNil: {:shader :: Void |
            shader _ attachTo: builder
        }.
        (description fragmentShader getPointer castTo: AgpuShaderStageHandle pointer) ifNotNil: {:shader :: Void |
            shader _ attachTo: builder
        }.
        (description geometryShader getPointer castTo: AgpuShaderStageHandle pointer) ifNotNil: {:shader :: Void |
            shader _ attachTo: builder
        }.
        (description tessellationControlShader getPointer castTo: AgpuShaderStageHandle pointer) ifNotNil: {:shader :: Void |
            shader _ attachTo: builder
        }.
        (description tessellationEvaluationShader getPointer castTo: AgpuShaderStageHandle pointer) ifNotNil: {:shader :: Void |
            shader _ attachTo: builder
        }.

        builder _ setRenderTargetCount: (description colorAttachments size castTo: Int32).
        description colorAttachments doWithIndex: {:attachment :index :: Void |
            let attachmentMask := (1<<index) castTo: Int32.
            let blendingEquation ref := attachment blendingEquation.
            builder _
                setRenderTargetFormat: (index castTo: UInt32) format: (attachment format castTo: AGPU TextureFormat);
                setBlendState: attachmentMask enabled: attachment blendingEnabled asBit;
                setColorMask: attachmentMask redEnabled: attachment colorMask r asBit greenEnabled: attachment colorMask g asBit blueEnabled: attachment colorMask b asBit alphaEnabled: attachment colorMask a asBit.

            attachment blendingEnabled ifTrue: {
                builder _
                    setBlendFunction: attachmentMask
                    sourceFactor: (blendingEquation sourceColorFactor castTo: AGPU BlendingFactor) destFactor: (blendingEquation destColorFactor castTo: AGPU BlendingFactor) colorOperation: (blendingEquation colorOperation castTo: AGPU BlendingOperation)
                    sourceAlphaFactor: (blendingEquation sourceAlphaFactor castTo: AGPU BlendingFactor) destAlphaFactor: (blendingEquation destAlphaFactor castTo: AGPU BlendingFactor) alphaOperation: (blendingEquation alphaOperation castTo: AGPU BlendingOperation)
            }.
        }.

        builder _
            setDepthStencilFormat: (description depthStencilFormat castTo: AGPU TextureFormat);
            setDepthState: description depthTestingEnabled asBit writeMask: description depthWriteMask asBit function: (description depthFunction castTo: AGPU CompareFunction);
            setDepthBias: description depthBiasConstantFactor clamp: description depthBiasClamp slopeFactor: description depthBiasSlopeFactor;

            setStencilState: (description stencilTestingEnabled asBit) writeMask: (description stencilWriteMask) readMask: (description stencilReadMask);
            setStencilFrontFace: (description stencilFrontFaceState stencilFailOperation castTo: AGPU StencilOperation) depthFailOperation: (description stencilFrontFaceState depthFailOperation castTo: AGPU StencilOperation) stencilDepthPassOperation: (description stencilFrontFaceState depthPassOperation castTo: AGPU StencilOperation) stencilFunction: (description stencilFrontFaceState compareFunction castTo: AGPU CompareFunction);
            setStencilBackFace: (description stencilBackFaceState stencilFailOperation castTo: AGPU StencilOperation) depthFailOperation: (description stencilBackFaceState depthFailOperation castTo: AGPU StencilOperation) stencilDepthPassOperation: (description stencilBackFaceState depthPassOperation castTo: AGPU StencilOperation) stencilFunction: (description stencilBackFaceState compareFunction castTo: AGPU CompareFunction);

            setSampleDescription: description sampleCount sampleQuality: description sampleQuality;

            setFrontFace: (description frontFaceOrientation castTo: AGPU FaceWinding);
            setCullMode: (description faceCullingMode castTo: AGPU CullMode);
            setPolygonMode: (description polygonMode castTo: AGPU PolygonMode);
            setPrimitiveType: (description primitiveTopology castTo: AGPU PrimitiveTopology).

        let pso := builder _ build.
        pso ifNil: {
            return: PipelineStatePtr nil.
        }.

        let result := AgpuGraphicsPipelineState sharedNew.
        result _ handle: pso.
        result upCastFor: PipelineState
    }.

    override method createVertexLayout => VertexLayoutPtr := {
        let vertexLayoutHandle := handle _ createVertexLayout.
        vertexLayoutHandle ifNil: {
            return: VertexLayoutPtr nil.
        }.

        let result := AgpuVertexLayout sharedNew.
        result _
            handle: vertexLayoutHandle.
        result upCastFor: VertexLayout
    }.

    override method createVertexBindingFor: (layout: VertexLayout sharedPointer const ref) ::=> VertexBindingPtr := {
        let agpuVertexLayout := layout getPointer castTo: AgpuVertexLayout pointer.
        agpuVertexLayout ifNil: {
            return: VertexBindingPtr nil.
        }.

        let bindingHandle := handle _ createVertexBinding: agpuVertexLayout _ handle.
        bindingHandle ifNil: {
            return: VertexBindingPtr nil.
        }.

        let result := AgpuVertexBinding sharedNew.
        result _
            handle: bindingHandle;
            vertexLayout: layout.
        result upCastFor: VertexBinding
    }.

    override method createCommandAllocatorOfType: (type: CommandListType) for: (queue: CommandQueuePtr const ref) ::=> CommandListAllocatorPtr := {
        let agpuCommandQueue := queue getPointer castTo: AgpuCommandQueue pointer.
        agpuCommandQueue ifNil: {
            return: CommandListAllocatorPtr nil
        }.

        let allocatorHandle := handle _ createCommandAllocator: (type castTo: AGPU CommandListType) queue: agpuCommandQueue _ handle.
        allocatorHandle ifNil: {
            return: CommandListAllocatorPtr nil
        }.

        let result := AgpuCommandListAllocator sharedNew.
        result _ handle: allocatorHandle.
        result upCastFor: CommandListAllocator
    }.

    override method createCommandListOfType: (type: CommandListType) for: (allocator: CommandListAllocatorPtr const ref) initialPipelineState: (initialPipeline: PipelineStatePtr const ref) ::=> CommandListPtr := {
        let agpuAllocator := allocator getPointer castTo: AgpuCommandListAllocator pointer.
        agpuAllocator ifNil: {
            return: CommandListPtr nil
        }.

        let agpuInitialPipeline mutable := AGPU PipelineStateRef().
        initialPipeline ifNotNil: {
            initialPipeline _ isGraphicsPipelineState ifTrue: {
                agpuInitialPipeline := (initialPipeline getPointer castTo: AgpuGraphicsPipelineState pointer) _ handle
            }.

            initialPipeline _ isComputePipelineState ifTrue: {
                agpuInitialPipeline := (initialPipeline getPointer castTo: AgpuGraphicsPipelineState pointer) _ handle
            }.
        }.

        let commandListHandle := handle _ createCommandList: (type castTo: AGPU CommandListType) allocator: agpuAllocator _ handle initialPipelineState: agpuInitialPipeline.
        commandListHandle ifNil: {
            return: CommandListPtr nil
        }.

        let result := AgpuCommandList sharedNew.
        result _ handle: commandListHandle.
        result upCastFor: CommandList
    }.

    override method createDeferredStateTrackerOfType: (type: CommandListType) for: (allocator: CommandListAllocatorPtr const ref) ::=> StateTrackerPtr := {
        let commandList := self createCommandListOfType: type for: allocator.
        commandList ifNil: {
            return: StateTrackerPtr nil.
        }.

        let result := GenericStateTracker sharedNew.
        result _
            commandList: commandList;
            shaderCache: self getDefaultShaderCache;
            pipelineStateCache: self getDefaultPipelineStateCache.

        result upCastFor: StateTracker
    }.

    override method getDefaultCommandQueue => CommandQueuePtr const ref
        := defaultCommandQueue.

    override method createShaderLibraryFromSource: (shaderModuleSource: Char8 const arraySlice) shaderLanguage: (shaderLanguage: ShaderSourceLanguage) stageType: (stageType: ShaderStageType) ::=> ShaderLibraryHandlePtr
        := ShaderLibraryHandlePtr nil.

    override method createShaderLibraryFromBlob: (shaderModuleBlob: UInt8 const arraySlice) ::=> ShaderLibraryHandlePtr := {
        let shaderHandle := handle _ createShader: AGPU ShaderType Library.
        shaderHandle ifNil: {
            return: ShaderLibraryHandlePtr nil
        }.

        shaderHandle _
            setShaderSource: AGPU ShaderLanguage SpirV sourceText: (shaderModuleBlob elements reinterpretCastTo: Char8 const pointer)
                sourceTextLength: (shaderModuleBlob size castTo: UInt32);
                compileShader: "".

        let result := AgpuShaderLibraryHandle sharedNew.
        result _ handle: shaderHandle.
        result upCastFor: ShaderLibraryHandle
    }.

    override method createShaderStageFromSource: (shaderStageSource: Char8 const arraySlice) shaderLanguage: (shaderLanguage: ShaderSourceLanguage) stageType: (stageType: ShaderStageType) ::=> ShaderStageHandlePtr
        := ShaderStageHandlePtr nil. ## TODO: implement myself.

    override method createShaderStageFromBlob: (shaderStageBlob: UInt8 const arraySlice) stageType: (stageType: ShaderStageType) ::=> ShaderStageHandlePtr
        := ShaderStageHandlePtr nil. ## TODO: implement myself.

    override method createShaderStageFromEntryPoint: (entryPointInfo: GPU ShaderEntryPointInfo const ref) ::=> ShaderStageHandlePtr := {
        entryPointInfo moduleInfo ifNil: {
            return: ShaderStageHandlePtr nil
        }.

        let shaderLibrary := self createShaderLibraryFromModule: entryPointInfo moduleInfo _.
        shaderLibrary ifNil: {
            return: ShaderStageHandlePtr nil
        }.

        shaderLibrary _ createHandleForEntryPoint: entryPointInfo.
    }.

    override method createFramebuffer: (extent: UInt32x2) colorViews: (colorViews: TextureViewPtr const arraySlice) depthStencilView: (depthStencilView: TextureViewPtr const ref) ::=> FramebufferPtr := {
        let convertedColorViews mutable type: Stdn Collections Vector(AGPU TextureViewRef).
        convertedColorViews reserve: colorViews size.
        colorViews do: {:each :: Void |
            let agpuView := each getPointer castTo: AgpuTextureView const pointer.
            agpuView ifNil: {
                convertedColorViews add: AGPU TextureViewRef()
            } ifNotNil: {
                convertedColorViews add: agpuView _ handle
            }
        }.

        let convertedDepthStencilView mutable type: AGPU TextureViewRef.
        depthStencilView ifNotNil: {
            let agpuView := depthStencilView getPointer castTo: AgpuTextureView const pointer.
            agpuView ifNotNil: {
                convertedDepthStencilView := agpuView _ handle
            }
        }.

        let framebufferHandle := handle _ createFrameBuffer: extent x height: extent y
            colorCount: (convertedColorViews size castTo: UInt32) colorViews: convertedColorViews data
            depthStencilView: convertedDepthStencilView.
        framebufferHandle ifNil: {
            return: FramebufferPtr nil
        }.

        let result := AgpuFramebuffer sharedNew.
        result _ handle: framebufferHandle.
        result upCastFor: Framebuffer
    }.

    override method createRenderPass: (colorAttachments: RenderPassColorAttachmentDescription const arraySlice) depthStencilAttachment: (depthAttachment: RenderPassDepthStencilAttachmentDescription const pointer) ::=> RenderPassPtr := {
        let convertedColorAttachments mutable type: Stdn Collections Vector(AGPU RenderpassColorAttachmentDescription).
        convertedColorAttachments reserve: colorAttachments size.
        let sampleCount mutable type: UInt32 := 1.
        let sampleQuality mutable type: UInt32 := 0.
        colorAttachments do: {:each :: Void |
            sampleCount := each sampleCount.
            sampleQuality := each sampleQuality.

            convertedColorAttachments add: (AGPU RenderpassColorAttachmentDescription()
                format: (each format castTo: AGPU TextureFormat);
                sample_count: each sampleCount;
                sample_quality: each sampleQuality;
                begin_action: (each beginAction castTo: AGPU RenderpassAttachmentAction);
                end_action: (each endAction castTo: AGPU RenderpassAttachmentAction);
                clear_value: (AGPU Color4f() r: each clearValue r; g: each clearValue g; b: each clearValue b; a: each clearValue a; yourself);
                yourself).
        }.

        let renderPassDescription mutable type: AGPU RenderpassDescription.
        renderPassDescription
            color_attachment_count: (convertedColorAttachments size castTo: UInt32);
            color_attachments: convertedColorAttachments data.

        let convertedDepthStencilAttachment mutable type: AGPU RenderpassDepthStencilDescription.
        depthAttachment ifNotNil: {
            sampleCount := depthAttachment _ sampleCount.
            sampleQuality := depthAttachment _ sampleQuality.

            convertedDepthStencilAttachment
                format: (depthAttachment _ format castTo: AGPU TextureFormat);
                sample_count: depthAttachment _ sampleCount;
                sample_quality: depthAttachment _ sampleQuality;
                begin_action: (depthAttachment _ beginAction castTo: AGPU RenderpassAttachmentAction);
                end_action: (depthAttachment _ endAction castTo: AGPU RenderpassAttachmentAction);
                stencil_begin_action: (depthAttachment _ stencilBeginAction castTo: AGPU RenderpassAttachmentAction);
                stencil_end_action: (depthAttachment _ stencilEndAction castTo: AGPU RenderpassAttachmentAction);
                clear_value: (AGPU DepthStencilValue()
                    depth: depthAttachment _ clearValue depth;
                    stencil: depthAttachment _ clearValue stencil;
                    yourself).

            renderPassDescription depth_stencil_attachment: convertedDepthStencilAttachment address
        }.

        let renderPassHandle := handle _ createRenderPass: renderPassDescription address.
        renderPassHandle ifNil: {
            return: RenderPassPtr nil
        }.

        let result := AgpuRenderPass sharedNew.
        result _
            handle: renderPassHandle;
            theDepthStencilFormat: (depthAttachment ifNil: {PixelFormat Unknown} ifNotNil: {depthAttachment _ format});
            theSampleCount: sampleCount;
            theSampleQuality: sampleQuality.
        result _ colorAttachmentFormats reserve: colorAttachments size.
        colorAttachments do: {:each :: Void |
            result _ colorAttachmentFormats add: each format
        }.

        result upCastFor: RenderPass
    }.

    override method createFence => FencePtr := {
        let fenceHandle := handle _ createFence.
        fenceHandle ifNil: {
            return: FencePtr nil
        }.

        let result := AgpuFence sharedNew.
        result _ handle: fenceHandle.
        result upCastFor: Fence
    }.

    override method createSwapChain: (swapChainCreationInfo: SwapChainCreationInfo const ref) for: (renderingQueue: CommandQueuePtr const ref) ::=> SwapChainPtr := {
        let agpuCommandQueue := renderingQueue getPointer castTo: AgpuCommandQueue pointer.
        agpuCommandQueue ifNil: {
            return: SwapChainPtr nil
        }.

        let oldSwapChain mutable type: AGPU SwapChain pointer.
        (swapChainCreationInfo oldSwapChain getPointer castTo: AgpuSwapChain pointer) ifNotNil: { :pointer :: Void |
            oldSwapChain := pointer _ handle getPointer
        }.

        let convertedCreationInfo mutable := AGPU SwapChainCreateInfo()
            display: swapChainCreationInfo display;
            window: swapChainCreationInfo window;
            window_system_name: swapChainCreationInfo windowSystemName asCString;
            surface: swapChainCreationInfo surface;
            colorbuffer_format: (swapChainCreationInfo colorBufferFormat castTo: AGPU TextureFormat);
            depth_stencil_format: (swapChainCreationInfo depthStencilFormat castTo: AGPU TextureFormat);
            width: swapChainCreationInfo extent x;
            height: swapChainCreationInfo extent y;
            layers: swapChainCreationInfo layerCount;
            buffer_count: swapChainCreationInfo bufferCount;
            flags: (swapChainCreationInfo flags castTo: AGPU SwapChainFlags);
            x: swapChainCreationInfo position x;
            y: swapChainCreationInfo position y;
            old_swap_chain: oldSwapChain;
            presentation_mode: (swapChainCreationInfo presentationMode castTo: AGPU SwapChainPresentationMode);
            fallback_presentation_mode: (swapChainCreationInfo fallbackPresentationMode castTo: AGPU SwapChainPresentationMode);
            yourself.

        let swapChainHandle := handle _ createSwapChain: agpuCommandQueue _ handle swapChainInfo: convertedCreationInfo address.
        swapChainHandle ifNil: {
            return: SwapChainPtr nil
        }.

        let result := AgpuSwapChain sharedNew.
        result _
            handle: swapChainHandle;
            creationInfo: swapChainCreationInfo.
        result _ creationInfo oldSwapChain reset.

        result upCastFor: SwapChain
    }.

    override method waitForIdle => Void := {
        handle _ finishExecution
    }.

    override method hasTopLeftNdcOrigin => Boolean8
        := handle _ hasTopLeftNdcOrigin ~= 0.

    override method hasBottomLeftTextureCoordinates => Boolean8
        := handle _ hasBottomLeftTextureCoordinates ~= 0.

    override method nonCoherentAtomSize => UIntPointer
        := nonCoherentAtomSize.
    override method minMemoryMapAlignment => UIntPointer
        := minMemoryMapAlignment.
    override method minTexelBufferOffsetAlignment => UIntPointer
        := minTexelBufferOffsetAlignment.
    override method minUniformBufferOffsetAlignment => UIntPointer
        := minUniformBufferOffsetAlignment.
    override method minStorageBufferOffsetAlignment => UIntPointer
        := minStorageBufferOffsetAlignment.

    override method createShaderSignatureCache => ShaderSignatureCachePtr := {
        let result := GenericShaderSignatureCache sharedNew.
        result _ device: (self asWeakPointer upCastFor: RenderingDevice).
        result upCastFor: ShaderSignatureCache
    }.

    override method createVertexLayoutCache => VertexLayoutCachePtr := {
        let result := GenericVertexLayoutCache sharedNew.
        result _ device: (self asWeakPointer upCastFor: RenderingDevice).
        result upCastFor: VertexLayoutCache
    }.

    override method createPipelineStateCache => PipelineStateCachePtr := {
        let result := GenericPipelineStateCache sharedNew.
        result _ device: (self asWeakPointer upCastFor: RenderingDevice).
        result upCastFor: PipelineStateCache
    }.

    override method createShaderCache => ShaderCachePtr := {
        let result := GenericShaderCache sharedNew.
        result _ device: (self asWeakPointer upCastFor: RenderingDevice).
        result upCastFor: ShaderCache
    }.

    override method createFontCache => RenderingDeviceFontCachePtr := {
        let result := TextureAtlasRenderingDeviceFontCache sharedNew.
        result _ initializeWithDevice: (self asWeakPointer upCastFor: RenderingDevice).
        result upCastFor: RenderingDeviceFontCache
    }.

    override method createScene2DBuilder => Scene2D BuilderPtr := {
        let result := GenericScene2DBuilder sharedNew.
        result _ device: (self asWeakPointer upCastFor: RenderingDevice).
        result upCastFor: Scene2D Builder
    }.

    override method getDefaultShaderSignatureCache => ShaderSignatureCachePtr const ref
        := defaultShaderSignatureCache.

    override method getDefaultVertexLayoutCache => VertexLayoutCachePtr const ref
        := defaultVertexLayoutCache.

    override method getDefaultPipelineStateCache => PipelineStateCachePtr const ref
        := defaultPipelineStateCache.

    override method getDefaultShaderCache => ShaderCachePtr const ref
        := defaultShaderCache.

    override method getDefaultFontCache => RenderingDeviceFontCachePtr const ref
        := defaultFontCache.
}.

compileTime constant AgpuRenderingDevicePtr := AgpuRenderingDevice sharedPointer.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
