namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

compileTime if: Compiler compilationTarget isDesktopPC then: {
    Compiler addNativeLibraryDependency: #SysmelTextureCompressor.

    function sysmel_textureCompressor_compressTextureSlice externC(
        width: UInt32 , height: UInt32,
        sourceFormat: PixelFormat, sourcePitch: Int32, sourcePixels: UInt8 const pointer,
        destFormat: PixelFormat, destPitch: Int32, destPixels: UInt8 pointer) => Boolean8.
    function sysmel_textureCompressor_decompressTextureSlice externC(
        width: UInt32 , height: UInt32,
        sourceFormat: PixelFormat, sourcePitch: Int32, sourcePixels: UInt8 const pointer,
        destFormat: PixelFormat, destPitch: Int32, destPixels: UInt8 pointer) => Boolean8.
}.

enum TextureDataFlags bitMask valueType: UInt32; values: #{
    None: 0.
    OptimalTargetSpecificTiling: 1. ## For some embedded devices where the tiling layout is well known.
}.

class TextureFileHeader definition: {
    compileTime constant MagicNumber := "STEX".
    compileTime constant VersionMajor := 0.
    compileTime constant VersionMinor := 1.

    public field magic type: (Char8 array: 4).
    public field versionMajor type: UInt16.
    public field versionMinor type: UInt16.

    method isValid => Boolean8
        := magic = MagicNumber && versionMajor = VersionMajor && versionMinor = VersionMinor.

    method setValid => Void := {
        Stdn memcpy(magic address, MagicNumber, 4).
        versionMajor := VersionMajor.
        versionMinor := VersionMinor.
    }.
}.

class TextureDataHeader definition: {
    public field type type: TextureType.
    public field format type: PixelFormat.
    public field srgbFormat type: PixelFormat.

    public field width type: UInt32.
    public field height type: UInt32.
    public field depth type: UInt32.
    public field miplevels type: UInt32.
    public field layers type: UInt32.
    public field linearDataSize type: UInt32.
    public field flags type: TextureDataFlags.
    public field mainViewComponents type: ComponentsSwizzle.

    const inline method hasOptimalTargetSpecificTiling => Boolean8
        := flags anyMask: TextureDataFlags OptimalTargetSpecificTiling.

    const inline method isTexture1D => Boolean8
        := type = TextureType Texture1D.

    const inline method isTexture2D => Boolean8
        := type = TextureType Texture2D.

    const inline method isTextureCube => Boolean8
        := type = TextureType TextureCube.

    const inline method isTexture3D => Boolean8
        := type = TextureType Texture3D.
}.

#**
 * I am a container for texture pixel dta.
 *#
class TextureData superclass: TextureDataHeader; definition: {
    public field pixels type: UInt8 uniquePointer.
    public field levelsData type: Stdn Collections Vector(TextureLevelData).

    method asFormForLevel: (levelIndex: UIntPointer) ::=> FormPtr := {
        format isCompressed ifTrue: {
            return: (self asNonColorTextureDataExpandedForConversions _ asFormForLevel: levelIndex)
        }.

        let levelData ref := levelsData[levelIndex].

        let form := Form extent: levelData extent xy pixelFormat: format.
        let levelPixels := pixels getPointer + levelData dataOffset.
        let sourcePitch := levelData pitch.
        let destPitch := form _ pitch.
        sourcePitch = destPitch && levelData slicePitch = form _ height * destPitch ifTrue: {
            Stdn memcpy(form _ pixels getPointer, levelPixels, levelData slicePitch)
        } ifFalse: {
            let source mutable := levelPixels.
            let dest mutable := form _ pixels getPointer.
            0 until: form _ height do: {:y :: Void |
                Stdn memcpy(dest, source, destPitch).
                dest := dest + destPitch.
                source := source + sourcePitch.
            }
        }.

        form
    }.

    method asForm => FormPtr
        := self asFormForLevel: 0.

    method computeLinearPackedTextureLevelMetadata => Void := {
        levelsData
            removeAll;
            reserve: layers * miplevels.

        let currentDataOffset mutable := 0u.
        let extent := UInt32x3(width, height, depth).

        let compressedBlockSize := format compressedBlockSize.
        let compressedBlockExtent := format compressedBlockExtent.
        let uncompressedPixelSize := format bytesPerPixel.

        0 until: layers do: {:i :: Void |
            let currentExtent mutable := extent.
            0 until: miplevels do: {:j :: Void |
                let levelData mutable := TextureLevelData()
                    extent: currentExtent;
                    yourself.

                compressedBlockSize = 0 ifTrue: {
                    levelData
                        compressedExtent: currentExtent;
                        pitch: (currentExtent x * uncompressedPixelSize alignedTo: 4);
                        slicePitch: levelData pitch * currentExtent y.
                } ifFalse: {
                    ## Compute the width and height by separate to keep valgrind happy.
                    let compressedWidth := (currentExtent x + compressedBlockExtent x - 1) / compressedBlockExtent x max: 1u.
                    let compressedHeight := (currentExtent y + compressedBlockExtent y - 1) / compressedBlockExtent y max: 1u.
                    let compressedExtent := UInt32x3(compressedWidth, compressedHeight, currentExtent z).
                    levelData
                        compressedExtent: compressedExtent;
                        pitch: compressedExtent x * compressedBlockSize;
                        slicePitch: levelData pitch * compressedExtent y.
                }.

                levelData
                    dataOffset: currentDataOffset;
                    dataSize: levelData slicePitch * levelData compressedExtent z.
                levelsData add: levelData.

                currentExtent := currentExtent / 2u max: UInt32x3 ones.
                currentDataOffset := currentDataOffset + levelData dataSize.
            }
        }.

        linearDataSize := currentDataOffset
    }.

    inline const method convertIntoCompressedPixelFormat: (newFormat: PixelFormat) srgbFormat: (newSRGBFormat: PixelFormat) ::=> TextureData sharedPointer := {
        compileTime if: Compiler compilationTarget isDesktopPC then: {
            let result := TextureData sharedNew.
            result _
                type: type;
                format: newFormat;
                srgbFormat: newSRGBFormat;

                width: width;
                height: height;
                depth: depth;
                miplevels: miplevels;
                layers: layers;
                flags: flags;
                mainViewComponents: mainViewComponents;
                computeLinearPackedTextureLevelMetadata.
            Stdn assert: newFormat isCompressed.
            Stdn assert: format isCompressed not.
            Stdn assert: levelsData size = result _ levelsData size.
            let sourcePixelSize := format bytesPerPixel.
            let destPixelSize := newFormat bytesPerPixel.

            result _ pixels reset: (Stdn zmalloc(result _ linearDataSize) reinterpretCastTo: UInt8 pointer).

            0 until: levelsData size do: {:i :: Void |
                let sourceLevel ref := levelsData[i].
                let destLevel ref := result _ levelsData[i].

                let sourceSlice mutable := pixels getPointer + sourceLevel dataOffset.
                let destSlice mutable := result _ pixels getPointer + destLevel dataOffset.
                0 until: sourceLevel extent z do: {:z :: Void |
                    sysmel_textureCompressor_compressTextureSlice(
                        sourceLevel extent x, sourceLevel extent y,
                        format, sourceLevel pitch castTo: Int32, sourceSlice,
                        newFormat, destLevel pitch castTo: Int32, destSlice) ifFalse: {
                        return: TextureData sharedPointer nil
                    }.

                    sourceSlice := sourceSlice + sourceLevel slicePitch.
                    destSlice := destSlice + destLevel slicePitch.
                }.
            }.

            result
        } else: {
            return: TextureData sharedPointer nil
        }
    }.

    inline const method convertIntoUncompressedPixelFormat: (newFormat: PixelFormat) srgbFormat: (newSRGBFormat: PixelFormat) ::=> TextureData sharedPointer := {
        compileTime if: Compiler compilationTarget isDesktopPC then: {
            let result := TextureData sharedNew.
            result _
                type: type;
                format: newFormat;
                srgbFormat: newSRGBFormat;

                width: width;
                height: height;
                depth: depth;
                miplevels: miplevels;
                layers: layers;
                flags: flags;
                mainViewComponents: mainViewComponents;
                computeLinearPackedTextureLevelMetadata.
            Stdn assert: newFormat isCompressed not.
            Stdn assert: format isCompressed.
            Stdn assert: levelsData size = result _ levelsData size.
            let sourcePixelSize := format bytesPerPixel.
            let destPixelSize := newFormat bytesPerPixel.

            result _ pixels reset: (Stdn zmalloc(result _ linearDataSize) reinterpretCastTo: UInt8 pointer).

            0 until: levelsData size do: {:i :: Void |
                let sourceLevel ref := levelsData[i].
                let destLevel ref := result _ levelsData[i].

                let sourceSlice mutable := pixels getPointer + sourceLevel dataOffset.
                let destSlice mutable := result _ pixels getPointer + destLevel dataOffset.
                0 until: sourceLevel extent z do: {:z :: Void |
                    sysmel_textureCompressor_decompressTextureSlice(
                        sourceLevel extent x, sourceLevel extent y,
                        format, sourceLevel pitch castTo: Int32, sourceSlice,
                        newFormat, destLevel pitch castTo: Int32, destSlice) ifFalse: {
                        return: TextureData sharedPointer nil
                    }.

                    sourceSlice := sourceSlice + sourceLevel slicePitch.
                    destSlice := destSlice + destLevel slicePitch.
                }.
            }.

            result
        } else: {
            return: TextureData sharedPointer nil
        }
    }.

    inline const method convertIntoUncompressedPixelFormat: (newFormat: PixelFormat) srgbFormat: (newSRGBFormat: PixelFormat)
        with: (pixelConversionBlock: ((UInt8 pointer -- UInt8 const pointer ) => Void) nativeStackBlockClosure) ::=> TextureData sharedPointer := {
        let result := TextureData sharedNew.
        result _
            type: type;
            format: newFormat;
            srgbFormat: newSRGBFormat;

            width: width;
            height: height;
            depth: depth;
            miplevels: miplevels;
            layers: layers;
            flags: flags;
            mainViewComponents: mainViewComponents;
            computeLinearPackedTextureLevelMetadata.
        Stdn assert: levelsData size = result _ levelsData size.
        let sourcePixelSize := format bytesPerPixel.
        let destPixelSize := newFormat bytesPerPixel.

        result _ pixels reset: (Stdn zmalloc(result _ linearDataSize) reinterpretCastTo: UInt8 pointer).

        0 until: levelsData size do: {:i :: Void |
            let sourceLevel ref := levelsData[i].
            let destLevel ref := result _ levelsData[i].

            let sourceSlice mutable := pixels getPointer + sourceLevel dataOffset.
            let destSlice mutable := result _ pixels getPointer + destLevel dataOffset.
            0 until: sourceLevel extent z do: {:z :: Void |
                let sourceRow mutable := sourceSlice.
                let destRow mutable := destSlice.
                0 until: sourceLevel extent y do: {:y :: Void |
                    let sourcePixels mutable := sourceRow.
                    let destPixels mutable := destRow.
                    0 until: sourceLevel extent x do: {:x :: Void |
                        pixelConversionBlock(destPixels, sourcePixels).

                        sourcePixels := sourcePixels + sourcePixelSize.
                        destPixels := destPixels + destPixelSize.
                    }.

                    sourceRow := sourceRow + sourceLevel pitch.
                    destRow := destRow + destLevel pitch.
                }.
                sourceSlice := sourceSlice + sourceLevel slicePitch.
                destSlice := destSlice + destLevel slicePitch.
            }.
        }.

        result
    }.

    inline const method verticallyFlipped ::=> TextureData sharedPointer := {
        let result := TextureData sharedNew.
        result _
            type: type;
            format: format;
            srgbFormat: srgbFormat;

            width: width;
            height: height;
            depth: depth;
            miplevels: miplevels;
            layers: layers;
            flags: flags;
            mainViewComponents: mainViewComponents;
            computeLinearPackedTextureLevelMetadata.
        Stdn assert: levelsData size = result _ levelsData size.
        let pixelSize := format bytesPerPixel.

        result _ pixels reset: (Stdn zmalloc(result _ linearDataSize) reinterpretCastTo: UInt8 pointer).

        0 until: levelsData size do: {:i :: Void |
            let sourceLevel ref := levelsData[i].
            let destLevel ref := result _ levelsData[i].
            let sourcePitch := (sourceLevel pitch castTo: Int32) negated.

            let sourceSlice mutable := pixels getPointer + sourceLevel dataOffset.
            let destSlice mutable := result _ pixels getPointer + destLevel dataOffset.
            0 until: sourceLevel extent z do: {:z :: Void |
                let sourceRow mutable := sourceSlice + (sourceLevel extent y - 1) * sourceLevel pitch.
                let destRow mutable := destSlice.
                0 until: sourceLevel extent y do: {:y :: Void |
                    Stdn memcpy(destRow, sourceRow, destLevel pitch).
                    sourceRow := sourceRow + sourcePitch.
                    destRow := destRow + destLevel pitch.
                }.
                sourceSlice := sourceSlice + sourceLevel slicePitch.
                destSlice := destSlice + destLevel slicePitch.
            }.
        }.

        result
    }.

    inline const method swizzleComponentsWith: (swizzleBlock: ((UInt8 pointer -- UInt8 const pointer ) => Void) nativeStackBlockClosure) ::=> TextureData sharedPointer := {
        let result := TextureData sharedNew.
        result _
            type: type;
            format: format;
            srgbFormat: srgbFormat;

            width: width;
            height: height;
            depth: depth;
            miplevels: miplevels;
            layers: layers;
            flags: flags;
            mainViewComponents: mainViewComponents;
            computeLinearPackedTextureLevelMetadata.
        Stdn assert: levelsData size = result _ levelsData size.
        let pixelSize := format bytesPerPixel.

        result _ pixels reset: (Stdn zmalloc(result _ linearDataSize) reinterpretCastTo: UInt8 pointer).
        let pixelCount := result _ linearDataSize / pixelSize.
        let sourcePixels mutable := pixels getPointer.
        let destPixels mutable := result _ pixels getPointer.

        0 until: pixelCount do: {:i :: Void |
            swizzleBlock(destPixels, sourcePixels).
            destPixels := destPixels + pixelSize.
            sourcePixels := sourcePixels + pixelSize.
        }.

        result
    }.

    const method convertFromPixelFormat: (sourceFormat: PixelFormat) intoFormat: (destFormat: PixelFormat)
        resultFormat: (resultFormat: PixelFormat) srgbFormat: (resultSrgbFormat: PixelFormat) ::=> TextureData sharedPointer := {

        sourceFormat isCompressed not && destFormat isCompressed ifTrue: {
            return: (self convertIntoCompressedPixelFormat: resultFormat srgbFormat: resultSrgbFormat)
        }.

        sourceFormat isCompressed && destFormat isCompressed not ifTrue: {
            return: (self convertIntoUncompressedPixelFormat: resultFormat srgbFormat: resultSrgbFormat)
        }.

        sourceFormat isCompressed not && destFormat isCompressed not ifTrue: {
            return: (self convertIntoUncompressedPixelFormat: resultFormat srgbFormat: resultSrgbFormat
                with: { :(UInt8 pointer)destPixel :(UInt8 const pointer) sourcePixel :: Void |
                    destFormat store: (sourceFormat fetchFromMemory: sourcePixel) intoMemory: destPixel
            })
        }.

        TextureData sharedPointer nil
    }.

    const method asTextureDataExpandedForConversions => TextureData sharedPointer
        := self convertFromPixelFormat: srgbFormat intoFormat: srgbFormat asExpandedWorkingFormat
            resultFormat: srgbFormat asExpandedWorkingFormat asLinearFormat srgbFormat: srgbFormat asExpandedWorkingFormat.

    const method asNonColorTextureDataExpandedForConversions => TextureData sharedPointer
        := self convertFromPixelFormat: format intoFormat: format asExpandedWorkingFormat
            resultFormat: format asExpandedWorkingFormat srgbFormat: format asExpandedWorkingFormat asSRGBFormat.

    const method asNormalMapTextureDataExpandedForConversions => TextureData sharedPointer
        := self convertFromPixelFormat: format intoFormat: PixelFormat R8G8B8A8_UNorm
            resultFormat: PixelFormat R8G8B8A8_UNorm srgbFormat: PixelFormat R8G8B8A8_UNormSRGB.

    const method expand24To32BitsWithFormat: (newFormat: PixelFormat) srgbFormat: (newSRGBFormat: PixelFormat) ::=> TextureData sharedPointer := {
        self convertIntoUncompressedPixelFormat: newFormat srgbFormat: newSRGBFormat
            with: { :(UInt8 pointer)destPixel :(UInt8 const pointer) sourcePixel :: Void |
                destPixel[0] := sourcePixel[0].
                destPixel[1] := sourcePixel[1].
                destPixel[2] := sourcePixel[2].
                destPixel[3] := 16rff.
        }
    }.

    const method asTextureDataWithExpandedUnalignedRGBFormats => TextureData sharedPointer := {
        format selectCase: #{
        PixelFormat R8G8B8_UNorm : (self expand24To32BitsWithFormat: PixelFormat R8G8B8A8_UNorm srgbFormat: PixelFormat R8G8B8A8_UNormSRGB).
        PixelFormat R8G8B8_UNormSRGB : (self expand24To32BitsWithFormat: PixelFormat R8G8B8A8_UNorm srgbFormat: PixelFormat R8G8B8A8_UNormSRGB).
        PixelFormat R8G8B8_SNorm : (self expand24To32BitsWithFormat: PixelFormat R8G8B8A8_SNorm srgbFormat: PixelFormat R8G8B8A8_SNorm).

        PixelFormat B8G8R8_UNorm : (self expand24To32BitsWithFormat: PixelFormat B8G8R8A8_UNorm srgbFormat: PixelFormat B8G8R8A8_UNormSRGB).
        PixelFormat B8G8R8_UNormSRGB : (self expand24To32BitsWithFormat: PixelFormat B8G8R8A8_UNorm srgbFormat: PixelFormat B8G8R8A8_UNormSRGB).

        _ : (TextureData sharedPointer nil)
        }
    }.

    const method computeMiplevelsRequiredDownTo: (smallestLevelExtent: UInt32x3) ::=> UInt32 := {
        let currentExtent mutable := UInt32x3(width, height, depth).
        let count mutable := 1u.
        while: (currentExtent > smallestLevelExtent) isAnySet do: {
            currentExtent := currentExtent / 2u max: smallestLevelExtent.
            count := count + 1
        }.

        count
    }.

    method generateMiplevelsDownTo: (smallestLevelExtent: UInt32x3)
        withBoxFilter: (boxFilterBlock: ((UInt8 pointer -- UInt8 const pointer -- UInt8 const pointer -- UInt8 const pointer -- UInt8 const pointer) => Void) nativeStackBlockClosure)
        ::=> TextureData sharedPointer := {
        format compressedBlockSize = 0 ifFalse: {return: TextureDataPtr nil}.

        let newLevelCount := self computeMiplevelsRequiredDownTo: smallestLevelExtent.
        newLevelCount <= miplevels ifTrue: {return: TextureDataPtr nil}.

        let result := TextureData sharedNew.
        result _
            type: type;
            format: format;
            srgbFormat: srgbFormat;

            width: width;
            height: height;
            depth: depth;
            miplevels: newLevelCount;
            layers: layers;
            flags: flags;
            mainViewComponents: mainViewComponents;
            computeLinearPackedTextureLevelMetadata.
        let pixelSize := format bytesPerPixel.

        result _ pixels reset: (Stdn zmalloc(result _ linearDataSize) reinterpretCastTo: UInt8 pointer).

        let destLevelDataIndex mutable := 0u.
        let sourceLevelDataIndex mutable := 0u.
        0 until: layers do: {:layerIndex :: Void |

            ## Copy the base level
            {
                let sourceBaseLevel ref := levelsData[sourceLevelDataIndex].
                let destBaseLevel ref := levelsData[destLevelDataIndex].
                Stdn assert: sourceBaseLevel dataSize = destBaseLevel dataSize.
                Stdn memcpy(result _ pixels getPointer + destBaseLevel dataOffset, pixels getPointer + sourceBaseLevel dataOffset, sourceBaseLevel dataSize)
            }.

            0 until: newLevelCount - 1 do: {:levelIndex :: Void |
                let sourceLevel ref := result _ levelsData[destLevelDataIndex + levelIndex].
                let destLevel ref := result _ levelsData[destLevelDataIndex + levelIndex + 1u].

                let sourceRowAdvance mutable := sourceLevel pitch*2.
                let sourceTopRowDelta mutable := sourceLevel pitch.
                let sourcePixelAdvance mutable := pixelSize*2.
                let sourceColumnPixelDelta mutable := pixelSize.

                destLevel extent y * 2 = sourceLevel extent y ifFalse: {
                    sourceRowAdvance := sourceLevel pitch.
                    sourceTopRowDelta := 0.
                }.
                destLevel extent x * 2 = sourceLevel extent x ifFalse: {
                    sourcePixelAdvance := pixelSize.
                    sourceColumnPixelDelta := 0.
                }.

                let sourceSlice mutable := result _ pixels getPointer + sourceLevel dataOffset.
                let destSlice mutable := result _ pixels getPointer + destLevel dataOffset.
                0 until: destLevel extent z do: {:z :: Void |
                    let sourceTopRow mutable := sourceSlice.
                    let sourceBottomRow mutable := sourceSlice + sourceTopRowDelta.

                    let destRow mutable := destSlice.
                    0 until: destLevel extent y do: {:y :: Void |
                        let sourceTopPixels mutable := sourceTopRow.
                        let sourceBottomPixels mutable := sourceBottomRow.
                        let destPixels mutable := destRow.
                        0 until: destLevel extent x do: {:x :: Void |
                            let sourceTopLeft := sourceTopPixels.
                            let sourceTopRight := sourceTopPixels + sourceColumnPixelDelta.
                            let sourceBottomLeft := sourceBottomPixels.
                            let sourceBottomRight := sourceBottomPixels + sourceColumnPixelDelta.

                            boxFilterBlock(destPixels, sourceTopLeft, sourceTopRight, sourceBottomLeft, sourceBottomRight).

                            sourceTopPixels := sourceTopPixels + sourcePixelAdvance.
                            sourceBottomPixels := sourceBottomPixels + sourcePixelAdvance.
                            destPixels := destPixels + pixelSize.
                        }.

                        sourceTopRow := sourceTopRow + sourceRowAdvance.
                        sourceBottomRow := sourceBottomRow + sourceRowAdvance.
                        destRow := destRow + destLevel pitch.
                    }.
                    sourceSlice := sourceSlice + sourceLevel slicePitch.
                    destSlice := destSlice + destLevel slicePitch.
                }.
            }.

            sourceLevelDataIndex := sourceLevelDataIndex + miplevels.
            destLevelDataIndex := destLevelDataIndex + newLevelCount.
        }.

        result
    }.

    method generateMiplevels8x3DownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer := {
        self generateMiplevelsDownTo: smallestLevelExtent withBoxFilter: {:destPixels
        :sourceTopLeftPixels :sourceTopRightPixels :sourceBottomLeftPixels :sourceBottomRightPixels :: Void |
            let topLeft := (UInt8x3(sourceTopLeftPixels[0], sourceTopLeftPixels[1], sourceTopLeftPixels[2]) castTo: Float32x3).
            let topRight := (UInt8x3(sourceTopRightPixels[0], sourceTopRightPixels[1], sourceTopRightPixels[2]) castTo: Float32x3).
            let bottomLeft := (UInt8x3(sourceBottomLeftPixels[0], sourceBottomLeftPixels[1], sourceBottomLeftPixels[2]) castTo: Float32x3).
            let bottomRight := (UInt8x3(sourceBottomRightPixels[0], sourceBottomRightPixels[1], sourceBottomRightPixels[2]) castTo: Float32x3).

            let filtered := (((topLeft + topRight + bottomLeft + bottomRight)*0.25f + 0.5f) floor clampMin: 0.0f max: 255.0f) castTo: UInt8x3.
            destPixels[0] := filtered x.
            destPixels[1] := filtered y.
            destPixels[2] := filtered z.
        }
    }.

    method generateMiplevels8x4DownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer := {
        self generateMiplevelsDownTo: smallestLevelExtent withBoxFilter: {:destPixels
        :sourceTopLeftPixels :sourceTopRightPixels :sourceBottomLeftPixels :sourceBottomRightPixels :: Void |
            let topLeft := (sourceTopLeftPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4.
            let topRight := (sourceTopRightPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4.
            let bottomLeft := (sourceBottomLeftPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4.
            let bottomRight := (sourceBottomRightPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4.

            let filtered := (((topLeft + topRight + bottomLeft + bottomRight)*0.25f + 0.5f) floor clampMin: 0.0f max: 255.0f) castTo: UInt8x4.
            (destPixels reinterpretCastTo: UInt8x4 pointer) _ := filtered
        }
    }.

    method generateSRGBMiplevels8x3DownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer := {
        useNamespace: Stdn Math Color.
        self generateMiplevelsDownTo: smallestLevelExtent withBoxFilter: {:destPixels
        :sourceTopLeftPixels :sourceTopRightPixels :sourceBottomLeftPixels :sourceBottomRightPixels :: Void |
            let topLeft := Float32x3(decodeSRGBChannelUnorm8(sourceTopLeftPixels[0]), decodeSRGBChannelUnorm8(sourceTopLeftPixels[1]), decodeSRGBChannelUnorm8(sourceTopLeftPixels[2])).
            let topRight := Float32x3(decodeSRGBChannelUnorm8(sourceTopRightPixels[0]), decodeSRGBChannelUnorm8(sourceTopRightPixels[1]), decodeSRGBChannelUnorm8(sourceTopRightPixels[2])).
            let bottomLeft := Float32x3(decodeSRGBChannelUnorm8(sourceBottomLeftPixels[0]), decodeSRGBChannelUnorm8(sourceBottomLeftPixels[1]), decodeSRGBChannelUnorm8(sourceBottomLeftPixels[2])).
            let bottomRight := Float32x3(decodeSRGBChannelUnorm8(sourceBottomRightPixels[0]), decodeSRGBChannelUnorm8(sourceTopLeftPixels[1]), decodeSRGBChannelUnorm8(sourceBottomRightPixels[2])).

            let filtered := (topLeft + topRight + bottomLeft + bottomRight)*0.25f clampMin: 0.0f max: 1.0f.

            destPixels[0] := encodeSRGBChannelUnorm8(filtered x).
            destPixels[1] := encodeSRGBChannelUnorm8(filtered y).
            destPixels[2] := encodeSRGBChannelUnorm8(filtered z).
        }
    }.

    method generateSRGBMiplevels8x4DownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer := {
        useNamespace: Stdn Math Color.
        self generateMiplevelsDownTo: smallestLevelExtent withBoxFilter: {:destPixels
        :sourceTopLeftPixels :sourceTopRightPixels :sourceBottomLeftPixels :sourceBottomRightPixels :: Void |
            let topLeft := decodeSRGBUnorm8((sourceTopLeftPixels reinterpretCastTo: UInt8x4 const pointer) _).
            let topRight := decodeSRGBUnorm8((sourceTopRightPixels reinterpretCastTo: UInt8x4 const pointer) _).
            let bottomLeft := decodeSRGBUnorm8((sourceBottomLeftPixels reinterpretCastTo: UInt8x4 const pointer) _).
            let bottomRight := decodeSRGBUnorm8((sourceBottomRightPixels reinterpretCastTo: UInt8x4 const pointer) _).

            let filtered := (topLeft + topRight + bottomLeft + bottomRight)*0.25f clampMin: 0.0f max: 1.0f.
            (destPixels reinterpretCastTo: UInt8x4 pointer) _ := encodeSRGBUnorm8(filtered)
        }
    }.

    method generateNormalMiplevels8x3DownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer := {
        self generateMiplevelsDownTo: smallestLevelExtent withBoxFilter: {:destPixels
        :sourceTopLeftPixels :sourceTopRightPixels :sourceBottomLeftPixels :sourceBottomRightPixels :: Void |
            let topLeft := (UInt8x3(sourceTopLeftPixels[0], sourceTopLeftPixels[1], sourceTopLeftPixels[2]) castTo: Float32x3)/255.0f*2.0f - 1.0f.
            let topRight := (UInt8x3(sourceTopRightPixels[0], sourceTopRightPixels[1], sourceTopRightPixels[2]) castTo: Float32x3)/255.0f*2.0f - 1.0f.
            let bottomLeft := (UInt8x3(sourceBottomLeftPixels[0], sourceBottomLeftPixels[1], sourceBottomLeftPixels[2]) castTo: Float32x3)/255.0f*2.0f - 1.0f.
            let bottomRight := (UInt8x3(sourceBottomRightPixels[0], sourceBottomRightPixels[1], sourceBottomRightPixels[2]) castTo: Float32x3)/255.0f*2.0f - 1.0f.

            let normalized := (topLeft + topRight + bottomLeft + bottomRight) normalized.
            let filtered := (((normalized*0.5f + 0.5f)*255.0f + 0.5f) floor clampMin: 0.0f max: 255.0f) castTo: UInt8x3.

            destPixels[0] := filtered x.
            destPixels[1] := filtered y.
            destPixels[2] := filtered z.
        }
    }.

    method generateNormalMiplevels8x4DownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer := {
        self generateMiplevelsDownTo: smallestLevelExtent withBoxFilter: {:destPixels
        :sourceTopLeftPixels :sourceTopRightPixels :sourceBottomLeftPixels :sourceBottomRightPixels :: Void |
            let topLeft := ((sourceTopLeftPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4)/255.0f*2.0f - 1.0f.
            let topRight := ((sourceTopRightPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4)/255.0f*2.0f - 1.0f.
            let bottomLeft := ((sourceBottomLeftPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4)/255.0f*2.0f - 1.0f.
            let bottomRight := ((sourceBottomRightPixels reinterpretCastTo: UInt8x4 const pointer) _ castTo: Float32x4)/255.0f*2.0f - 1.0f.

            let sum := topLeft + topRight + bottomLeft + bottomRight.
            let normalized := Float32x4(sum rgb normalized, sum a * 0.25f).
            let filtered := (((normalized*0.5f + 0.5f)*255.0f + 0.5f) floor clampMin: 0.0f max: 255.0f) castTo: UInt8x4.
            (destPixels reinterpretCastTo: UInt8x4 pointer) _ := filtered
        }
    }.

    method generateMiplevelsDownTo: (smallestLevelExtent: UInt32x3) decodingFormat: (decodingFormat: PixelFormat)::=> TextureData sharedPointer := {
        decodingFormat selectCase: #{
            (
                PixelFormat R8G8B8_UNorm, PixelFormat B8G8R8_UNorm
            ) asValueInSetPattern : {
                self generateMiplevels8x3DownTo: smallestLevelExtent
            }.

            (
                PixelFormat R8G8B8_UNormSRGB, PixelFormat B8G8R8_UNormSRGB
            ) asValueInSetPattern : {
                self generateSRGBMiplevels8x3DownTo: smallestLevelExtent
            }.

            (
                PixelFormat R8G8B8A8_UNorm, PixelFormat B8G8R8A8_UNorm,
                PixelFormat B8G8R8X8_UNorm, PixelFormat B8G8R8A8_Typeless,
                PixelFormat B8G8R8X8_Typeless
            ) asValueInSetPattern : {
                self generateMiplevels8x4DownTo: smallestLevelExtent
            }.

            (
                PixelFormat R8G8B8A8_UNormSRGB, PixelFormat B8G8R8A8_UNormSRGB, PixelFormat B8G8R8X8_UNormSRGB
            ) asValueInSetPattern : {
                self generateSRGBMiplevels8x4DownTo: smallestLevelExtent
            }.

            _ : TextureData sharedPointer nil.
        }.
    }.

    method generateMiplevelsDownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer
        := self generateMiplevelsDownTo: smallestLevelExtent decodingFormat: format.

    method generateMiplevels => TextureData sharedPointer
        := self generateMiplevelsDownTo: 1.

    method generateColorMiplevelsDownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer
        := self generateMiplevelsDownTo: smallestLevelExtent decodingFormat: srgbFormat.

    method generateColorMiplevels => TextureData sharedPointer
        := self generateColorMiplevelsDownTo: 1.

    method generateNormalMiplevelsDownTo: (smallestLevelExtent: UInt32x3) ::=> TextureData sharedPointer := {
        format selectCase: #{
            (
                PixelFormat R8G8B8_UNorm, PixelFormat R8G8B8_UNormSRGB, PixelFormat B8G8R8_UNorm, PixelFormat B8G8R8_UNormSRGB
            ) asValueInSetPattern : {
                self generateNormalMiplevels8x3DownTo: smallestLevelExtent
            }.

            (
                PixelFormat R8G8B8A8_UNorm, PixelFormat R8G8B8A8_UNormSRGB, PixelFormat B8G8R8A8_UNorm,
                PixelFormat B8G8R8X8_UNorm, PixelFormat B8G8R8A8_Typeless, PixelFormat B8G8R8A8_UNormSRGB,
                PixelFormat B8G8R8X8_Typeless, PixelFormat B8G8R8X8_UNormSRGB
            ) asValueInSetPattern : {
                self generateNormalMiplevels8x4DownTo: smallestLevelExtent
            }.

            _ : TextureData sharedPointer nil.
        }.
    }.

    method generateNormalMiplevels => TextureData sharedPointer
        := self generateNormalMiplevelsDownTo: 1.

    const method swizzleComponentsForRXGBNormalMap => TextureData sharedPointer := {
        let result := self swizzleComponentsWith: {:(UInt8 pointer)destPixel :(UInt8 const pointer)sourcePixel :: Void |
            let source := (sourcePixel reinterpretCastTo: UInt8x4 const pointer) _.
            (destPixel reinterpretCastTo: UInt8x4 pointer) _ := UInt8x4(0, source g, 0, source r)
        }.
        result _ mainViewComponents: (ComponentsSwizzle()
            r: ComponentSwizzle A;
            g: ComponentSwizzle G;
            b: ComponentSwizzle Zero;
            a: ComponentSwizzle Zero;
            yourself).
        result
    }.
}.

compileTime constant TextureDataPtr := TextureData sharedPointer.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
