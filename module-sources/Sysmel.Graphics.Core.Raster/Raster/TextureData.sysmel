namespace Stdn definition: {
namespace Graphics definition: {
namespace Core definition: {

enum TextureDataFlags bitMask valueType: UInt32; values: #{
    None: 0.
    OptimalTargetSpecificTiling: 1. ## For some embedded devices where the tiling layout is well known.
}.

class TextureDataHeader definition: {
    public field type type: TextureType.
    public field format type: PixelFormat.
    public field srgbFormat type: PixelFormat.

    public field width type: UInt32.
    public field height type: UInt32.
    public field depth type: UInt32.
    public field miplevels type: UInt32.
    public field layers type: UInt32.
    public field linearDataSize type: UInt32.
    public field flags type: TextureDataFlags.
    public field mainViewComponents type: ComponentsSwizzle.
}.

#**
 * I am a container for texture pixel dta.
 *#
class TextureData superclass: TextureDataHeader; definition: {
    public field pixels type: UInt8 uniquePointer.
    public field levelsData type: Stdn Collections Vector(TextureLevelData).

    method computeLinearPackedTextureLevelMetadata => Void := {
        levelsData
            removeAll;
            reserve: layers * miplevels.

        let currentDataOffset mutable := 0u.
        let extent := UInt32x3(width, height, depth).

        let compressedBlockSize := format compressedBlockSize.
        let compressedBlockExtent := format compressedBlockExtent.
        let uncompressedPixelSize := format bytesPerPixel.

        0 until: layers do: {:i :: Void |
            let currentExtent mutable := extent.
            0 until: miplevels do: {:j :: Void |
                let levelData mutable := TextureLevelData()
                    extent: currentExtent;
                    yourself.

                compressedBlockSize = 0 ifTrue: {
                    levelData
                        compressedExtent: currentExtent;
                        pitch: (currentExtent x * uncompressedPixelSize alignedTo: 4);
                        slicePitch: levelData pitch * currentExtent y.
                } ifFalse: {
                    ## Compute the width and height by separate to keep valgrind happy.
                    let compressedWidth := (currentExtent x + compressedBlockExtent x - 1) / compressedBlockExtent x max: 1u.
                    let compressedHeight := (currentExtent y + compressedBlockExtent y - 1) / compressedBlockExtent y max: 1u.
                    let compressedExtent := UInt32x3(compressedWidth, compressedHeight, currentExtent z).
                    levelData
                        compressedExtent: compressedExtent;
                        pitch: compressedExtent x * compressedBlockSize;
                        slicePitch: levelData pitch * compressedExtent y.
                }.

                levelData
                    dataOffset: currentDataOffset;
                    dataSize: levelData slicePitch * levelData compressedExtent z.
                levelsData add: levelData.

                currentExtent := currentExtent / 2u max: UInt32x3 ones.
                currentDataOffset := currentDataOffset + levelData dataSize.
            }
        }.

        linearDataSize := currentDataOffset
    }.
}.

compileTime constant TextureDataPtr := TextureData sharedPointer.

}. ## End of namespace Core
}. ## End of namespace Graphics
}. ## End of namespace Stdn
