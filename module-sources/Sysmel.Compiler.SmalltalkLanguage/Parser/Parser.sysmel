namespace Sysmel definition: {
namespace Compiler definition: {
namespace SmalltalkLanguage definition: {

useNamespace: Sysmel Compiler Parsing.

class Parser definition: {


    method parseIntegerIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Integer ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected an integer literal." asMutableString).
        }.

        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.

        ASTIntegerLiteralNode new
            tokenRange: position;
            stringValue: token text asMutableString;
            upCastFor: ASTNode
    }.

    method parseFloatIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Float ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a float literal." asMutableString).
        }.

        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.

        ASTFloatLiteralNode new
            tokenRange: position;
            value: token text parseFloat64;
            upCastFor: ASTNode
    }.

    method parseString: (rawString: Char8 const arraySlice) escapeSequencesInto: (result: Std String ref) errorMessageInto: (errorMessage: Std String ref) ::=> Boolean8 := {
        let end := rawString size - 1.
        for: (let i mutable type: UIntPointer := 1) while: (i < end) do: {
            let c := rawString[i].

            c = '\\' ifTrue: {
                i + 1 < end ifFalse: {
                    errorMessage := "String literal has incomplete escape sequence.".
                    return: false
                }.
                i := i + 1.
                rawString[i] selectCase: #{
                'n' : (result add: '\n').
                'r' : (result add: '\r').
                't' : (result add: '\t').
                let x : (result add: x)
                }.
            } ifFalse: {
                result add: c
            }.
        } continueWith: (i := i + 1).

        true
    }.

    method parseStringIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType String ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a string literal." asMutableString).
        }.

        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.
        let tokenContent := token text.
        Std assert: tokenContent size >= 2.

        let result := ASTStringLiteralNode new
            tokenRange: position;
            yourself.

        let errorMessage mutable type: Std String.
        (self parseString: tokenContent escapeSequencesInto: result value errorMessageInto: errorMessage) ifFalse: {
            return: (ASTParseErrorNode atToken: startPosition message: errorMessage).
        }.

        result upCastFor: ASTNode
    }.

    method parseCharacterIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Character ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a character literal." asMutableString).
        }.

        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.
        let tokenContent := token text.
        Std assert: tokenContent size >= 1.

        let utf32String := Std LString fromUTF8: (tokenContent elements from: 1 until: tokenContent size).
        utf32String size ~= 1 ifTrue: {
            return: (ASTParseErrorNode atToken: startPosition message: "Invalid character literal with multiple code points." asMutableString).
        }.

        ASTCharacterLiteralNode new
            tokenRange: position;
            value: utf32String first;
            upCastFor: ASTNode
    }.

    method parseIdentifierReferenceIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Identifier ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected an identifier reference." asMutableString).
        }.

        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.

        ASTIdentifierReferenceNode new
            tokenRange: position;
            identifier: token text asMutableString;
            upCastFor: ASTNode
    }.

    method parseIdentifierAsSymbolIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Identifier ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected an identifier." asMutableString).
        }.

        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.

        ASTSymbolLiteralNode new
            tokenRange: position;
            value: token text asMutableString;
            upCastFor: ASTNode
    }.

    method parseLiteralSymbolStringIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType SymbolString ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a literal symbol string ." asMutableString).
        }.

        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.
        let tokenContent := token text.
        Std assert: tokenContent size >= 3.

        let result := ASTSymbolLiteralNode new
            tokenRange: position;
            yourself.

        let errorMessage mutable type: Std String.
        (self parseString: (tokenContent elements from: 1 until: tokenContent size)
            escapeSequencesInto: result value errorMessageInto: errorMessage) ifFalse: {
            return: (ASTParseErrorNode atToken: startPosition message: errorMessage).
        }.

        result upCastFor: ASTNode
    }.

    method parseSimpleLiteralSymbolIn: (currentPosition: TokenizedSourceCodeRange ref) prefixSize: (prefixSize: UIntPointer)::=> ASTNodeRef := {
        let startPosition := currentPosition.
        let token := currentPosition next.
        let position := startPosition until: currentPosition.
        let tokenContent := token text.
        Std assert: tokenContent size >= prefixSize.

        ASTSymbolLiteralNode new
            value: (tokenContent elements from: prefixSize until: tokenContent size);
            tokenRange: position;
            upCastFor: ASTNode
    }.

    method parseLiteralSymbolKeywordIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType SymbolKeyword ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a literal symbol keyword ." asMutableString).
        }.

        self parseSimpleLiteralSymbolIn: currentPosition prefixSize: 1
    }.

    method parseLiteralSymbolIdentifierIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType SymbolIdentifier ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a literal symbol identifier ." asMutableString).
        }.

        self parseSimpleLiteralSymbolIn: currentPosition prefixSize: 1
    }.

    method parseLiteralSymbolOperatorIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType SymbolOperator ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a literal symbol binary operator ." asMutableString).
        }.

        self parseSimpleLiteralSymbolIn: currentPosition prefixSize: 1
    }.

    method parseLiteralIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type selectCase: #{
        TokenType Integer : (self parseIntegerIn: currentPosition).
        TokenType Float : (self parseFloatIn: currentPosition).
        TokenType String : (self parseStringIn: currentPosition).
        TokenType Character : (self parseCharacterIn: currentPosition).
        TokenType SymbolKeyword : (self parseLiteralSymbolKeywordIn: currentPosition).
        TokenType SymbolIdentifier : (self parseLiteralSymbolIdentifierIn: currentPosition).
        TokenType SymbolOperator : (self parseLiteralSymbolOperatorIn: currentPosition).
        TokenType SymbolString : (self parseLiteralSymbolStringIn: currentPosition).
        TokenType LiteralArrayLeftParent : (self parseLiteralArrayIn: currentPosition).
        _ : (ASTParseErrorNode atToken: currentPosition message: "Expected a literal." asMutableString).
        }.
    }.

    method parseDictionaryKeyIn: (currentPosition: TokenizedSourceCodeRange ref) isLiteral: (isLiteral: Boolean8) ::=> ASTNodeRef := {
        ## The single keyword cased.
        currentPosition peek type = TokenType Keyword ifTrue: {
            let symbol := ASTSymbolLiteralNode new.
            let keywordPosition := currentPosition until: 1.
            let keywordContent := currentPosition next text.
            Std assert: keywordContent size > 1.
            (self isSingleKeyword: keywordContent) ifFalse: {
                return: (ASTParseErrorNode atToken: keywordPosition message: "Expected a single keyword ." asMutableString).
            }.

            symbol
                tokenRange: keywordPosition;
                value: (keywordContent elements until: keywordContent size - 1).
            return: (symbol upCastFor: ASTNode)
        }.

        let key mutable := ASTNodeRef nil.
        isLiteral ifTrue: {
            key := self parseLiteralArrayElementIn: currentPosition.
            void
        } ifFalse: {
            key := self parseBinaryExpressionIn: currentPosition
        }.

        ## The separator.
        currentPosition peek type = TokenType Colon ifTrue: {
            currentPosition advance
        } ifFalse: {
            key isParseErrorNode ifFalse: {
                return: (ASTParseErrorNode atToken: currentPosition message: "Expected a colon after the key ." asMutableString).
            }
        }.

        key
    }.

    method parseDictionaryElementIn: (currentPosition: TokenizedSourceCodeRange ref) isLiteral: (isLiteral: Boolean8) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Splice ifTrue: {
            return: (self parseSpliceIn: currentPosition)
        }.

        let startPosition := currentPosition.
        let element := ASTDictionaryElementNode new.
        element key: (self parseDictionaryKeyIn: currentPosition isLiteral: isLiteral).

        currentPosition peek type selectCase: #{
        TokenType Dot : ().
        TokenType RightCurlyBracket : ().
        _ : {
            isLiteral ifTrue: {
                element value: (self parseLiteralArrayElementIn: currentPosition).
                void
            } ifFalse: {
                element value: (self parseExpressionIn: currentPosition)
            }
        }.
        }.

        element 
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseDictionaryIn: (currentPosition: TokenizedSourceCodeRange ref) isLiteral: (isLiteral: Boolean8) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        currentPosition peek type = TokenType DictionaryLeftBracket ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a directionary expression ." asMutableString).
        }.
        currentPosition advance.

        let result := ASTMakeDictionaryNode new.
        let hasMetError mutable := false.
        do: {
            while: currentPosition peek type = TokenType Dot do: {
                currentPosition advance
            }.

            currentPosition peek type = TokenType RightCurlyBracket ifFalse: {
                let element := self parseDictionaryElementIn: currentPosition isLiteral: isLiteral.
                result elements add: element.
                hasMetError := element isParseErrorNode
            }.
        } while: (hasMetError not && currentPosition peek type = TokenType Dot).

        currentPosition peek type = TokenType RightCurlyBracket ifTrue: {
            currentPosition advance.
        } ifFalse: {
            hasMetError ifFalse: {
                result elements add: (ASTParseErrorNode atToken: currentPosition message: "Expected a bracket ('}') ending the dictionary expression ." asMutableString).
            }.
        }.

        result 
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseLiteralArrayElementIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type selectCase: #{
        TokenType LeftParent : (self parseLiteralArrayIn: currentPosition).
        TokenType Identifier : (self parseIdentifierReferenceIn: currentPosition).
        TokenType DictionaryLeftBracket : (self parseDictionaryIn: currentPosition isLiteral: true).
        (TokenType Keyword,
        TokenType GenericBinaryOperator, TokenType LogicalNot,
        TokenType BitwiseNot, TokenType BitwiseOr, TokenType BitwiseXor, TokenType Minus,
        TokenType Plus, TokenType LessThan, TokenType GreaterThan,
        TokenType Colon, TokenType ColonColon, TokenType Assignment,
        TokenType Dot, TokenType Semicolon
        ) asValueInSetPattern : (self parseSimpleLiteralSymbolIn: currentPosition prefixSize: 0).
        _ : (self parseLiteralIn: currentPosition)
        }.

    }.

    method parseLiteralArrayIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        {
            let tokenType := currentPosition peek type.
            tokenType = TokenType LiteralArrayLeftParent || tokenType = TokenType LeftParent ifFalse: {
                return: (ASTParseErrorNode atToken: currentPosition message: "Expected a literal array ." asMutableString).
            }.
        }.
        currentPosition advance.

        let result := ASTLiteralArrayNode new.
        let hasMetError mutable := false.
        until: hasMetError || currentPosition peek type = TokenType RightParent do: {
            let element := self parseLiteralArrayElementIn: currentPosition.
            result elements add: element.
            hasMetError := element isParseErrorNode
        }.

        currentPosition peek type = TokenType RightParent ifTrue: {
            currentPosition advance.
        } ifFalse: {
            hasMetError ifFalse: {
                result elements add: (ASTParseErrorNode atToken: currentPosition message: "Expected a right parenthesis ." asMutableString).
            }.
        }.

        result
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseParentExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        currentPosition peek type = TokenType LeftParent ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a parenthesis." asMutableString).
        }.
        currentPosition advance.

        let expression := self parseExpressionIn: currentPosition.
        expression isParseErrorNode ifTrue: {
            return: expression
        }.

        currentPosition peek type = TokenType RightParent ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a right parenthesis." asMutableString).
        }.
        currentPosition advance.
        expression
    }.

    method parseMakeArrayExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let result := ASTMakeArrayNode new.
        currentPosition peek type = TokenType LeftCurlyBracket ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a left curly bracket." asMutableString).
        }.

        let startPosition := currentPosition.
        currentPosition advance.

        let hasMetError mutable := false.
        do: {
            while: currentPosition peek type = TokenType Dot do: {
                currentPosition advance
            }.

            currentPosition peek type = TokenType RightCurlyBracket ifFalse: {
                let expression := self parseExpressionIn: currentPosition.
                result elements add: expression.
                hasMetError := hasMetError || expression isParseErrorNode.
            }.
        } while: (currentPosition peek type = TokenType Dot).

        currentPosition peek type = TokenType RightCurlyBracket ifTrue: {
            currentPosition advance.
        } ifFalse: {
            hasMetError ifFalse: {
                result elements add: (ASTParseErrorNode atToken: currentPosition message: "Expected a right curly bracket ." asMutableString).
            }.
        }.

        result
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseCallArgumentsIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        currentPosition peek type = TokenType LeftParent ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a parenthesis." asMutableString).
        }.
        currentPosition advance.

        let arguments := self parseExpressionListIn: currentPosition until: TokenType RightParent.

        currentPosition peek type = TokenType RightParent ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a right parenthesis." asMutableString).
        }.
        currentPosition advance.
        arguments
    }.

    method parseKeywordPragmaIn: (currentPosition: TokenizedSourceCodeRange ref) contentInto: (pragma: ASTPragmaNode rcRef const ref) ::=> Void := {
        let selector := ASTSymbolLiteralNode new.
        let startPosition := currentPosition.

        let hasMetError mutable := false.
        while: hasMetError not && currentPosition peek type = TokenType Keyword do: {
            let keywordPosition := currentPosition until: 1.
            let keyword := currentPosition next text.
            selector value addAll: keyword.

            (self isSingleKeyword: keyword) ifFalse: {
                pragma arguments add: (ASTParseErrorNode atToken: currentPosition message: "Expected a single keyword." asMutableString).
                hasMetError := true.
            }.

            let argument := self parsePrimaryExpressionIn: currentPosition.
            pragma arguments add: argument.
            hasMetError := hasMetError || argument isParseErrorNode
        }.

        ## Set the selector.
        selector tokenRange: (startPosition until: currentPosition).
        pragma selector: (selector upCastFor: ASTNode)
    }.

    method parsePragmaIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        currentPosition peek type = TokenType LessThan ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a pragma." asMutableString)
        }.
        currentPosition advance.

        let pragma := ASTPragmaNode new.
        currentPosition peek type selectCase: #{
        TokenType Identifier : {
            pragma selector: (ASTSymbolLiteralNode new
                tokenRange: (currentPosition until: 1);
                value: currentPosition next text;
                upCastFor: ASTNode)
        }.
        TokenType Keyword : (self parseKeywordPragmaIn: currentPosition contentInto: pragma).
        _ : (
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a pragma selector." asMutableString)
        )
        }.

        currentPosition peek type = TokenType GreaterThan ifTrue: {
            currentPosition advance
        } ifFalse: {
            pragma arguments isEmpty || pragma arguments last isParseErrorNode not ifTrue: {
                pragma arguments add: (ASTParseErrorNode atToken: currentPosition message: "Expected the pragma end delimiter ('>')." asMutableString)
            }
        }.

        pragma
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseIdentifierOrMacroExpansionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type selectCase: #{
        TokenType Identifier : (self parseIdentifierAsSymbolIn: currentPosition).
        TokenType QuasiUnquote : (self parseQuasiUnquoteIn: currentPosition).
        _ : (ASTParseErrorNode atToken: currentPosition message: "Expected an identifier or a macro expansion" asMutableString)
        }.
    }.

    method parseBlockClosureArgumentIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        currentPosition peek type = TokenType Colon ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a colon (:) before a block closure argument definition." asMutableString)
        }.
        currentPosition advance.

        let node := ASTBlockClosureArgumentNode new.
        currentPosition peek type = TokenType LeftParent ifTrue: {
            node type: (self parseParentExpressionIn: currentPosition)
        }.

        node
            identifier: (self parseIdentifierOrMacroExpansionIn: currentPosition);
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseBlockClosureReturnTypeIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type selectCase: #{
        TokenType Identifier : (self parseIdentifierReferenceIn: currentPosition).
        TokenType QuasiUnquote : (self parseQuasiUnquoteIn: currentPosition).
        TokenType LeftParent : (self parseParentExpressionIn: currentPosition).
        _ : (ASTParseErrorNode atToken: currentPosition message: "Expected a block closure return type specification." asMutableString)
        }.
    }.

    method parseBlockClosureExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        currentPosition peek type = TokenType LeftBracket ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a block." asMutableString).
        }.
        currentPosition advance.

        let block := ASTBlockClosureNode new.

        let hasMetError mutable := false.
        let hasArgumentsOrReturnType mutable := false.
        while: hasMetError not && currentPosition peek type = TokenType Colon do: {
            let argument := self parseBlockClosureArgumentIn: currentPosition.
            block arguments add: argument.
            hasMetError := argument isParseErrorNode.
            hasArgumentsOrReturnType := true.
        }.

        currentPosition peek type = TokenType ColonColon ifTrue: {
            currentPosition advance.
            block returnType: (self parseBlockClosureReturnTypeIn: currentPosition).
            hasArgumentsOrReturnType := true
        }.

        hasArgumentsOrReturnType ifTrue: {
            currentPosition peek type = TokenType BitwiseOr ifTrue: {
                currentPosition advance.
            } ifFalse: {
                block content: ((ASTParseErrorNode atToken: currentPosition message: "Expected the delimiter separating the block arguments from its content. ('|')." asMutableString)).
                return: (block upCastFor: ASTNode)
            }.
        }.

        ## Parse the sequence.
        block content: (self parseSequenceIn: currentPosition until: TokenType RightBracket).

        currentPosition peek type = TokenType RightBracket ifTrue: {
            currentPosition advance
        } ifFalse: {
            block content isParseErrorNode ifFalse: {
                Std assert: block content isSequenceNode.
                (block content rcObjectAddress castTo: ASTSequenceNode pointer) _
                    expressions add: (ASTParseErrorNode atToken: currentPosition message: "Expected a block ending with a right bracket(']')." asMutableString)
            }.
        }.

        block
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseReturnExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType BitwiseXor ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a return expression." asMutableString)
        }.

        let startPosition := currentPosition.
        currentPosition advance.

        let expression := self parseExpressionIn: currentPosition.

        ASTReturnNode new
            tokenRange: (startPosition until: currentPosition);
            expression: expression;
            upCastFor: ASTNode
    }.

    method parseQuoteIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Quote ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a quote expression." asMutableString)
        }.

        let startPosition := currentPosition.
        currentPosition advance.

        let quoted := self parsePrimaryExpressionIn: currentPosition.

        ASTQuoteNode new
            tokenRange: (startPosition until: currentPosition);
            quoted: quoted;
            upCastFor: ASTNode
    }.

    method parseQuasiQuoteIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType QuasiQuote ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a quasi quote expression." asMutableString)
        }.

        let startPosition := currentPosition.
        currentPosition advance.

        let quoted := self parsePrimaryExpressionIn: currentPosition.

        ASTQuasiQuoteNode new
            tokenRange: (startPosition until: currentPosition);
            quoted: quoted;
            upCastFor: ASTNode
    }.

    method parseQuasiUnquoteIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType QuasiUnquote ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a quasi unquote expression." asMutableString)
        }.

        let startPosition := currentPosition.
        currentPosition advance.

        let expression := self parsePrimaryExpressionIn: currentPosition.

        ASTQuasiUnquoteNode new
            tokenRange: (startPosition until: currentPosition);
            expression: expression;
            upCastFor: ASTNode
    }.

    method parseSpliceIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Splice ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a splice expression." asMutableString)
        }.

        let startPosition := currentPosition.
        currentPosition advance.

        let expression := self parsePrimaryExpressionIn: currentPosition.

        ASTSpliceNode new
            tokenRange: (startPosition until: currentPosition);
            expression: expression;
            upCastFor: ASTNode
    }.

    method parsePrimaryExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type selectCase: #{
        TokenType LeftParent : (self parseParentExpressionIn: currentPosition).
        TokenType LeftBracket : (self parseBlockClosureExpressionIn: currentPosition).
        TokenType LeftCurlyBracket : (self parseMakeArrayExpressionIn: currentPosition).
        TokenType Quote : (self parseQuoteIn: currentPosition).
        TokenType QuasiQuote : (self parseQuasiQuoteIn: currentPosition).
        TokenType QuasiUnquote : (self parseQuasiUnquoteIn: currentPosition).
        TokenType Splice : (self parseSpliceIn: currentPosition).
        TokenType Identifier : (self parseIdentifierReferenceIn: currentPosition).
        TokenType DictionaryLeftBracket : (self parseDictionaryIn: currentPosition isLiteral: false).
        _ : (self parseLiteralIn: currentPosition).
        }.
    }.


    method parseUnaryPostfixExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        let receiver mutable := self parsePrimaryExpressionIn: currentPosition.
        receiver isParseErrorNode ifTrue: {
            return: receiver
        }.

        until: currentPosition isEmpty do: {
            currentPosition peek type selectCase: #{
            TokenType Identifier : {
                ## Unary message.
                let selector := ASTSymbolLiteralNode new
                    tokenRange: (currentPosition until: 1);
                    value: currentPosition next text;
                    yourself.

                receiver := ASTMessageSendNode new
                    tokenRange: (startPosition until: currentPosition);
                    receiver: receiver;
                    selector: (selector upCastFor: ASTNode);
                    upCastFor: ASTNode.
                void
            }.
            TokenType LeftParent : {
                receiver := ASTCallNode new
                    callable: receiver;
                    arguments: (self parseCallArgumentsIn: currentPosition);
                    tokenRange: (startPosition until: currentPosition);
                    upCastFor: ASTNode.
                void
            }.
            TokenType LeftBracket : {
                ## Subscript expression.
                currentPosition advance.

                let index mutable := self parseExpressionIn: currentPosition.
                currentPosition peek type = TokenType RightBracket ifTrue: {
                    currentPosition advance
                } ifFalse: {
                    index isParseErrorNode ifFalse: {
                        index := ASTParseErrorNode atToken: currentPosition message: "Expected a right bracket ']'." asMutableString
                    }.
                }.

                receiver := ASTSubscriptNode new
                    array: receiver;
                    index: index;
                    tokenRange: (startPosition until: currentPosition);
                    upCastFor: ASTNode.
                void
            }.
            TokenType QuasiUnquote : {
                ## Unary message with macro selector.
                let selector := self parseQuasiUnquoteIn: currentPosition.

                receiver := ASTMessageSendNode new
                    tokenRange: (startPosition until: currentPosition);
                    receiver: receiver;
                    selector: selector;
                    upCastFor: ASTNode.
                void
            }.
            _ : (return: receiver)
            }.
        }.

        receiver
    }.

    method parseUnaryPrefixExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type selectCase: #{
        (TokenType Plus, TokenType Minus, TokenType LogicalNot, TokenType BitwiseNot) asValueInSetPattern : {
            let startPosition := currentPosition.
            let operation := currentPosition next text.

            let selector := ASTSymbolLiteralNode new.
            selector tokenRange: (startPosition until: currentPosition).
            selector value
                reserve: 4 + operation size;
                addAll: "pre-";
                addAll: operation.

            let receiver := self parseUnaryPrefixExpressionIn: currentPosition.

            ASTMessageSendNode new
                tokenRange: (startPosition until: currentPosition);
                selector: (selector upCastFor: ASTNode);
                receiver: receiver;
                upCastFor: ASTNode
        }.
        _ : (self parseUnaryPostfixExpressionIn: currentPosition)
        }.
    }.

    method parseUnaryExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef
        := self parseUnaryPrefixExpressionIn: currentPosition.

    method parseBinaryExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        let receiver := self parseUnaryExpressionIn: currentPosition.
        currentPosition peek type isBinaryOperator ifFalse: {
            return: receiver.
        }.


        let result := ASTBinaryMessageSendSequenceNode new.
        result operands add: receiver.

        while: currentPosition peek type isBinaryOperator do: {
            let selectorPosition := (currentPosition until: 1).
            let selectorValue := currentPosition next text.
            let selector := ASTSymbolLiteralNode new
                tokenRange: selectorPosition;
                value: selectorValue;
                yourself.

            let operand := self parseUnaryExpressionIn: currentPosition.

            result selectors add: (selector upCastFor: ASTNode).
            result operands add: operand.
        }.

        result
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseChainReceiverIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        self parseBinaryExpressionIn: currentPosition
    }.

    method isSingleKeyword: (text: Std ImmutableString) ::=> Boolean8 := {
        let colonCount mutable type: UInt32.
        text do: {:c :: Void |
            c = ':' ifTrue: {
                colonCount := colonCount + 1
            }
        }.
        colonCount = 1
    }.
    method parseChainKeywordMessageIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        currentPosition peek type = TokenType Keyword ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a keyword chained message." asMutableString)
        }.

        let selectorContent mutable := Std String().
        let chainMessage := ASTMessageChainMessageNode new.

        let hasMetError mutable := false.
        while: hasMetError not && currentPosition peek type = TokenType Keyword do: {
            let keywordPosition := currentPosition until: 1.
            let keyword := currentPosition next text.
            selectorContent addAll: keyword.

            (self isSingleKeyword: keyword) ifFalse: {
                chainMessage addArgument: (ASTParseErrorNode atToken: keywordPosition message: "Expected a single keyword." asMutableString).
                hasMetError := true.
            }.

            let argument := self parseBinaryExpressionIn: currentPosition.
            chainMessage addArgument: argument.
            hasMetError := hasMetError || argument isParseErrorNode
        }.

        let selector := ASTSymbolLiteralNode new
            tokenRange: (startPosition until: currentPosition);
            value: selectorContent;
            yourself.

        chainMessage
            tokenRange: (startPosition until: currentPosition);
            selector: (selector upCastFor: ASTNode);
            upCastFor: ASTNode
    }.

    method parseChainUnaryMessageIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType Identifier ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected an unary chained." asMutableString)
        }.

        let selector := ASTSymbolLiteralNode new
            tokenRange: (currentPosition until: 1);
            value: currentPosition next text;
            yourself.

        ASTMessageChainMessageNode new
            tokenRange: selector tokenRange;
            selector: (selector upCastFor: ASTNode);
            upCastFor: ASTNode
    }.

    method parseChainBinaryMessageIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type isBinaryOperator ifFalse: {
            return: (ASTParseErrorNode atToken: currentPosition message: "Expected a chained binary expression." asMutableString)
        }.

        let startPosition := currentPosition.
        let selector := ASTSymbolLiteralNode new
            tokenRange: (currentPosition until: 1);
            value: currentPosition next text;
            yourself.

        let operand := self parseUnaryExpressionIn: currentPosition.

        ASTMessageChainMessageNode new
            tokenRange: (startPosition until: currentPosition);
            selector: (selector upCastFor: ASTNode);
            addArgument: operand;
            upCastFor: ASTNode
    }.

    method parseChainedMessageIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type selectCase: #{
        TokenType Keyword : (self parseChainKeywordMessageIn: currentPosition).
        TokenType Identifier : (self parseChainUnaryMessageIn: currentPosition).
        (TokenType GenericBinaryOperator, TokenType LogicalNot,
        TokenType BitwiseNot, TokenType BitwiseOr, TokenType Minus, TokenType Plus,
        TokenType LessThan, TokenType GreaterThan
        ) asValueInSetPattern : (self parseChainBinaryMessageIn: currentPosition).
        _ : (ASTParseErrorNode atToken: currentPosition message: "Expected a chained message." asMutableString).
        }.
    }.

    method parseChainExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        let receiver mutable := ASTNodeRef nil.
        currentPosition peek type ~= TokenType Keyword ifTrue: {
            receiver := self parseChainReceiverIn: currentPosition.
            let nextType := currentPosition peek type.
            nextType = TokenType Keyword || nextType = TokenType Semicolon ifFalse: {
                return: receiver.
            }
        }.

        let firstChainKeywordMessage mutable := ASTNodeRef nil.
        currentPosition peek type = TokenType Keyword ifTrue: {
            firstChainKeywordMessage := self parseChainKeywordMessageIn: currentPosition
        }.

        ## Not chained message case.
        currentPosition peek type = TokenType Semicolon ifFalse: {
            firstChainKeywordMessage ifNil: {
                return: receiver
            }.

            Std assert: firstChainKeywordMessage isMessageChainMessageNode.

            let castedChain ref := (firstChainKeywordMessage rcObjectAddress castTo: ASTMessageChainMessageNode pointer) _.

            return: (ASTMessageSendNode new
                receiver: receiver;
                selector: castedChain selector;
                arguments: castedChain arguments;
                tokenRange: (startPosition until: currentPosition);
                upCastFor: ASTNode)
        }.

        ## Message chain case.
        let chainNode := ASTMessageChainNode new.

        firstChainKeywordMessage ifNotNil: {
            chainNode receiver: receiver.
            chainNode messages add: firstChainKeywordMessage.
        } ifNil: {
            ## Split the message on its parts.
            receiver isMessageSendNode ifTrue: {
                let firstMessage ref := (receiver rcObjectAddress castTo: ASTMessageSendNode pointer) _.

                let firstChain := ASTMessageChainMessageNode new
                    tokenRange: firstMessage tokenRange;
                    selector: firstMessage selector;
                    arguments: firstMessage arguments;
                    yourself.

                chainNode receiver: firstMessage receiver.
                chainNode messages add: (firstChain upCastFor: ASTNode).
            } ifFalse: {
                receiver isSingleMessageBinaryMessageSendSequenceNode ifTrue: {
                    let firstMessage ref := (receiver rcObjectAddress castTo: ASTBinaryMessageSendSequenceNode pointer) _.
                    Std assert: firstMessage selectors size = 1.
                    Std assert: firstMessage operands size = 2.

                    let firstChain := ASTMessageChainMessageNode new
                        tokenRange: firstMessage tokenRange;
                        selector: firstMessage selectors first;
                        addArgument: firstMessage operands second;
                        yourself.

                    chainNode receiver: firstMessage operands first.
                    chainNode messages add: (firstChain upCastFor: ASTNode).
                } ifFalse: {
                    chainNode receiver: receiver.
                }.
            }.
        }.

        while: currentPosition peek type = TokenType Semicolon do: {
            currentPosition advance.
            chainNode messages add: (self parseChainedMessageIn: currentPosition)
        }.

        chainNode
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.


    method parseLowPrecedenceExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        let receiver := self parseChainExpressionIn: currentPosition.
        currentPosition peek type = TokenType LowPrecedenceBinaryOperator ifFalse: {
            return: receiver.
        }.

        let result := ASTBinaryMessageSendSequenceNode new
            isLowPrecedence: true;
            yourself.
        result operands add: receiver.

        while: currentPosition peek type = TokenType LowPrecedenceBinaryOperator do: {
            let selectorPosition := (currentPosition until: 1).
            let rawSelectorValue := currentPosition next text.
            let selector := ASTSymbolLiteralNode new
                tokenRange: selectorPosition;
                value: (rawSelectorValue elements from: 2 until: rawSelectorValue size);
                yourself.

            let operand := self parseChainExpressionIn: currentPosition.

            result selectors add: (selector upCastFor: ASTNode).
            result operands add: operand.
        }.

        result
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseAssignmentExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        let receiver := self parseLowPrecedenceExpressionIn: currentPosition.
        currentPosition peek type = TokenType Assignment ifFalse: {
            return: receiver
        }.

        let selector := ASTSymbolLiteralNode new
            tokenRange: (currentPosition until: 1);
            value: ":=";
            yourself.
        currentPosition advance.
        let newValue := self parseAssignmentExpressionIn: currentPosition.

        ASTMessageSendNode new
            receiver: receiver;
            selector: (selector upCastFor: ASTNode);
            addArgument: newValue;
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseExpressionIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        currentPosition peek type = TokenType BitwiseXor ifTrue: {
            return: (self parseReturnExpressionIn: currentPosition)
        }.

        self parseAssignmentExpressionIn: currentPosition.
    }.

    method parseExpressionListIn: (currentPosition: TokenizedSourceCodeRange ref) until: (expectedDelimiter: TokenType) ::=> ASTNodeRef := {
        let result := ASTExpressionListNode new.
        let startPosition := currentPosition.

        do: {
            while: currentPosition peek type = TokenType Dot do: {
                currentPosition advance
            }.

            currentPosition peek type = expectedDelimiter ifFalse: {
                result expressions add: (self parseExpressionIn: currentPosition)
            }.
        } while: (currentPosition peek type = TokenType Dot).

        result
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseSequence: (sequence: ASTSequenceNode rcRef const ref) pragmasIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> Void := {
        let hasMetError mutable := false.
        while: hasMetError not && currentPosition peek type = TokenType LessThan do: {
            let pragma := self parsePragmaIn: currentPosition.
            sequence pragmas add: pragma.
            hasMetError := hasMetError || pragma isParseErrorNode.
        }.
    }.

    method parseLocalDeclarationIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.
        let local := ASTLocalDeclarationNode new.

        currentPosition peek type = TokenType LeftParent ifTrue: {
            local type: (self parseParentExpressionIn: currentPosition)
        }.

        local
            identifier: (self parseIdentifierOrMacroExpansionIn: currentPosition);
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseSequence: (sequence: ASTSequenceNode rcRef const ref) localsIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> Void := {
        currentPosition peek type = TokenType BitwiseOr ifFalse: {
            currentPosition peek type = TokenType GenericBinaryOperator && currentPosition peek text = "||" ifTrue: {
                currentPosition advance.
            }.

            return: void
        }.
        currentPosition advance.

        let hasMetError mutable := false.
        until: hasMetError || currentPosition peek type = TokenType BitwiseOr do: {
            let local := self parseLocalDeclarationIn: currentPosition.
            sequence locals add: local.
            hasMetError := hasMetError || local isParseErrorNode
        }.

        currentPosition peek type = TokenType BitwiseOr ifTrue: {
            currentPosition advance
        } ifFalse: {
            hasMetError ifFalse: {
                sequence locals add: (ASTParseErrorNode atToken: currentPosition message: "Expected '|' after the local declarations'." asMutableString).
            }
        }
    }.

    method parseSequenceIn: (currentPosition: TokenizedSourceCodeRange ref) until: (expectedDelimiter: TokenType) ::=> ASTNodeRef := {
        let sequence := ASTSequenceNode new.
        let startPosition := currentPosition.

        ## Parse the pragmas.
        self parseSequence: sequence pragmasIn: currentPosition.

        ## Parse the locals
        self parseSequence: sequence localsIn: currentPosition.

        ## Parse more pragmas.
        self parseSequence: sequence pragmasIn: currentPosition.

        do: {
            while: currentPosition peek type = TokenType Dot do: {
                currentPosition advance
            }.

            currentPosition peek type = expectedDelimiter ifFalse: {
                sequence expressions add: (self parseExpressionIn: currentPosition)
            }.
        } while: (currentPosition peek type = TokenType Dot).

        sequence
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parse: (tokenizedSource: TokenizedSourceCodeRef const ref) ::=> ASTNodeRef := {
        let currentPosition mutable := TokenizedSourceCodeRange for: tokenizedSource.
        let result := self parseSequenceIn: currentPosition until: TokenType EndOfSource.

        currentPosition peek type isEndOfSource ifFalse: {
            (result rcObjectAddress castTo: ASTExpressionListNode pointer) _
                expressions add: (ASTParseErrorNode atToken: currentPosition message: "Expected the end of the source." asMutableString).
        }.

        result
    }.

    method parseSourceWithLiteralArrayContentIn: (currentPosition: TokenizedSourceCodeRange ref) ::=> ASTNodeRef := {
        let startPosition := currentPosition.

        let result := ASTLiteralArrayNode new.
        let hasMetError mutable := false.
        until: hasMetError || currentPosition peek type isEndOfSource do: {
            let element := self parseLiteralArrayElementIn: currentPosition.
            result elements add: element.
            hasMetError := element isParseErrorNode
        }.

        currentPosition peek type isEndOfSource ifFalse: {
            hasMetError ifFalse: {
                result elements add: (ASTParseErrorNode atToken: currentPosition message: "Expected the end of the source." asMutableString).
            }.
        }.

        result
            tokenRange: (startPosition until: currentPosition);
            upCastFor: ASTNode
    }.

    method parseLiteralArrayContent: (tokenizedSource: TokenizedSourceCodeRef const ref) ::=> ASTNodeRef := {
        let currentPosition mutable := TokenizedSourceCodeRange for: tokenizedSource.
        self parseSourceWithLiteralArrayContentIn: currentPosition
    }.
}.

}. ## End of namespace SmalltalkLanguage
}. ## End of namespace Compiler
}. ## End of namespace Sysmel
