// Main function
struct SomeStruct := {
    field first type: Float32.
    field second type: Float64.
}.

namespace Math definition: {
template Vector3(S: Type) := struct definition: {
    alias Scalar := S.
    alias Vector3F := Vector3(Float32).
    alias Vector3D := Vector3(Float64).

    field x public type: Scalar.
    field y public type: Scalar.
    field z public type: Scalar.

    meta message x: (x: Scalar) y: (y: Scalar) z: (z: Scalar) ::-> SelfType := {
        return: (SelfType newValue
            x: x;
            y: y;
            z: z;
            yourself
        )
    }.

    message + (o: SelfType) ::-> SelfType := {
        return: (SelfType newValue
            x: x + o x;
            y: y + o y;
            z: z + o z;
            yourself
        )
    }.

    message asVector3D ::-> Vector3D := {
        return: (Vector3D newValue x: x; y: y; z: z; yourself)
    }.

    message asVector3F ::-> Vector3F := {
        return: (Vector3F newValue
            x: (x castTo: Float32);
            y: (y castTo: Float32);
            z: (z castTo: Float32);
            yourself)
    }.
}.

alias Vector3F := Vector3(Float32).
alias Vector3D := Vector3(Float64).
}.

function main externC (argc: Int32, argv: Char const pointer pointer) -> Int32 := {
    let v3f := Math Vector3F x: 1.0 y: 2.0 z: 3.0.
    CStdLib printf("v3f %f %f %f\n", v3f x, v3f y, v3f z).

    let v3d := v3f asVector3D.
    CStdLib printf("v3d %f %f %f\n", v3d x, v3d y, v3d z).

    let i := 1.
    CStdLib printf("i address: %p\n", i address).
    until: i >= argc do: {
        if: i = 1 then: {
            CStdLib printf("First ").
        } else: {
            CStdLib printf("Not first ").
        }.

        CStdLib printf("argv %d %p %p: %s\n", i, argv[i] address, argv + i, argv[i]).
    } continueWith: {i := i + 1}.

    CStdLib printf("Hello World: %s\n", argv value).
    return: 0.
}.
