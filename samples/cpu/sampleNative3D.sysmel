useNamespace: SDL2.

class TriangleShader definition: {
    let triangleVertices type: (Float32x4 array: 3) := (
        Float32x4(-1.0f, 1.0f, 0.0f, 1.0f),
        Float32x4(1.0f, 1.0f, 0.0f, 1.0f),
        Float32x4(0.0f, -1.0f, 0.0f, 1.0f)
    ).

    let triangleColors type: (Float32x4 array: 3) := (
        Float32x4(1.0f, 0.0f, 0.0f, 1.0f),
        Float32x4(0.0f, 1.0f, 0.0f, 1.0f),
        Float32x4(0.0f, 0.0f, 1.0f, 1.0f)
    ).

    class VertexOutput superclass: GPU VertexStageOutput; definition: {
        public field color type: Float32x4; location: 0.
        public field screenPosition type: Float32x4; intrinsic: #position.
    }.

    class FragmentInput definition: {
        public field color type: Float32x4; location: 0.
    }.

    class FragmentOutput definition: {
        public field color type: Float32x4; location: 0.
    }.

    function triangleVertex vertexShader externC(stageIn: GPU VertexStageInput inputChannel, stageOut: VertexOutput outputChannel) => Void := {
        let input := stageIn receive.

        stageOut send: (VertexOutput newValue
            screenPosition: triangleVertices[input vertexID];
            color: triangleColors[input vertexID];
            yourself
        ).
    }.

    function triangleFragment fragmentShader externC(stageIn: FragmentInput inputChannel, stageOut: FragmentOutput outputChannel) => Void := {
        let input := stageIn receive.

        stageOut send: (FragmentOutput newValue
            color: input color
        )
    }.
}.

class Application definition: {
    field window type: SDL_Window pointer.
    field renderer type: SDL_Renderer pointer.
    field isQuitting type: Boolean8.

    field screenWidth type: UInt32.
    field screenHeight type: UInt32.

    field device type: AGPU DeviceRef.
    field commandQueue type: AGPU CommandQueueRef.
    field swapChain type: AGPU SwapChainRef.

    field mainRenderPass type: AGPU RenderpassRef.
    field commandAllocator type: AGPU CommandAllocatorRef.
    field commandList type: AGPU CommandListRef.

    field shaderModule type: AGPU ShaderRef.
    field shaderSignature type: AGPU ShaderSignatureRef.
    field pipelineState type: AGPU PipelineStateRef.

    method onKeyDown: (event: SDL_KeyboardEvent ref) ::=> Void := {
    	event keysym sym selectCase: #{
    	Keycode SDLK_ESCAPE : {isQuitting := true.}.
    	}.
    }.

    method onKeyUp: (event: SDL_KeyboardEvent ref) ::=> Void := {
    	event keysym sym selectCase: #{
    	}.
    }.

    method processEvents => Void := {
    	let event mutable type: SDL_Event.

    	while: SDL_PollEvent(event address) do: {
    		event type selectCase: #{
    		SDL_EventType SDL_QUIT : { isQuitting := true }.
    		SDL_EventType SDL_KEYDOWN : { self onKeyDown: event key }.
    		SDL_EventType SDL_KEYUP  : { self onKeyUp: event key }.
    		}.
    	}
    }.

    method update: (delta: Float32) ::=> Void := {

    }.

    method render => Void := {
        commandAllocator _ reset.
        commandList _ reset: commandAllocator initialPipelineState: AGPU PipelineStateRef nil.

        let backBuffer := swapChain _ getCurrentBackBuffer.
        commandList _
            setShaderSignature: shaderSignature;

            beginRenderPass: mainRenderPass framebuffer: backBuffer bundleContent: 0;
            setViewport: 0 y: 0 w: (screenWidth castTo: Int32) h: (screenHeight castTo: Int32);
            setScissor: 0 y: 0 w: (screenWidth castTo: Int32) h: (screenHeight castTo: Int32);

            usePipelineState: pipelineState;
            drawArrays: 3 instanceCount: 1 firstVertex: 0 baseInstance: 0;

            endRenderPass.

        commandList _ close.

        commandQueue _ addCommandList: commandList.
        swapChain _ swapBuffers.
        commandQueue _ finishExecution.
    }.

    method run => Int32 := {
        screenWidth := 640.
        screenHeight := 480.

        ## Find the platform.
        let agpuPlatform mutable type: AGPU Platform pointer.
        AGPU agpuGetPlatforms(1, agpuPlatform address, nil).
        agpuPlatform ifNil: {
            StdNative stderr << "Failed to get AGPU platform"; nl.
            return: 1.
        }.

        ## Initialize SDL.
        SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_GAMECONTROLLER) < 0 ifTrue: {
            StdNative stderr << "Failed to initialize SDL2. "; nl.
    		return: 1.
    	}.

    	window := SDL_CreateWindow("Sysmel SDL2 AGPU example", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, screenWidth castTo: Int32, screenHeight castTo: Int32, SDL_WINDOW_SHOWN).
    	window ifNil: {
            StdNative stderr << "Failed to create the window: "; nl.
    		return: 1.
    	}.

        ## Create the device.
        {
            ## Get the window info.
            let windowInfo mutable type: SDL_SysWMinfo.
            windowInfo version setCurrent.
            SDL_GetWindowWMInfo(window, windowInfo address).

            ## Setup the swap chain creation, and the device open info.
            let swapChainCreateInfo mutable type: AGPU SwapChainCreateInfo.
            let deviceOpenInfo mutable type: AGPU DeviceOpenInfo.

            windowInfo subsystem selectCase: #{
            SDL_SYSWM_WINDOWS : {
                swapChainCreateInfo window: windowInfo info win window.
            }.
            SDL_SYSWM_X11 : {
                deviceOpenInfo display: windowInfo info x11 display.
                swapChainCreateInfo window: windowInfo info x11 window.
            }.
            SDL_SYSWM_COCOA : {
                swapChainCreateInfo window: windowInfo info cocoa window.
            }.
            let _ : {
                StdNative stderr << "Unsupported window system"; nl.
                return: 1
            }.
            }.

            swapChainCreateInfo
                colorbuffer_format: AGPU TextureFormat B8G8R8A8_UNorm;
                depth_stencil_format: AGPU TextureFormat D32_Float_S8X24_UInt;
                width: screenWidth;
                height: screenHeight;
                buffer_count: 3.

            deviceOpenInfo debug_layer: 1.

            ## Open device.
            device := agpuPlatform _ openDevice: deviceOpenInfo address.
            device ifNil: {
                StdNative stderr << "Failed to open the device"; nl.
                return: 1
            }.

            ## Get the default command queue.
            commandQueue := device _ getDefaultCommandQueue.

            ## Create the swap chain.
            swapChain := device _ createSwapChain: commandQueue swapChainInfo: swapChainCreateInfo address.
            swapChain ifNil: {
                StdNative stderr << "Failed to create the swap chain."; nl.
                return: 1
            }.

            ## Create the shader module.
            {
                let moduleInfo := TriangleShader triangleVertex shaderEntryPointInfo moduleInfo.

                shaderModule := device _ createShader: AGPU ShaderType Library.
                shaderModule _
                    setShaderSource: AGPU ShaderLanguage SpirV sourceText: (moduleInfo _ blobStartPointer reinterpretCastTo: Char8 const pointer)
                        sourceTextLength: moduleInfo _ blobSize;
                        compileShader: "".

                ## TODO: Handle shader compilation errors.
            }.

            ## Create the shader signature.
            {
                let builder := device _ createShaderSignatureBuilder.
                shaderSignature := builder _
                    build
            }.

            ## Create the pipeline state object.
            {
                let builder := device _ createPipelineBuilder.
                pipelineState :=
                    builder _
                    setShaderSignature: shaderSignature;
                    attachShaderWithEntryPoint: shaderModule type: AGPU ShaderType Vertex entryPoint: TriangleShader triangleVertex shaderEntryPointInfo entryPointSymbol;
                    attachShaderWithEntryPoint: shaderModule type: AGPU ShaderType Fragment entryPoint: TriangleShader triangleFragment shaderEntryPointInfo entryPointSymbol;
                    setPrimitiveType: AGPU PrimitiveTopology Triangles;
                    build
            }.

            ## Create the main render pass.
            {
                ## Color attachment
                let colorAttachment mutable type: AGPU RenderpassColorAttachmentDescription.
                colorAttachment
                    format: AGPU TextureFormat B8G8R8A8_UNorm;
                    begin_action: AGPU RenderpassAttachmentAction Clear;
                    end_action: AGPU RenderpassAttachmentAction Keep;
                    sample_count: 1.
                colorAttachment clear_value r: 0.0f; g: 0.0f; b: 0.0f; a: 0.0f.

                ## Depth stencil
                let depthStencil mutable type: AGPU RenderpassDepthStencilDescription.
                depthStencil
                    format: AGPU TextureFormat D32_Float_S8X24_UInt;
                    begin_action: AGPU RenderpassAttachmentAction Clear;
                    end_action: AGPU RenderpassAttachmentAction Keep;
                    sample_count: 1.
                depthStencil clear_value depth: 1.0f.

                let description mutable type: AGPU RenderpassDescription.
                description
                    color_attachment_count: 1;
                    color_attachments: colorAttachment address;
                    depth_stencil_attachment: depthStencil address.

                mainRenderPass := device _ createRenderPass: description address.
            }.

            ## Create the command allocator and the command list.
            commandAllocator := device _ createCommandAllocator: AGPU CommandListType Direct queue: commandQueue.
            commandList := device _ createCommandList: AGPU CommandListType Direct allocator: commandAllocator initialPipelineState: AGPU PipelineStateRef nil.
            commandList _ close.
        }.

    	let oldTicks mutable := SDL_GetTicks().
    	let updateDelta := 1.0 / 60.0 castTo: Float32.
    	let accumulatedTime mutable type: Float32 := 0.0.
    	until: isQuitting do: {
    		let newTicks := SDL_GetTicks().
    		let deltaTicks := newTicks - oldTicks.
    		accumulatedTime := accumulatedTime + deltaTicks *0.001 castTo: Float32.

    		## Process the event.
    		self processEvents.

    		## Deterministic update.
    		##StdNative stdout << "deltaTicks " << deltaTicks; nl.
    		##StdNative stdout << "accumulatedTime " << accumulatedTime; nl.
    		while: accumulatedTime - updateDelta >= updateDelta  do: {
    			##StdNative stdout << "update iter "; nl.
    			self update: updateDelta.
    			accumulatedTime := accumulatedTime - updateDelta
    		}.

    		## Perform the actual rendering.
    		self render.

    		## Compute the sleep time to achieve 60 fps.
    		let targetTicks := newTicks + 16 - (accumulatedTime castTo: UInt32).
    		let renderEndTicks := SDL_GetTicks().
    		renderEndTicks < targetTicks ifTrue: {
    			let delayTicks := targetTicks - renderEndTicks - 2 castTo: Int32.
    			##StdNative stdout << "delayTicks " << delayTicks; nl.
    			delayTicks > 0 ifTrue: {
    				SDL_Delay(delayTicks castTo: UInt32).
    			}
    		}.
    		oldTicks := newTicks.
    	}.

        device _ finishExecution.
        swapChain reset.
    	SDL_DestroyWindow(window).
    	SDL_Quit().

        return: 0
    }.
}.

function main externC (argc: Int32, argv: Char8 const pointer pointer) => Int32 := {
    let app mutable type: Application.
    return: app run.
}.
