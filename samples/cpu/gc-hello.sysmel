## Main function

global testGlobal mutable := 42.

function printValue(value: Int32) => Void := {
    Stdn stdout << "printValue Int32: " << value; nl.
}.

function printValue(value: Float32) => Void := {
    Stdn stdout << "printValue Float32: " << value; nl.
}.

function testNativeErrorThrow() => Void := {
    Stdn error: "Test error"
}.

function testNativeError() => Void := {
    try: {
        testNativeErrorThrow().
    } catch: Stdn Error doing: {:exception :: Void |
        Stdn stdout << "Caught error exception: " << exception; nl.
    }.
}.

function testSmalltalkErrorThrow() => Void := {
    Smalltalk Object error: "Test smalltalk error".
}.

function testGCError() => Void := {
    try: {
        testSmalltalkErrorThrow().
    } catch: Smalltalk Error doing: {:exception :: Void |
        Stdn stdout << "Caught Smalltalk exception: " << exception; nl.
    }.
}.

function testNonLocalReturn() => Void := {
    let array type: Smalltalk ProtoObject := #(1 2 3 4 5).
    Stdn stdout << "Should print until 3"; nl.
    array do: {:(Smalltalk ProtoObject)v :: Void |
        Stdn stdout << v; nl.
        v == 3 ifTrue: {
            Stdn stdout << "Found 3, do non-local return."; nl.
            return: nil
        }.
    }.
}.

function testWriteFile() => Void := {
    let outFile mutable type: Stdn IO FileStream.
    (outFile open: "test.txt" mode: Stdn IO FileOpenMode CreateNew) ifTrue: {
        let out mutable := Stdn IO TextStreamWriter for: outFile address.
        out << "Hello World"; nl.
        out << "File written from sysmel"; nl.
        outFile close
    }.
}.

function testMessageNotUnderstood() => Void := {
    try: {
        Smalltalk Object someMessageThatIsNotImplemented: #hello with: #world and: 42
    } catch: Smalltalk MessageNotUnderstood doing: {:exception :: Void |
        Stdn stdout << "Caught message not understood exception: " << exception; nl.
    }.
}.

Stdn MainEntryPoint: {:args :: Int32 |
    Stdn stdout << "testGlobal " << testGlobal; nl.
	Stdn stdout << "TestChar " << 'c'; nl.

    ##let s type: SomeStruct.

    1 to: 3 do: {:i :: Void |
        Stdn stdout << "Loop iteration " << i; nl
    }.

    let v3f := Float32x3 x: 1.0 y: 2.0 z: 3.0.
    Stdn stdout << "v3f " << v3f; nl.

    let vp := v3f + (Float32x3 x: 4.0 y: 5.0 z: 6.0).
    Stdn stdout << "vp " << v3f; nl.

    let vps := v3f + 3.0.
    Stdn stdout << "vps " << v3f; nl.

    let v3d := Float64x3 x: v3f x y: v3f y z: v3f z.
    Stdn stdout << "v3d " << v3f; nl.

    ##let matrix := Float32x3x3 identity + Float32x3x3 identity.
    ##let matrix := Float32x3x3 ones * Float32x3x3 ones.
    let matrix := Float32x3x3 rowMajorIndices.
    ##let matrix mutable := Float32x3x3 identity + Float32x3x3 identity.
    Stdn stdout nextPutAll: "zm "; nl;
	tab; print: matrix firstRow; nl;
	tab; print: matrix secondRow; nl;
	tab; print: matrix thirdRow; nl.

    let mv3f := matrix * v3f.
    Stdn stdout << "mv3f " << mv3f; nl.

    let v3fm := v3f * matrix.
    Stdn stdout << "v3fm " << v3fm; nl.
    Stdn stdout << "v3f dot: v3f" << (v3f dot: v3f); nl.

    let v3fc := v3f cross: v3f.
    Stdn stdout << "v3fc cross: v3f " << v3fc; nl.

    printValue(1).
    printValue(1.0).

    1 until: args size do: {:i :: Void |
        i = 1 ifTrue: {
            Stdn stdout << "First "
        } ifFalse: {
            Stdn stdout << "Not first "

        }.

        Stdn stdout << "args[" << i << "] " << (args[i] reinterpretCastTo: Void pointer) << ": " << args[i]; nl
    }.

    Stdn stdout << "Hello World: " << args first; nl.

    Stdn stdout << "Object: " << (Smalltalk Object reinterpretCastTo: Void pointer); nl.
    Stdn stdout << "Object class: " << (Smalltalk Object class reinterpretCastTo: Void pointer); nl.

    useNamespace: Smalltalk.

    let o := Object.
    Stdn stdout << "o: " << (o reinterpretCastTo: Void pointer) << " " << o; nl.
    Stdn stdout << "o class: " << (o class reinterpretCastTo: Void pointer) << " " << o class; nl.
    Stdn stdout << "Object basicNew: " << Object basicNew; nl.

	let n mutable type: ProtoObject := 42.
	let sumResult := n + 7.
    Stdn stdout << "(ProtoObject)42 + (ProtoObject)7 = " << sumResult; nl.

    let boolValue := true.
    let boolCast type: ProtoObject := boolValue.
    Stdn stdout << "Bool cast " << (boolCast reinterpretCastTo: Void pointer) << " " << boolCast; nl.

	let testArray type: ProtoObject := #("Hello world" 1 #symbol 2 3 4 5).
	testArray do: {:(ProtoObject)el :: Void |
	    Stdn stdout << "Array element " << el; nl.
	}.

    Stdn stdout << "Printing ProtoObject with all subclasses"; nl.
    ProtoObject withAllSubclassesDo: {:(ProtoObject)cls :: Void |
	    Stdn stdout << cls; nl.
	}.

    {
        let string type: ProtoObject := "class".
        let symbol := string asSymbol.

        Stdn stdout << "String '"  << string << "' asSymbol #'" << symbol << "' unique: " << (symbol == #class) << " sameResult: " << (symbol == string asSymbol); nl.
    }.

    testNativeError().
    testNonLocalReturn().
    testGCError().
    testWriteFile().
    testMessageNotUnderstood().

    Stdn stdout << (__global Smalltalk Object name -- " with concat"); nl.
    Stdn stdout << (__global Smalltalk Object name -- " with concat") asStdnMutableString; nl.

    Stdn stdout << "Printing Smalltalk global values"; nl.
    let nspace := (__global Smalltalk castTo: ProtoObject) sharedNamespace.
    nspace associations do: {:each :: Void |
        Stdn stdout << each; nl.
    }.


    return: 0.
}.
