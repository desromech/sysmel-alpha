useNamespace: SDL2.

global window mutable type: SDL_Window pointer.
global renderer mutable type: SDL_Renderer pointer.
global isQuitting mutable := false.

struct Box2D definition: {
	public field min type: Float32x2.
	public field max type: Float32x2.

	meta message center: (center: Float32x2) halfExtent: (halfExtent: Float32x2) ::=> SelfType
		:= SelfType newValue
			min: center - halfExtent;
			max: center + halfExtent;
			yourself.

	message extent => Float32x2
		:= max - min.

	message halfExtent => Float32x2
		:= (max - min) * 0.5.

	message center => Float32x2
		:= (max + min) * 0.5.
}.

class Character definition: {
	public field position type: Float32x2.
	public field velocity type: Float32x2.
	public field halfExtent type: Float32x2.

	message boundingBox => Box2D
		:= Box2D center: position halfExtent: halfExtent.
}.

class Player superclass: Character; definition: {
	public field speed type: Float32.
	public field direction type: Float32x2.

	message initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		self walk
	}.

	message walk => Void := {
		speed := 1.0
	}.

	message run => Void := {
		speed := 3.0
	}.

	message simulate: (delta: Float32) ::=> Void := {
		velocity := direction * speed.

		position := position + velocity * delta.
	}.
}.

global characters mutable type: (StdNative OrderedCollection(Character pointer)).

global player mutable type: Player pointer.
global viewMatrix mutable type: Float32x2x3.

function onKeyDown(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ direction x: -1.0}.
	Keycode SDLK_d : {player _ direction x: 1.0}.
	Keycode SDLK_s : {player _ direction y: -1.0}.
	Keycode SDLK_w : {player _ direction y: 1.0}.
	Keycode SDLK_LSHIFT : {player _ run}.
	}.
}.

function onKeyUp(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ direction x < 0.0 ifTrue: {player _ direction x: 0.0}}.
	Keycode SDLK_d : {player _ direction x > 0.0 ifTrue: {player _ direction x: 0.0}}.
	Keycode SDLK_s : {player _ direction y < 0.0 ifTrue: {player _ direction y: 0.0}}.
	Keycode SDLK_w : {player _ direction y > 0.0 ifTrue: {player _ direction y: 0.0}}.
	Keycode SDLK_LSHIFT : {player _ walk}.
	}.
}.

function processEvents() => Void := {
	let event mutable type: SDL_Event.

	while: SDL_PollEvent(event address) do: {
		event type selectCase: #{
		SDL_EventType SDL_QUIT : { isQuitting := true }.
		SDL_EventType SDL_KEYDOWN : { onKeyDown(event key) }.
		SDL_EventType SDL_KEYUP  : { onKeyUp(event key) }.
		}.
	}
}.

function drawCharacter(character: Character ref) => Void := {
	let boundingBox := character boundingBox.
	let min := viewMatrix * Float32x3(boundingBox min, 1.0) castTo: Int32x2.
	let max := viewMatrix * Float32x3(boundingBox max, 1.0) castTo: Int32x2.
	let extent := max - min.

	let rect mutable := SDL_Rect newValue
		x: (min x);
		y: (max y);
		w: (extent x);
		h: (-extent y).
	SDL_SetRenderDrawColor(renderer, 128, 128, 0, 255).
	SDL_RenderFillRect(renderer, rect address).
}.

function update(delta: Float32) => Void := {
	player _ simulate: delta.
}.

function render() => Void := {
	## Clear the screen.
	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255).
	SDL_RenderClear(renderer).

	## Compute the view matrix
	{
		let viewScale := 1.0 / 10.0 castTo: Float32.
		viewMatrix := Float32x2x3(
			Float32x2(640.0*viewScale, 0.0),
			Float32x2(0.0, -480.0*viewScale),
			Float32x2(320, 240)
		).
	}.

	drawCharacter(player _).

	SDL_RenderPresent(renderer).
}.

function main externC (argc: Int32, argv: Char8 const pointer pointer) => Int32 := {

	SDL_Init(SDL_INIT_VIDEO) < 0 ifTrue: {
		return: 1.
	}.

	window := SDL_CreateWindow("Test window", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_SHOWN).
	window ifNil: {
		return: 1.
	}.

	renderer := SDL_CreateRenderer(window, -1, SDL_RENDERER_PRESENTVSYNC).
	renderer ifNil: {
		return: 1.
	}.
	
	player := Player nativeNew.
	characters add: player.

	let oldTicks mutable := SDL_GetTicks().
	let updateDelta := 1.0 / 60.0 castTo: Float32.
	let accumulatedTime mutable type: Float32 := 0.0.
	until: isQuitting do: {
		let newTicks := SDL_GetTicks().
		let deltaTicks := newTicks - oldTicks.
		accumulatedTime := accumulatedTime + deltaTicks *0.001 castTo: Float32.

		## Process the event.
		processEvents().

		## Deterministic update.
		##StdNative stdout << "deltaTicks " << deltaTicks; nl.
		##StdNative stdout << "accumulatedTime " << accumulatedTime; nl.
		while: accumulatedTime - updateDelta >= updateDelta  do: {
			##StdNative stdout << "update iter "; nl.
			update(updateDelta).
			accumulatedTime := accumulatedTime - updateDelta
		}.

		## Perform the actual rendering.
		render().

		## Compute the sleep time to achieve 60 fps.
		let targetTicks := newTicks + 16 - (accumulatedTime castTo: UInt32).
		let renderEndTicks := SDL_GetTicks().
		renderEndTicks < targetTicks ifTrue: {
			let delayTicks := targetTicks - renderEndTicks - 2 castTo: Int32.
			##StdNative stdout << "delayTicks " << delayTicks; nl.
			delayTicks > 0 ifTrue: {
				SDL_Delay(delayTicks castTo: UInt32).
			}
		}.
		oldTicks := newTicks.
	}.

	SDL_DestroyRenderer(renderer).
	SDL_DestroyWindow(window).
	SDL_Quit().

    return: 0.
}.
