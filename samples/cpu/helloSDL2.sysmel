useNamespace: SDL2.

let Gravity := Float32x2(0.0, -9.8).
global window mutable type: SDL_Window pointer.
global renderer mutable type: SDL_Renderer pointer.
global isQuitting mutable := false.

global audioMutex mutable type: StdNative Mutex.
global audioDeviceID mutable type: SDL_AudioDeviceID.
global audioDeviceSpec mutable type: SDL_AudioSpec.
global audioTemporaryBuffer mutable type: Float32x2 pointer.

struct Box2D definition: {
	public field min type: Float32x2.
	public field max type: Float32x2.

	meta method center: (center: Float32x2) halfExtent: (halfExtent: Float32x2) ::=> SelfType
		:= SelfType newValue
			min: center - halfExtent;
			max: center + halfExtent;
			yourself.

	method extent => Float32x2
		:= max - min.

	method halfExtent => Float32x2
		:= (max - min) * 0.5.

	method center => Float32x2
		:= (max + min) * 0.5.

	method containsPoint: (point: Float32x2) ::=> Boolean8
		:= min x <= point x && point x <= max x &&
		   min y <= point y && point y <= max x.

	method hasIntersectionWithRayOrigin: (rayOrigin: Float32x2) direction: (rayDirection: Float32x2) at: (intersectionT: Float32 pointer) ::=> Boolean8 := {
		## Ray box intersection algorithm from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection
		let directionReciprocal := 1.0f / rayDirection.
		let tNegative := (min - rayOrigin) * directionReciprocal.
		let tPositive := (max - rayOrigin) * directionReciprocal.

		let tmin := tNegative min: tPositive.
		let tmax := tNegative max: tPositive.

		(tmin x > tmax y || tmin y > tmax x) ifTrue: {
			false
		} ifFalse: {
			intersectionT _ := (tmin x max: tmin y) max: 0.0f.
			tmin x >= 0.0f || tmin y >= 0.0f
		}
	}.

	method computePenetrationDistanceForPoint: (point: Float32x2) withNormal: (normal: Float32x2) ::=> Float32 := {
		let delta := point - self center.
		((self halfExtent - delta) dot: normal) max: 0.0
	}.

	method computeCollisionNormalForPoint: (point: Float32x2) ::=> Float32x2 := {
		let delta := point - self center.
		let deltaAbsolute := delta abs / self halfExtent.
		deltaAbsolute x >= deltaAbsolute y ifTrue: {
			Float32x2(delta x sign, 0.0f)
		} ifFalse: {
			Float32x2(0.0f, delta y sign)
		}
	}.
}.

class Entity definition: {
	public field position type: Float32x2.
	public field halfExtent type: Float32x2.
	public field color type: Float32x4.

	method boundingBox => Box2D
		:= Box2D center: position halfExtent: halfExtent.

	method boundingBoxExpandedWith: (extraHalfExtent: Float32x2) ::=> Box2D
		:= Box2D center: position halfExtent: halfExtent + extraHalfExtent.

	virtual method hasCollisionResponse => Boolean8
		:= true.

	virtual method render => Void := {
		fillRectangle(self boundingBox, color).
	}.

	virtual method update: (delta: Float32) ::=> Void := {
	}.
}.

class Wall superclass: Entity; definition: {

}.

class Character superclass: Entity; definition: {
	public field velocity type: Float32x2.
	field isOnFloor type: Boolean8.

	override method hasCollisionResponse => Boolean8
		:= false.

	method sweepCollidingFrom: (oldPosition: Float32x2) into: (targetPosition: Float32x2) maxDepth: (maxDepth: UInt32)::=> Void := {
		maxDepth = 0 ifTrue: { return: nil. }.

		## Compute the ray direction and length.
		let rayOrigin := oldPosition.
		let rayDirection mutable := targetPosition - position.
		let rayLength := rayDirection length2 sqrt.##rayDirection length.
		rayLength < 0.00001f ifTrue: { return: nil }.
		rayDirection := rayDirection / rayLength.

		## Perform Minkowski difference based collision detection with the boxes.
		let bestCollisionAlpha mutable := rayLength.
		let bestCollisionEntity mutable type: Entity pointer := nil.
		let bestCollisionExpandedBound mutable type: Box2D.

		entities do: {:(Entity pointer)entity :: Void |
			## FIXME: Make this cast redundant.
			entity ~~ (self address castTo: Entity pointer) && entity _ hasCollisionResponse ifTrue: {
				let entityExpandedBoundingBox mutable := entity _ boundingBoxExpandedWith: halfExtent.
				let intersectionAlpha mutable type: Float32.
				(entityExpandedBoundingBox hasIntersectionWithRayOrigin: rayOrigin direction: rayDirection at: intersectionAlpha address) ifTrue: {
					intersectionAlpha < rayLength ifTrue: {
						bestCollisionExpandedBound := entityExpandedBoundingBox.
						bestCollisionAlpha := intersectionAlpha.
						bestCollisionEntity := entity
					}.
				}.
			}.
		}.

		bestCollisionAlpha < rayLength ifTrue: {
			let collisionPoint := rayOrigin + bestCollisionAlpha*rayDirection.
			let remainingDelta := (rayLength - bestCollisionAlpha)*rayDirection.

			let collisionNormal := bestCollisionExpandedBound computeCollisionNormalForPoint: collisionPoint.
			let penetrationDistance := bestCollisionExpandedBound computePenetrationDistanceForPoint: collisionNormal withNormal: collisionNormal.
			let slidingDelta := remainingDelta - (remainingDelta dot: collisionNormal)*collisionNormal.

			isOnFloor := isOnFloor || collisionNormal y > 0.0.
			velocity := velocity - (velocity dot: collisionNormal)*collisionNormal.
			position := collisionPoint + collisionNormal*(penetrationDistance*0.1f).

			self sweepCollidingFrom: position into: position + slidingDelta maxDepth: maxDepth - 1.
		} ifFalse: {
			position := targetPosition
		}.

	}.

	override method update: (delta: Float32) ::=> Void := {
		velocity := velocity + Gravity * delta.
		let newPosition := position + velocity * delta.

		isOnFloor := false.
		self sweepCollidingFrom: position into: newPosition maxDepth: 5.
	}.
}.

class Enemy superclass: Character; definition: {
	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.1, 0.1, 1.0).
	}.
}.

class Player superclass: Character; definition: {
	public field speed type: Float32.
	public field direction type: Float32x2.

	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.5, 0.2, 1.0).
		self walk
	}.

	method walk => Void := {
		speed := 1.0
	}.

	method run => Void := {
		speed := 3.0
	}.

	method jump => Void := {
		isOnFloor ifTrue: {
			velocity y: 10.0.
		}.
	}.

	method shoot => Void := {

	}.

	override method update: (delta: Float32) ::=> Void := {
		velocity x: direction x * speed.

		super update: delta
	}.
}.

class SoundChannel definition: {
	virtual method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		## By default do nothing.
	}.
}.

class NoiseChannel; superclass: SoundChannel; definition: {
	public field amplitude type: Float32.

	field currentSampleIndex type: UInt32.

	field randomState type: UInt64.

	method nextRandomSample => Float32 := {
		randomState = 0 ifTrue: {randomState := 1}.

		## Xor shift generator.
		## https://en.wikipedia.org/wiki/Xorshift [January 3th, 2020]
		let x mutable := randomState.
		x := x ^ (x << 13).
		x := x ^ (x >> 7).
		x := x ^ (x << 17).
		randomState := x.

		let unormValue := (randomState castTo: Float64) / 18446744073709551615.0.
		unormValue*2.0 - 1.0 castTo: Float32
	}.

	override method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		## Mix the samples
		0 until: sampleCount do: {:(UInt32)i :: Void |
			##let absoluteSampleTime := (currentSampleIndex + i)*samplePeriod.
			let sample := self nextRandomSample * amplitude.
			mixBuffer[i] := mixBuffer[i] + sample
		}.

		currentSampleIndex := currentSampleIndex + sampleCount.
	}.
}.

template ToneFunctionSoundChannel(toneFunction: _FunctionType ref)
	:= class superclass: SoundChannel; definition: {
	public field amplitude type: Float32.
	public field frequency type: Float32.
	public field phase type: Float32.
	public field extraParam type: Float32.

	field currentSampleIndex type: UInt32.

	override method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		## Mix the samples
		0 until: sampleCount do: {:(UInt32)i :: Void |
			let absoluteSampleTime := (currentSampleIndex + i)*samplePeriod.
			let sample := toneFunction(absoluteSampleTime * frequency + phase, extraParam) * amplitude.
			mixBuffer[i] := mixBuffer[i] + sample
		}.

		currentSampleIndex := currentSampleIndex + sampleCount.
	}.
}.

compileTimeConstant SineChannel := ToneFunctionSoundChannel(
	function(x: Float32, _: Float32) => Float32
		:= (x * Float32 twoPi) sin
).

compileTimeConstant PulseChannel := ToneFunctionSoundChannel(
	function(x: Float32, pulseWidth: Float32) => Float32
		:= (x fract stepValue: pulseWidth)*2.0f - 1.0f
).

compileTimeConstant SawChannel := ToneFunctionSoundChannel(
	function(x: Float32, _: Float32) => Float32
		:= x fract*2.0f - 1.0f
).

global entities mutable type: (StdNative OrderedCollection(Entity pointer)).
global soundChannels mutable type: (StdNative OrderedCollection(SoundChannel pointer)).

global player mutable type: Player pointer.
global viewMatrix mutable type: Float32x2x3.

function onKeyDown(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ direction x: -1.0}.
	Keycode SDLK_d : {player _ direction x: 1.0}.
	Keycode SDLK_w : {player _ jump}.
	Keycode SDLK_SPACE : {player _ shoot}.
	Keycode SDLK_LSHIFT : {player _ run}.
	}.
}.

function onKeyUp(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ direction x < 0.0 ifTrue: {player _ direction x: 0.0}}.
	Keycode SDLK_d : {player _ direction x > 0.0 ifTrue: {player _ direction x: 0.0}}.
	Keycode SDLK_LSHIFT : {player _ walk}.
	}.
}.

function processEvents() => Void := {
	let event mutable type: SDL_Event.

	while: SDL_PollEvent(event address) do: {
		event type selectCase: #{
		SDL_EventType SDL_QUIT : { isQuitting := true }.
		SDL_EventType SDL_KEYDOWN : { onKeyDown(event key) }.
		SDL_EventType SDL_KEYUP  : { onKeyUp(event key) }.
		}.
	}
}.

function fillRectangle(worldRectangle: Box2D, color: Float32x4) => Void := {
	let color32 := (color clampMin: 0.0 max: 1.0)*255.0 castTo: UInt8x4.

	let negativeCorner := (viewMatrix * Float32x3(worldRectangle min, 1.0)) floor castTo: Int32x2.
	let positiveCorner := (viewMatrix * Float32x3(worldRectangle max, 1.0)) floor castTo: Int32x2.

	let minCorner := negativeCorner min: positiveCorner.
	let maxCorner := negativeCorner max: positiveCorner.
	let extent := maxCorner - minCorner.

	let rect mutable := SDL_Rect newValue
		x: (minCorner x);
		y: (minCorner y);
		w: (extent x);
		h: (extent y).
	SDL_SetRenderDrawColor(renderer, color32 r, color32 g, color32 b, color32 a).
	SDL_RenderFillRect(renderer, rect address).
}.

function update(delta: Float32) => Void := {
	entities do: {:(Entity pointer)entity :: Void |
		entity _ update: delta.
	}.
}.

function render() => Void := {
	## Clear the screen.
	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255).
	SDL_RenderClear(renderer).

	## Compute the view matrix
	{
		let viewScale := 1.0 / 10.0 castTo: Float32.
		let viewScaleMatrix := Float32x3x3(
			Float32x3(640.0f*viewScale, 0.0f, 0.0f),
			Float32x3(0.0f, -480.0f*viewScale, 0.0f),
			Float32x3(320.0f, 240.0f, 1.0f)
		).
		let cameraMatrix := Float32x3x3(
			Float32x3(1.0f, 0.0f, 0.0f),
			Float32x3(0.0f, 1.0f, 0.0f),
			Float32x3(player _ position negated + Float32x2(-2.0f, -2.0f), 1.0f)).
		let fullViewMatrix := viewScaleMatrix * cameraMatrix.

		viewMatrix := Float32x2x3(
			fullViewMatrix firstColumn xy,
			fullViewMatrix secondColumn xy,
			fullViewMatrix thirdColumn xy).
	}.

	entities do: {:(Entity pointer)entity :: Void |
		entity _ render.
	}.

	SDL_RenderPresent(renderer).
}.

function mixAudioSamples(mixBuffer: Float32x2 pointer, sampleCount: UInt32) => Void := {
	let samplePeriod := 1.0f / audioDeviceSpec freq.

	## Clear the mixing buffer.
	StdNative memset(mixBuffer, 0, sampleCount * Float32x2 instanceSize).

	audioMutex withLock: {
		## Add each one of the sound channels into the mixing buffer.
		soundChannels do: {:(SoundChannel pointer)channel :: Void |
			channel _ mixSamples: sampleCount samplePeriod: samplePeriod intoBuffer: mixBuffer
		}.
	}.
}.

function audioCallback(userdata: Void pointer, stream: UInt8 pointer, len: Int32) => Void := {
	let channels := audioDeviceSpec channels.
	let sampleByteSize := audioDeviceSpec sampleByteSize.
	let sampleCount := len / (sampleByteSize * channels) castTo: UInt32.

	audioDeviceSpec format = AUDIO_F32 ifTrue: {
		mixAudioSamples(stream reinterpretCastTo: Float32x2 pointer, sampleCount).
		return: nil
	}.

	mixAudioSamples(audioTemporaryBuffer, sampleCount).

	audioDeviceSpec format selectCase: #{
		AUDIO_S16 : {
			let targetBuffer := stream reinterpretCastTo: Int16x2 pointer.
			0 until: sampleCount do: {:(UInt32)i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample clampMin: -1.0 max: 1.0)*32767.0 castTo: Int16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		AUDIO_U16 : {
			let targetBuffer := stream reinterpretCastTo: UInt16x2 pointer.
			0 until: sampleCount do: {:(UInt32)i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample*0.5 + 0.5 clampMin: 0.0 max: 1.0)*65535.0 castTo: UInt16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		let _ : {
			StdNative memset(stream, 0, len).
		}.
	}.
}.

method createWallMin: (min: Float32x2) max: (max: Float32x2) color: (color: Float32x4) ::=> Void := {
	let wall mutable := Wall nativeNew.
	wall _
		position: (max + min) *0.5f;
		halfExtent: (max - min) *0.5f;
		color: color.
	entities add: wall.
}.

function main externC (argc: Int32, argv: Char8 const pointer pointer) => Int32 := {

	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_GAMECONTROLLER) < 0 ifTrue: {
		return: 1.
	}.

	window := SDL_CreateWindow("Sysmel Hello SDL2", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_SHOWN).
	window ifNil: {
		return: 1.
	}.

	renderer := SDL_CreateRenderer(window, -1, SDL_RENDERER_PRESENTVSYNC).
	renderer ifNil: {
		return: 1.
	}.

	{
		let desiredAudioSpec mutable := SDL_AudioSpec newValue
			freq: 48000;
			format: AUDIO_S16;
			channels: 2;
			samples: 2048;
			callback: audioCallback address;
			yourself.
		audioDeviceID := SDL_OpenAudioDevice(nil, 0, desiredAudioSpec address, audioDeviceSpec address, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_FORMAT_CHANGE | SDL_AUDIO_ALLOW_SAMPLES_CHANGE).
		audioDeviceSpec format ~= AUDIO_F32 ifTrue: {
			audioTemporaryBuffer := StdNative malloc(audioDeviceSpec samples * 8) reinterpretCastTo: Float32x2 pointer.
		}.
	}.

	## Create the floor
	{
		createWallMin: Float32x2(-20.0f, -5.0f) max: Float32x2(20.0f, -4.0f) color: Float32x4(0.2f, 0.2f, 0.2f, 0.2f).
	}.

	{
		player := Player nativeNew.
		entities add: player.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(2.0, 0.0).
		entities add: enemy.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(4.0, 0.0).
		entities add: enemy.
	}.

	{
		let pulseChannel mutable := PulseChannel nativeNew.
		pulseChannel _
			frequency: 440.0;
			amplitude: 0.05;
			extraParam: 0.15.
		soundChannels add: pulseChannel.
	}.

	{
		let noiseChannel mutable := NoiseChannel nativeNew.
		noiseChannel _
			amplitude: 0.1.
		soundChannels add: noiseChannel.
	}.
	audioDeviceID ~= 0 ifTrue: {
		SDL_PauseAudioDevice(audioDeviceID, 0).
	}.

	let oldTicks mutable := SDL_GetTicks().
	let updateDelta := 1.0 / 60.0 castTo: Float32.
	let accumulatedTime mutable type: Float32 := 0.0.
	until: isQuitting do: {
		let newTicks := SDL_GetTicks().
		let deltaTicks := newTicks - oldTicks.
		accumulatedTime := accumulatedTime + deltaTicks *0.001 castTo: Float32.

		## Process the event.
		processEvents().

		## Deterministic update.
		##StdNative stdout << "deltaTicks " << deltaTicks; nl.
		##StdNative stdout << "accumulatedTime " << accumulatedTime; nl.
		while: accumulatedTime - updateDelta >= updateDelta  do: {
			##StdNative stdout << "update iter "; nl.
			update(updateDelta).
			accumulatedTime := accumulatedTime - updateDelta
		}.

		## Perform the actual rendering.
		render().

		## Compute the sleep time to achieve 60 fps.
		let targetTicks := newTicks + 16 - (accumulatedTime castTo: UInt32).
		let renderEndTicks := SDL_GetTicks().
		renderEndTicks < targetTicks ifTrue: {
			let delayTicks := targetTicks - renderEndTicks - 2 castTo: Int32.
			##StdNative stdout << "delayTicks " << delayTicks; nl.
			delayTicks > 0 ifTrue: {
				SDL_Delay(delayTicks castTo: UInt32).
			}
		}.
		oldTicks := newTicks.
	}.

	audioDeviceID ~= 0 ifTrue: {
		SDL_CloseAudioDevice(audioDeviceID).
		StdNative free(audioTemporaryBuffer).
	}.

	entities do: #nativeDelete.
	soundChannels do: #nativeDelete.

	SDL_DestroyRenderer(renderer).
	SDL_DestroyWindow(window).
	SDL_Quit().

    return: 0.
}.
