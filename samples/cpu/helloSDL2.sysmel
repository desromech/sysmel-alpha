useNamespace: SDL2.

global window mutable type: SDL_Window pointer.
global renderer mutable type: SDL_Renderer pointer.
global isQuitting mutable := false.

global audioMutex mutable type: StdNative Mutex.
global audioDeviceID mutable type: SDL_AudioDeviceID.
global audioDeviceSpec mutable type: SDL_AudioSpec.
global audioTemporaryBuffer mutable type: Float32x2 pointer.

struct Box2D definition: {
	public field min type: Float32x2.
	public field max type: Float32x2.

	meta method center: (center: Float32x2) halfExtent: (halfExtent: Float32x2) ::=> SelfType
		:= SelfType newValue
			min: center - halfExtent;
			max: center + halfExtent;
			yourself.

	method extent => Float32x2
		:= max - min.

	method halfExtent => Float32x2
		:= (max - min) * 0.5.

	method center => Float32x2
		:= (max + min) * 0.5.
}.

class Character definition: {
	public field position type: Float32x2.
	public field velocity type: Float32x2.
	public field halfExtent type: Float32x2.
	public field color type: Float32x4.

	method boundingBox => Box2D
		:= Box2D center: position halfExtent: halfExtent.
}.

class Enemy superclass: Character; definition: {
	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.1, 0.1, 1.0).
	}.

	method simulate: (delta: Float32) ::=> Void := {
	}.
}.

class Player superclass: Character; definition: {
	public field speed type: Float32.
	public field direction type: Float32x2.

	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.5, 0.2, 1.0).
		self walk
	}.

	method walk => Void := {
		speed := 1.0
	}.

	method run => Void := {
		speed := 3.0
	}.

	method simulate: (delta: Float32) ::=> Void := {
		velocity := direction * speed.

		position := position + velocity * delta.
	}.
}.

class SoundChannel definition: {
	virtual method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		## By default do nothing.
	}.
}.

class SineChannel superclass: SoundChannel; definition: {
	public field amplitude type: Float32.
	public field frequency type: Float32.

	field currentSampleIndex type: UInt32.

	override method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		## Mix the samples
		0 until: sampleCount do: {:(UInt32)i :: Void |
			let absoluteSampleTime := (currentSampleIndex + i)*samplePeriod.
			let c := (absoluteSampleTime * frequency * Float32 twoPi) cos * amplitude.
			mixBuffer[i] := mixBuffer[i] + Float32x2(c, c)
		}.

		currentSampleIndex := currentSampleIndex + sampleCount.
	}.
}.

global characters mutable type: (StdNative OrderedCollection(Character pointer)).
global soundChannels mutable type: (StdNative OrderedCollection(SoundChannel pointer)).

global player mutable type: Player pointer.
global viewMatrix mutable type: Float32x2x3.

function onKeyDown(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ direction x: -1.0}.
	Keycode SDLK_d : {player _ direction x: 1.0}.
	Keycode SDLK_s : {player _ direction y: -1.0}.
	Keycode SDLK_w : {player _ direction y: 1.0}.
	Keycode SDLK_LSHIFT : {player _ run}.
	}.
}.

function onKeyUp(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ direction x < 0.0 ifTrue: {player _ direction x: 0.0}}.
	Keycode SDLK_d : {player _ direction x > 0.0 ifTrue: {player _ direction x: 0.0}}.
	Keycode SDLK_s : {player _ direction y < 0.0 ifTrue: {player _ direction y: 0.0}}.
	Keycode SDLK_w : {player _ direction y > 0.0 ifTrue: {player _ direction y: 0.0}}.
	Keycode SDLK_LSHIFT : {player _ walk}.
	}.
}.

function processEvents() => Void := {
	let event mutable type: SDL_Event.

	while: SDL_PollEvent(event address) do: {
		event type selectCase: #{
		SDL_EventType SDL_QUIT : { isQuitting := true }.
		SDL_EventType SDL_KEYDOWN : { onKeyDown(event key) }.
		SDL_EventType SDL_KEYUP  : { onKeyUp(event key) }.
		}.
	}
}.

function drawCharacter(character: Character ref) => Void := {
	let color := (character color clampMin: 0.0 max: 1.0)*255.0 castTo: UInt8x4.

	let boundingBox := character boundingBox.
	let negativeCorner := viewMatrix * Float32x3(boundingBox min, 1.0) castTo: Int32x2.
	let positiveCorner := viewMatrix * Float32x3(boundingBox max, 1.0) castTo: Int32x2.

	let minCorner := negativeCorner min: positiveCorner.
	let maxCorner := negativeCorner max: positiveCorner.
	let extent := maxCorner - minCorner.

	let rect mutable := SDL_Rect newValue
		x: (minCorner x);
		y: (minCorner y);
		w: (extent x);
		h: (extent y).
	SDL_SetRenderDrawColor(renderer, color r, color g, color b, color a).
	SDL_RenderFillRect(renderer, rect address).
}.

function update(delta: Float32) => Void := {
	player _ simulate: delta.
}.

function render() => Void := {
	## Clear the screen.
	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255).
	SDL_RenderClear(renderer).

	## Compute the view matrix
	{
		let viewScale := 1.0 / 10.0 castTo: Float32.
		viewMatrix := Float32x2x3(
			Float32x2(640.0*viewScale, 0.0),
			Float32x2(0.0, -480.0*viewScale),
			Float32x2(320, 240)
		).
	}.

	characters do: {:(Character pointer)character :: Void |
		drawCharacter(character _).
	}.

	SDL_RenderPresent(renderer).
}.

function mixAudioSamples(mixBuffer: Float32x2 pointer, sampleCount: UInt32) => Void := {
	let samplePeriod := 1.0f / audioDeviceSpec freq.

	## Clear the mixing buffer.
	StdNative memset(mixBuffer, 0, sampleCount * Float32x2 instanceSize).

	audioMutex withLock: {
		## Add each one of the sound channels into the mixing buffer.
		soundChannels do: {:(SoundChannel pointer)channel :: Void |
			channel _ mixSamples: sampleCount samplePeriod: samplePeriod intoBuffer: mixBuffer
		}.
	}.

}.

function audioCallback(userdata: Void pointer, stream: UInt8 pointer, len: Int32) => Void := {
	let channels := audioDeviceSpec channels.
	let sampleByteSize := audioDeviceSpec sampleByteSize.
	let sampleCount := len / (sampleByteSize * channels) castTo: UInt32.

	audioDeviceSpec format = AUDIO_F32 ifTrue: {
		mixAudioSamples(stream reinterpretCastTo: Float32x2 pointer, sampleCount).
		return: nil
	}.

	mixAudioSamples(audioTemporaryBuffer, sampleCount).

	audioDeviceSpec format selectCase: #{
		AUDIO_S16 : {
			let targetBuffer := stream reinterpretCastTo: Int16x2 pointer.
			0 until: sampleCount do: {:(UInt32)i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample clampMin: -1.0 max: 1.0)*32767.0 castTo: Int16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		AUDIO_U16 : {
			let targetBuffer := stream reinterpretCastTo: UInt16x2 pointer.
			0 until: sampleCount do: {:(UInt32)i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample*0.5 + 0.5 clampMin: 0.0 max: 1.0)*65535.0 castTo: UInt16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		let _ : {
			StdNative memset(stream, 0, len).
		}.
	}.
}.

function main externC (argc: Int32, argv: Char8 const pointer pointer) => Int32 := {

	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_GAMECONTROLLER) < 0 ifTrue: {
		return: 1.
	}.

	window := SDL_CreateWindow("Test window", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_SHOWN).
	window ifNil: {
		return: 1.
	}.

	renderer := SDL_CreateRenderer(window, -1, SDL_RENDERER_PRESENTVSYNC).
	renderer ifNil: {
		return: 1.
	}.

	{
		let desiredAudioSpec mutable := SDL_AudioSpec newValue
			freq: 48000;
			format: AUDIO_S16;
			channels: 2;
			samples: 2048;
			callback: audioCallback address;
			yourself.
		audioDeviceID := SDL_OpenAudioDevice(nil, 0, desiredAudioSpec address, audioDeviceSpec address, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_FORMAT_CHANGE | SDL_AUDIO_ALLOW_SAMPLES_CHANGE).
		audioDeviceSpec format ~= AUDIO_F32 ifTrue: {
			audioTemporaryBuffer := StdNative malloc(audioDeviceSpec samples * 8) reinterpretCastTo: Float32x2 pointer.
		}.
	}.

	{
		player := Player nativeNew.
		characters add: player.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(2.0, 0.0).
		characters add: enemy.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(4.0, 0.0).
		characters add: enemy.
	}.

	{
		let sineChannel mutable := SineChannel nativeNew.
		sineChannel _
			frequency: 440.0;
			amplitude: 0.05.
		soundChannels add: sineChannel.
	}.

	{
		let sineChannel mutable := SineChannel nativeNew.
		sineChannel _
			frequency: 220.0;
			amplitude: 0.1.
		soundChannels add: sineChannel.
	}.
	audioDeviceID ~= 0 ifTrue: {
		SDL_PauseAudioDevice(audioDeviceID, 0).
	}.

	let oldTicks mutable := SDL_GetTicks().
	let updateDelta := 1.0 / 60.0 castTo: Float32.
	let accumulatedTime mutable type: Float32 := 0.0.
	until: isQuitting do: {
		let newTicks := SDL_GetTicks().
		let deltaTicks := newTicks - oldTicks.
		accumulatedTime := accumulatedTime + deltaTicks *0.001 castTo: Float32.

		## Process the event.
		processEvents().

		## Deterministic update.
		##StdNative stdout << "deltaTicks " << deltaTicks; nl.
		##StdNative stdout << "accumulatedTime " << accumulatedTime; nl.
		while: accumulatedTime - updateDelta >= updateDelta  do: {
			##StdNative stdout << "update iter "; nl.
			update(updateDelta).
			accumulatedTime := accumulatedTime - updateDelta
		}.

		## Perform the actual rendering.
		render().

		## Compute the sleep time to achieve 60 fps.
		let targetTicks := newTicks + 16 - (accumulatedTime castTo: UInt32).
		let renderEndTicks := SDL_GetTicks().
		renderEndTicks < targetTicks ifTrue: {
			let delayTicks := targetTicks - renderEndTicks - 2 castTo: Int32.
			##StdNative stdout << "delayTicks " << delayTicks; nl.
			delayTicks > 0 ifTrue: {
				SDL_Delay(delayTicks castTo: UInt32).
			}
		}.
		oldTicks := newTicks.
	}.

	audioDeviceID ~= 0 ifTrue: {
		SDL_CloseAudioDevice(audioDeviceID).
		StdNative free(audioTemporaryBuffer).
	}.

	characters do: #nativeDelete.
	soundChannels do: #nativeDelete.

	SDL_DestroyRenderer(renderer).
	SDL_DestroyWindow(window).
	SDL_Quit().

    return: 0.
}.
