useNamespace: SDL2.

class SoundChannelWithEnvelope.

let Gravity := Float32x2(0.0, -9.8).
global window mutable type: SDL_Window pointer.
global renderer mutable type: SDL_Renderer pointer.
global isQuitting mutable := false.

global audioMutex mutable type: NStd Mutex.
global audioDeviceID mutable type: SDL_AudioDeviceID.
global audioDeviceSpec mutable type: SDL_AudioSpec.
global audioTemporaryBuffer mutable type: Float32x2 pointer.

global jumpSound mutable type: SoundChannelWithEnvelope pointer.
global dashSound mutable type: SoundChannelWithEnvelope pointer.
global shootSound mutable type: SoundChannelWithEnvelope pointer.

struct Box2D definition: {
	public field min type: Float32x2.
	public field max type: Float32x2.

	meta method center: (center: Float32x2) halfExtent: (halfExtent: Float32x2) ::=> SelfType
		:= SelfType newValue
			min: center - halfExtent;
			max: center + halfExtent;
			yourself.

	method extent => Float32x2
		:= max - min.

	method halfExtent => Float32x2
		:= (max - min) * 0.5.

	method center => Float32x2
		:= (max + min) * 0.5.

	method containsPoint: (point: Float32x2) ::=> Boolean8
		:= min x <= point x && point x <= max x &&
		   min y <= point y && point y <= max y.

	method hasIntersectionWithRayOrigin: (rayOrigin: Float32x2) direction: (rayDirection: Float32x2) at: (intersectionT: Float32 pointer) ::=> Boolean8 := {
		## Ray box intersection algorithm from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection
		let directionReciprocal := 1.0f / rayDirection.
		let tNegative := (min - rayOrigin) * directionReciprocal.
		let tPositive := (max - rayOrigin) * directionReciprocal.

		let tmin := tNegative min: tPositive.
		let tmax := tNegative max: tPositive.

		(tmin x > tmax y || tmin y > tmax x) ifTrue: {
			false
		} ifFalse: {
			intersectionT _ := (tmin x max: tmin y) max: 0.0f.
			tmin x >= 0.0f || tmin y >= 0.0f
		}
	}.

	method computePenetrationDistanceForPoint: (point: Float32x2) withNormal: (normal: Float32x2) ::=> Float32 := {
		##let delta := point - self center.
		##((self halfExtent - delta) dot: normal) max: 0.0
		0.0f
	}.

	method computeCollisionNormalForPoint: (point: Float32x2) ::=> Float32x2 := {
		let delta := point - self center.
		let deltaAbsolute := delta abs / self halfExtent.
		deltaAbsolute x >= deltaAbsolute y ifTrue: {
			Float32x2(delta x sign, 0.0f)
		} ifFalse: {
			Float32x2(0.0f, delta y sign)
		}
	}.
}.

class Entity definition: {
	public field position type: Float32x2.
	public field halfExtent type: Float32x2.
	public field color type: Float32x4.

	virtual method shouldBeRemoved => Boolean8
		:= self isDead.

	virtual method isDead => Boolean8
		:= false.

	method boundingBox => Box2D
		:= Box2D center: position halfExtent: halfExtent.

	method boundingBoxExpandedWith: (extraHalfExtent: Float32x2) ::=> Box2D
		:= Box2D center: position halfExtent: halfExtent + extraHalfExtent.

	virtual method currentColor => Float32x4
		:= color.

	virtual method hasCollisionResponse => Boolean8
		:= true.

	virtual method canBeShot => Boolean8
		:= true.

	virtual method shotAt: (bulletHitPoint: Float32x2) withDamage: (damage: Float32) ::=> Void := {
		## By default do nothing when shot.
	}.

	virtual method render => Void := {
		fillRectangle(self boundingBox, self currentColor).
	}.

	virtual method update: (delta: Float32) ::=> Void := {
	}.
}.

class Wall superclass: Entity; definition: {

}.

class Character superclass: Entity; definition: {
	public field velocity type: Float32x2.
	public field lookDirection type: Float32x2.
	public field hitPoints type: Float32.
	field hitFlashRemainingTime type: Float32.

	field isOnFloor type: Boolean8.

	override method currentColor => Float32x4
		:= hitFlashRemainingTime > 0.0f ifTrue: {Float32x4(1.0f, 1.0f, 1.0f, 1.0f)} ifFalse: {color}.

	method initialize => Void := {
		lookDirection := Float32x2(1.0f, 0.0f).
		hitPoints := 100.0.
	}.

	override method isDead => Boolean8
		:= hitPoints <= 0.0f.

	override method hasCollisionResponse => Boolean8
		:= false.

	override method shotAt: (bulletHitPoint: Float32x2) withDamage: (damage: Float32) ::=> Void := {
		## Invincibility period.
		hitFlashRemainingTime > 0.0f ifTrue: { return: 0.0f }.

		hitPoints := hitPoints - damage.
		hitFlashRemainingTime := 0.05f.
	}.

	method sweepCollidingFrom: (oldPosition: Float32x2) into: (targetPosition: Float32x2) maxDepth: (maxDepth: UInt32)::=> Void := {
		maxDepth = 0 ifTrue: { return: nil. }.

		## Compute the ray direction and length.
		let rayOrigin := oldPosition.
		let rayDirection mutable := targetPosition - position.
		let rayLength := rayDirection length2 sqrt.##rayDirection length.
		rayLength < 0.00001f ifTrue: { return: nil }.
		rayDirection := rayDirection / rayLength.

		## Perform Minkowski difference based collision detection with the boxes.
		let bestCollisionAlpha mutable := rayLength.
		let bestCollisionEntity mutable type: Entity pointer := nil.
		let bestCollisionExpandedBound mutable type: Box2D.

		entities do: {:entity :: Void |
			## FIXME: Make this cast redundant.
			entity ~~ (self address castTo: Entity pointer) &&
			entity _ isDead not &&
			entity _ hasCollisionResponse ifTrue: {
				let entityExpandedBoundingBox mutable := entity _ boundingBoxExpandedWith: halfExtent.
				let intersectionAlpha mutable type: Float32.
				(entityExpandedBoundingBox hasIntersectionWithRayOrigin: rayOrigin direction: rayDirection at: intersectionAlpha address) ifTrue: {
					intersectionAlpha < bestCollisionAlpha ifTrue: {
						bestCollisionExpandedBound := entityExpandedBoundingBox.
						bestCollisionAlpha := intersectionAlpha.
						bestCollisionEntity := entity
					}.
				}.
			}.
		}.

		bestCollisionAlpha < rayLength ifTrue: {
			let collisionPoint := rayOrigin + bestCollisionAlpha*rayDirection.
			let remainingDelta := (rayLength - bestCollisionAlpha)*rayDirection.

			let collisionNormal := bestCollisionExpandedBound computeCollisionNormalForPoint: collisionPoint.
			let penetrationDistance := bestCollisionExpandedBound computePenetrationDistanceForPoint: collisionNormal withNormal: collisionNormal.
			let slidingDelta := remainingDelta - (remainingDelta dot: collisionNormal)*collisionNormal.

			isOnFloor := isOnFloor || collisionNormal y > 0.0.
			velocity := velocity - (velocity dot: collisionNormal)*collisionNormal.
			position := collisionPoint + collisionNormal*(penetrationDistance*0.1f).

			self sweepCollidingFrom: position into: position + slidingDelta maxDepth: maxDepth - 1.
		} ifFalse: {
			position := targetPosition
		}.

	}.

	override method update: (delta: Float32) ::=> Void := {
		hitFlashRemainingTime > 0.0f ifTrue: {
			hitFlashRemainingTime := hitFlashRemainingTime - delta.
		}.

		velocity := velocity + Gravity * delta.
		let newPosition := position + velocity * delta.

		isOnFloor := false.
		self sweepCollidingFrom: position into: newPosition maxDepth: 5.
	}.
}.

class Bullet superclass: Entity; definition: {
	public field velocity type: Float32x2.
	public field shooter type: Entity pointer.
	public field maxFlyingTime type: Float32.
	public field damage type: Float32.

	field flyingTime type: Float32.
	field hasHitTarget type: Boolean8.

	override method isDead => Boolean8
		:= hasHitTarget || flyingTime > maxFlyingTime.

	override method update: (delta: Float32) ::=> Void := {
		let targetPosition := position + velocity * delta.
		let oldPosition := position.
		flyingTime := flyingTime + delta.

		## Compute the ray direction and length.
		let rayOrigin := oldPosition.
		let rayDirection mutable := targetPosition - position.
		let rayLength := rayDirection length2 sqrt.##rayDirection length.
		rayLength < 0.00001f ifTrue: { return: nil }.
		rayDirection := rayDirection / rayLength.

		## Perform Minkowski difference based collision detection with the boxes.
		let bestCollisionAlpha mutable := rayLength.
		let bestCollisionEntity mutable type: Entity pointer := nil.

		entities do: {:entity :: Void |
			## FIXME: Make this cast redundant.
			entity ~~ shooter &&
			entity _ isDead not &&
			entity _ canBeShot ifTrue: {
				let entityExpandedBoundingBox mutable := entity _ boundingBoxExpandedWith: halfExtent.
				let intersectionAlpha mutable type: Float32.
				(entityExpandedBoundingBox hasIntersectionWithRayOrigin: rayOrigin direction: rayDirection at: intersectionAlpha address) ifTrue: {
					intersectionAlpha < bestCollisionAlpha ifTrue: {
						bestCollisionAlpha := intersectionAlpha.
						bestCollisionEntity := entity
					}.
				}.
			}.
		}.

		bestCollisionEntity ifNotNil: {
			hasHitTarget := true.
			bestCollisionEntity _ shotAt: rayOrigin + bestCollisionAlpha*rayDirection withDamage: damage.
			return: nil
		}.

		position := targetPosition.
	}.
}.

class Enemy superclass: Character; definition: {
	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.1, 0.1, 1.0).
	}.
}.

class Player superclass: Character; definition: {
	public field speed type: Float32.
	public field direction type: Float32x2.
	public field remainingDashTime type: Float32.
	public field dashDirection type: Float32x2.

	## Never remove the player.
	method shouldBeRemoved => Boolean8
		:= false.

	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.5, 0.2, 1.0).
		speed := 3.0f.
	}.

	method dash => Void := {
		isOnFloor ifTrue: {
			remainingDashTime := 0.35f.
			dashDirection := Float32x2(lookDirection x, 0.0f).
			speed := 10.0f.
			audioMutex withLock: {
				dashSound _ reset
			}.
		}.
	}.

	method moveLeftInput: (state: Boolean8) ::=> Void := {
		state ifTrue: {
			direction x: -1.0.
			lookDirection x: -1.0.
		} ifFalse: {
			direction x < 0.0 ifTrue: {
				direction x: 0.0.
			}.
		}.
	}.

	method moveRightInput: (state: Boolean8) ::=> Void := {
		state ifTrue: {
			direction x: 1.0.
			lookDirection x: 1.0.
		} ifFalse: {
			direction x > 0.0 ifTrue: {
				direction x: 0.0.
			}.
		}.
	}.

	method jump => Void := {
		isOnFloor ifTrue: {
			velocity y: 10.0.
			remainingDashTime := 0.0f.
			audioMutex withLock: {
				jumpSound _ reset
			}.
		}.
	}.

	method shoot => Void := {
		audioMutex withLock: {
			shootSound _ reset
		}.

		let bullet mutable := Bullet nativeNew.
		bullet _
			color: Float32x4(0.8, 0.8, 0.8, 1.0);
			halfExtent: 0.2;
			shooter: self address;
			position: position;
			velocity: Float32x2(velocity x, 0.0f) + 10.0f*lookDirection;
			damage: 20.0f;
			maxFlyingTime: 0.5f.
		entities add: bullet
	}.

	override method update: (delta: Float32) ::=> Void := {
		remainingDashTime > 0.0f ifTrue: {
			remainingDashTime := remainingDashTime - delta.
			velocity x: dashDirection x * speed.
		} ifFalse: {
			velocity x: direction x * speed.
		}.

		super update: delta.

		isOnFloor ifTrue: {
			remainingDashTime <= 0.0f ifTrue: {
				speed := 3.0f
			}.
		}.
	}.
}.

class SoundChannel definition: {
	virtual method reset => Void := {
		## By default do nothing
	}.

	virtual method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		## By default do nothing.
	}.
}.

class SoundChannelWithEnvelope; superclass: SoundChannel; definition: {
	public field attackTime type: Float32.
	public field decayTime type: Float32.
	public field sustainLevel type: Float32.
	public field sustainTime type: Float32.
	public field releaseTime type: Float32.
	public field paused type: Boolean8.

	field currentSampleIndex type: UInt32.

	override method reset => Void := {
		currentSampleIndex := 0.
		paused := false.
	}.

	method computeEnvelopeFactorAt: (time: Float32) ::=> Float32 := {
		(attackTime > 0.0f) && (time < attackTime) ifTrue: {
			return: time / attackTime
		}.
		(decayTime > 0.0f) && (time < attackTime + decayTime) ifTrue: {
			return: (1.0 interpolateTo: sustainLevel at: time - attackTime / decayTime)
		}.

		(sustainTime > 0.0f) && (time < attackTime + decayTime + sustainTime) ifTrue: {
			return: sustainLevel
		}.

		(releaseTime > 0.0f) && (time < attackTime + decayTime + sustainTime + releaseTime) ifTrue: {
			return: (sustainLevel interpolateTo: 0.0 at: (time - (attackTime + decayTime + sustainTime)) / releaseTime)
		}.

		paused := true.
		return: 0.0
	}
}.

class NoiseChannel; superclass: SoundChannelWithEnvelope; definition: {
	public field amplitude type: Float32.

	field randomState type: UInt64.

	method nextRandomSample => Float32 := {
		randomState = 0 ifTrue: {randomState := 1}.

		## Xor shift generator.
		## https://en.wikipedia.org/wiki/Xorshift [January 3th, 2020]
		let x mutable := randomState.
		x := x ^ (x << 13).
		x := x ^ (x >> 7).
		x := x ^ (x << 17).
		randomState := x.

		let unormValue := (randomState castTo: Float64) / 18446744073709551615.0.
		unormValue*2.0 - 1.0 castTo: Float32
	}.

	override method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		paused ifTrue: {return: nil}.

		## Mix the samples
		0 until: sampleCount do: {:i :: Void |
			let absoluteSampleTime := (currentSampleIndex + i)*samplePeriod.
			let envelopeFactor := self computeEnvelopeFactorAt: absoluteSampleTime.
			let sample := self nextRandomSample * amplitude * envelopeFactor.
			mixBuffer[i] := mixBuffer[i] + sample
		}.

		currentSampleIndex := currentSampleIndex + sampleCount.
	}.
}.

template ToneFunctionSoundChannel(toneFunction: _FunctionType ref)
	:= class superclass: SoundChannelWithEnvelope; definition: {
	public field amplitude type: Float32.
	public field frequency type: Float32.
	public field phase type: Float32.
	public field extraParam type: Float32.

	override method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		paused ifTrue: {return: nil}.

		## Mix the samples
		0 until: sampleCount do: {:i :: Void |
			let absoluteSampleTime := (currentSampleIndex + i)*samplePeriod.
			let envelopeFactor := self computeEnvelopeFactorAt: absoluteSampleTime.
			let sample := toneFunction(absoluteSampleTime * frequency + phase, extraParam) * amplitude * envelopeFactor.
			mixBuffer[i] := mixBuffer[i] + sample
		}.

		currentSampleIndex := currentSampleIndex + sampleCount.
	}.
}.

compileTimeConstant SineChannel := ToneFunctionSoundChannel(
	function(x: Float32, _: Float32) => Float32
		:= (x * Float32 twoPi) sin
).

compileTimeConstant PulseChannel := ToneFunctionSoundChannel(
	function(x: Float32, pulseWidth: Float32) => Float32
		:= (x fract stepValue: pulseWidth)*2.0f - 1.0f
).

compileTimeConstant SawChannel := ToneFunctionSoundChannel(
	function(x: Float32, _: Float32) => Float32
		:= x fract*2.0f - 1.0f
).

global entities mutable type: (NStd Collections Vector(Entity pointer)).
global soundChannels mutable type: (NStd Collections Vector(SoundChannel pointer)).

global player mutable type: Player pointer.
global viewMatrix mutable type: Float32x2x3.

function onKeyDown(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ moveLeftInput: true}.
	Keycode SDLK_d : {player _ moveRightInput: true}.
	Keycode SDLK_w : {player _ jump}.
	Keycode SDLK_SPACE : {player _ shoot}.
	Keycode SDLK_LSHIFT : {player _ dash}.
	}.
}.

function onKeyUp(event: SDL_KeyboardEvent ref) => Void := {
	event keysym sym selectCase: #{
	Keycode SDLK_ESCAPE : {isQuitting := true.}.
	Keycode SDLK_a : {player _ moveLeftInput: false}.
	Keycode SDLK_d : {player _ moveRightInput: false}.
	}.
}.

function processEvents() => Void := {
	let event mutable type: SDL_Event.

	while: SDL_PollEvent(event address) do: {
		event type selectCase: #{
		SDL_EventType SDL_QUIT : { isQuitting := true }.
		SDL_EventType SDL_KEYDOWN : { onKeyDown(event key) }.
		SDL_EventType SDL_KEYUP  : { onKeyUp(event key) }.
		}.
	}
}.

function fillRectangle(worldRectangle: Box2D, color: Float32x4) => Void := {
	let color32 := (color clampMin: 0.0 max: 1.0)*255.0 castTo: UInt8x4.

	let negativeCorner := (viewMatrix * Float32x3(worldRectangle min, 1.0)) floor castTo: Int32x2.
	let positiveCorner := (viewMatrix * Float32x3(worldRectangle max, 1.0)) floor castTo: Int32x2.

	let minCorner := negativeCorner min: positiveCorner.
	let maxCorner := negativeCorner max: positiveCorner.
	let extent := maxCorner - minCorner.

	let rect mutable := SDL_Rect newValue
		x: (minCorner x);
		y: (minCorner y);
		w: (extent x);
		h: (extent y).
	SDL_SetRenderDrawColor(renderer, color32 r, color32 g, color32 b, color32 a).
	SDL_RenderFillRect(renderer, rect address).
}.

function update(delta: Float32) => Void := {
	entities do: {:entity :: Void |
		entity _ update: delta.
	}.

	## Remove the dead entities
	let destIndex mutable type: UIntPointer := 0.
	0 until: entities size do: {:i :: Void |
		let entity := entities[i].
		entity _ shouldBeRemoved ifTrue: {
			entity nativeDelete
		} ifFalse: {
			entities[destIndex] := entity.
			destIndex := destIndex + 1
		}.
	}.
	entities resizeTo: destIndex.
}.

function drawHealth() => Void := {
	## Red border
	let fullHealthRect mutable := SDL_Rect newValue
		x: 20;
		y: 20;
		w: 250;
		h: 15;
		yourself.

	let currentHealthRect mutable := fullHealthRect.
	let healthPercentage := player _ hitPoints / 100.0f clampMin: 0.0f max: 1.0.
	currentHealthRect w: (fullHealthRect w * healthPercentage castTo: Int32).

	SDL_SetRenderDrawColor(renderer, 255, 160, 0, 255).
	SDL_RenderFillRect(renderer, fullHealthRect address).

	SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255).
	SDL_RenderDrawRect(renderer, fullHealthRect address).

}.

function renderHUD() => Void := {
	drawHealth().
}.

function render() => Void := {
	## Clear the screen.
	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255).
	SDL_RenderClear(renderer).

	## Compute the view matrix
	{
		let viewScale := 1.0 / 10.0 castTo: Float32.
		let viewScaleMatrix := Float32x3x3(
			Float32x3(640.0f*viewScale, 0.0f, 0.0f),
			Float32x3(0.0f, -480.0f*viewScale, 0.0f),
			Float32x3(320.0f, 240.0f, 1.0f)
		).
		let cameraMatrix := Float32x3x3(
			Float32x3(1.0f, 0.0f, 0.0f),
			Float32x3(0.0f, 1.0f, 0.0f),
			Float32x3(player _ position negated + Float32x2(-2.0f, -2.0f), 1.0f)).
		let fullViewMatrix := viewScaleMatrix * cameraMatrix.

		viewMatrix := Float32x2x3(
			fullViewMatrix firstColumn xy,
			fullViewMatrix secondColumn xy,
			fullViewMatrix thirdColumn xy).
	}.

	## Draw the entities.
	entities do: {:entity :: Void |
		entity _ render.
	}.

	## Draw the HUD.
	renderHUD().

	SDL_RenderPresent(renderer).
}.

function mixAudioSamples(mixBuffer: Float32x2 pointer, sampleCount: UInt32) => Void := {
	let samplePeriod := 1.0f / audioDeviceSpec freq.

	## Clear the mixing buffer.
	NStd memset(mixBuffer, 0, sampleCount * Float32x2 instanceSize).

	audioMutex withLock: {
		## Add each one of the sound channels into the mixing buffer.
		soundChannels do: {:channel :: Void |
			channel _ mixSamples: sampleCount samplePeriod: samplePeriod intoBuffer: mixBuffer
		}.
	}.
}.

function audioCallback(userdata: Void pointer, stream: UInt8 pointer, len: Int32) => Void := {
	let channels := audioDeviceSpec channels.
	let sampleByteSize := audioDeviceSpec sampleByteSize.
	let sampleCount := len / (sampleByteSize * channels) castTo: UInt32.

	audioDeviceSpec format = AUDIO_F32 ifTrue: {
		mixAudioSamples(stream reinterpretCastTo: Float32x2 pointer, sampleCount).
		return: nil
	}.

	mixAudioSamples(audioTemporaryBuffer, sampleCount).

	audioDeviceSpec format selectCase: #{
		AUDIO_S16 : {
			let targetBuffer := stream reinterpretCastTo: Int16x2 pointer.
			0 until: sampleCount do: {:i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample clampMin: -1.0 max: 1.0)*32767.0 castTo: Int16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		AUDIO_U16 : {
			let targetBuffer := stream reinterpretCastTo: UInt16x2 pointer.
			0 until: sampleCount do: {:i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample*0.5 + 0.5 clampMin: 0.0 max: 1.0)*65535.0 castTo: UInt16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		let _ : {
			NStd memset(stream, 0, len).
		}.
	}.
}.

method createWallMin: (min: Float32x2) max: (max: Float32x2) color: (color: Float32x4) ::=> Void := {
	let wall mutable := Wall nativeNew.
	wall _
		position: (max + min) *0.5f;
		halfExtent: (max - min) *0.5f;
		color: color.
	entities add: wall.
}.

function main externC (argc: Int32, argv: Char8 const pointer pointer) => Int32 := {

	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_GAMECONTROLLER) < 0 ifTrue: {
		return: 1.
	}.

	window := SDL_CreateWindow("Sysmel Hello SDL2", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_SHOWN).
	window ifNil: {
		return: 1.
	}.

	renderer := SDL_CreateRenderer(window, -1, SDL_RENDERER_PRESENTVSYNC).
	renderer ifNil: {
		return: 1.
	}.

	{
		let desiredAudioSpec mutable := SDL_AudioSpec newValue
			freq: 48000;
			format: AUDIO_S16;
			channels: 2;
			samples: 2048;
			callback: audioCallback address;
			yourself.
		audioDeviceID := SDL_OpenAudioDevice(nil, 0, desiredAudioSpec address, audioDeviceSpec address, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_FORMAT_CHANGE | SDL_AUDIO_ALLOW_SAMPLES_CHANGE).
		audioDeviceSpec format ~= AUDIO_F32 ifTrue: {
			audioTemporaryBuffer := NStd malloc(audioDeviceSpec samples * 8) reinterpretCastTo: Float32x2 pointer.
		}.
	}.

	## Create the floor
	{
		createWallMin: Float32x2(-5.0f, -5.0f) max: Float32x2(20.0f, -4.0f) color: Float32x4(0.2f, 0.2f, 0.2f, 0.2f).

		createWallMin: Float32x2(3.0f, -1.0f) max: Float32x2(8.0f, 0.0f) color: Float32x4(0.2f, 0.2f, 0.2f, 0.2f).
	}.

	{
		player := Player nativeNew.
		entities add: player.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(4.0, 2.0).
		entities add: enemy.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(15.0, 0.0).
		entities add: enemy.
	}.

	## Shoot sound.
	{
		let pulseChannel mutable := PulseChannel nativeNew.
		pulseChannel _
			frequency: 150.0;
			amplitude: 0.1;
			extraParam: 0.15;

			paused: true;

			attackTime: 0.025;
			decayTime: 0.025;
			sustainLevel: 0.4;
			sustainTime: 0.1;
			releaseTime: 0.3.

		shootSound := pulseChannel.
		soundChannels add: pulseChannel.
	}.

	## Jump sound.
	{
		let noiseChannel mutable := NoiseChannel nativeNew.
		noiseChannel _
			amplitude: 0.1;

			paused: true;

			attackTime: 0.015f;
			decayTime: 0.015f;
			sustainLevel: 0.2f;
			sustainTime: 0.05f;
			releaseTime: 0.1f.
		jumpSound := noiseChannel.
		soundChannels add: noiseChannel.
	}.

	## Dash sound.
	{
		let noiseChannel mutable := NoiseChannel nativeNew.
		noiseChannel _
			amplitude: 0.1;

			paused: true;

			attackTime: 0.025f;
			decayTime: 0.02f;
			sustainLevel: 0.2f;
			sustainTime: 0.1f;
			releaseTime: 0.2f.
		dashSound := noiseChannel.
		soundChannels add: noiseChannel.
	}.

	audioDeviceID ~= 0 ifTrue: {
		SDL_PauseAudioDevice(audioDeviceID, 0).
	}.

	let oldTicks mutable := SDL_GetTicks().
	let updateDelta := 1.0 / 60.0 castTo: Float32.
	let accumulatedTime mutable type: Float32 := 0.0.
	until: isQuitting do: {
		let newTicks := SDL_GetTicks().
		let deltaTicks := newTicks - oldTicks.
		accumulatedTime := accumulatedTime + deltaTicks *0.001 castTo: Float32.

		## Process the event.
		processEvents().

		## Deterministic update.
		##NStd stdout << "deltaTicks " << deltaTicks; nl.
		##NStd stdout << "accumulatedTime " << accumulatedTime; nl.
		while: accumulatedTime - updateDelta >= updateDelta  do: {
			##NStd stdout << "update iter "; nl.
			update(updateDelta).
			accumulatedTime := accumulatedTime - updateDelta
		}.

		## Perform the actual rendering.
		render().

		## Compute the sleep time to achieve 60 fps.
		let targetTicks := newTicks + 16 - (accumulatedTime castTo: UInt32).
		let renderEndTicks := SDL_GetTicks().
		renderEndTicks < targetTicks ifTrue: {
			let delayTicks := targetTicks - renderEndTicks - 2 castTo: Int32.
			##NStd stdout << "delayTicks " << delayTicks; nl.
			delayTicks > 0 ifTrue: {
				SDL_Delay(delayTicks castTo: UInt32).
			}
		}.
		oldTicks := newTicks.
	}.

	audioDeviceID ~= 0 ifTrue: {
		SDL_CloseAudioDevice(audioDeviceID).
		NStd free(audioTemporaryBuffer).
	}.

	entities do: #nativeDelete.
	soundChannels do: #nativeDelete.

	SDL_DestroyRenderer(renderer).
	SDL_DestroyWindow(window).
	SDL_Quit().

    return: 0.
}.
