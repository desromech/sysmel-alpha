Compiler
	importModuleNamed: #"Sysmel.Graphics.SDL2";
	importModuleNamed: #"Sysmel.Graphics.FreeType2".

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

useNamespace: SDL2.

class SoundChannelWithEnvelope.

let Gravity := Float32x2(0.0, -9.8).

global mainWindow mutable type: Window sharedPointer.
global mainDrawingSurface mutable type: Surface sharedPointer.

global audioMutex mutable type: Stdn Mutex.
global audioDeviceID mutable type: SDL_AudioDeviceID.
global audioDeviceSpec mutable type: SDL_AudioSpec.
global audioTemporaryBuffer mutable type: Float32x2 pointer.

global jumpSound mutable type: SoundChannelWithEnvelope pointer.
global dashSound mutable type: SoundChannelWithEnvelope pointer.
global shootSound mutable type: SoundChannelWithEnvelope pointer.

class Entity definition: {
	public field position type: Float32x2.
	public field halfExtent type: Float32x2.
	public field color type: Float32x4.

	virtual method shouldBeRemoved => Boolean8
		:= self isDead.

	virtual method isDead => Boolean8
		:= false.

	method boundingBox => RectangleF32
		:= RectangleF32 center: position halfExtent: halfExtent.

	method boundingBoxExpandedWith: (extraHalfExtent: Float32x2) ::=> RectangleF32
		:= RectangleF32 center: position halfExtent: halfExtent + extraHalfExtent.

	virtual method currentColor => Float32x4
		:= color.

	virtual method hasCollisionResponse => Boolean8
		:= true.

	virtual method canBeShot => Boolean8
		:= true.

	virtual method shotAt: (bulletHitPoint: Float32x2) withDamage: (damage: Float32) ::=> Void := {
		## By default do nothing when shot.
	}.

	virtual method renderOn: (canvas: Canvas ref) ::=> Void := {
		canvas
			color: self currentColor;
			fillRectangle: self boundingBox.
	}.

	virtual method update: (delta: Float32) ::=> Void := {
	}.
}.

class Wall superclass: Entity; definition: {

}.

class Character superclass: Entity; definition: {
	public field velocity type: Float32x2.
	public field lookDirection type: Float32x2.
	public field hitPoints type: Float32.
	field hitFlashRemainingTime type: Float32.

	field isOnFloor type: Boolean8.

	override method currentColor => Float32x4
		:= hitFlashRemainingTime > 0.0f ifTrue: {Float32x4(1.0f, 1.0f, 1.0f, 1.0f)} ifFalse: {color}.

	method initialize => Void := {
		lookDirection := Float32x2(1.0f, 0.0f).
		hitPoints := 100.0.
	}.

	override method isDead => Boolean8
		:= hitPoints <= 0.0f.

	override method hasCollisionResponse => Boolean8
		:= false.

	override method shotAt: (bulletHitPoint: Float32x2) withDamage: (damage: Float32) ::=> Void := {
		## Invincibility period.
		hitFlashRemainingTime > 0.0f ifTrue: { return: 0.0f }.

		hitPoints := hitPoints - damage.
		hitFlashRemainingTime := 0.05f.
	}.

	method sweepCollidingFrom: (oldPosition: Float32x2) into: (targetPosition: Float32x2) maxDepth: (maxDepth: UInt32)::=> Void := {
		maxDepth = 0 ifTrue: { return: nil. }.

		## Compute the ray direction and length.
		let rayOrigin := oldPosition.
		let rayDirection mutable := targetPosition - position.
		let rayLength := rayDirection length2 sqrt.##rayDirection length.
		rayLength < 0.00001f ifTrue: { return: nil }.
		rayDirection := rayDirection / rayLength.
		let ray := Ray2dF32 origin: rayOrigin direction: rayDirection.

		## Perform Minkowski difference based collision detection with the boxes.
		let bestCollisionAlpha mutable := rayLength.
		let bestCollisionEntity mutable type: Entity pointer := nil.
		let bestCollisionExpandedBound mutable type: RectangleF32.

		entities do: {:entity :: Void |
			## FIXME: Make this cast redundant.
			entity ~~ (self address castTo: Entity pointer) &&
			entity _ isDead not &&
			entity _ hasCollisionResponse ifTrue: {
				let entityExpandedBoundingBox mutable := entity _ boundingBoxExpandedWith: halfExtent.
				let intersectionResult mutable := entityExpandedBoundingBox intersectionWithRay: ray.
				intersectionResult isPresent ifTrue: {
					let intersectionAlpha := intersectionResult _.
					intersectionAlpha < bestCollisionAlpha ifTrue: {
						bestCollisionExpandedBound := entityExpandedBoundingBox.
						bestCollisionAlpha := intersectionAlpha.
						bestCollisionEntity := entity
					}.
				}.
			}.
		}.

		bestCollisionAlpha < rayLength ifTrue: {
			let collisionPoint := rayOrigin + bestCollisionAlpha*rayDirection.
			let remainingDelta := (rayLength - bestCollisionAlpha)*rayDirection.

			let collisionNormal := bestCollisionExpandedBound computeCollisionNormalForPoint: collisionPoint.
			let penetrationDistance := bestCollisionExpandedBound computePenetrationDistanceForPoint: collisionNormal withNormal: collisionNormal.
			let slidingDelta := remainingDelta - (remainingDelta dot: collisionNormal)*collisionNormal.

			isOnFloor := isOnFloor || collisionNormal y > 0.0.
			velocity := velocity - (velocity dot: collisionNormal)*collisionNormal.
			position := collisionPoint + collisionNormal*(penetrationDistance*0.1f).

			self sweepCollidingFrom: position into: position + slidingDelta maxDepth: maxDepth - 1.
		} ifFalse: {
			position := targetPosition
		}.

	}.

	override method update: (delta: Float32) ::=> Void := {
		hitFlashRemainingTime > 0.0f ifTrue: {
			hitFlashRemainingTime := hitFlashRemainingTime - delta.
		}.

		velocity := velocity + Gravity * delta.
		let newPosition := position + velocity * delta.

		isOnFloor := false.
		self sweepCollidingFrom: position into: newPosition maxDepth: 5.
	}.
}.

class Bullet superclass: Entity; definition: {
	public field velocity type: Float32x2.
	public field shooter type: Entity pointer.
	public field maxFlyingTime type: Float32.
	public field damage type: Float32.

	field flyingTime type: Float32.
	field hasHitTarget type: Boolean8.

	override method isDead => Boolean8
		:= hasHitTarget || flyingTime > maxFlyingTime.

	override method update: (delta: Float32) ::=> Void := {
		let targetPosition := position + velocity * delta.
		let oldPosition := position.
		flyingTime := flyingTime + delta.

		## Compute the ray direction and length.
		let rayOrigin := oldPosition.
		let rayDirection mutable := targetPosition - position.
		let rayLength := rayDirection length2 sqrt.##rayDirection length.
		rayLength < 0.00001f ifTrue: { return: nil }.
		rayDirection := rayDirection / rayLength.

		## Perform Minkowski difference based collision detection with the boxes.
		let bestCollisionAlpha mutable := rayLength.
		let bestCollisionEntity mutable type: Entity pointer := nil.
		let ray := Ray2dF32 origin: rayOrigin direction: rayDirection.

		entities do: {:entity :: Void |
			## FIXME: Make this cast redundant.
			entity ~~ shooter &&
			entity _ isDead not &&
			entity _ canBeShot ifTrue: {
				let entityExpandedBoundingBox mutable := entity _ boundingBoxExpandedWith: halfExtent.
				let intersectionResult mutable := entityExpandedBoundingBox intersectionWithRay: ray.
				intersectionResult isPresent ifTrue: {
					let intersectionAlpha := intersectionResult _.
					intersectionAlpha < bestCollisionAlpha ifTrue: {
						bestCollisionAlpha := intersectionAlpha.
						bestCollisionEntity := entity
					}.
				}.
			}.
		}.

		bestCollisionEntity ifNotNil: {
			hasHitTarget := true.
			bestCollisionEntity _ shotAt: rayOrigin + bestCollisionAlpha*rayDirection withDamage: damage.
			return: nil
		}.

		position := targetPosition.
	}.
}.

class Enemy superclass: Character; definition: {
	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.1, 0.1, 1.0).
	}.
}.

class Player superclass: Character; definition: {
	public field speed type: Float32.
	public field direction type: Float32x2.
	public field remainingDashTime type: Float32.
	public field dashDirection type: Float32x2.

	## Never remove the player.
	method shouldBeRemoved => Boolean8
		:= false.

	method initialize => Void := {
		halfExtent := Float32x2(0.5, 1.0).
		color := Float32x4(0.5, 0.5, 0.2, 1.0).
		speed := 3.0f.
	}.

	method dash => Void := {
		isOnFloor ifTrue: {
			remainingDashTime := 0.35f.
			dashDirection := Float32x2(lookDirection x, 0.0f).
			speed := 10.0f.
			audioMutex withLock: {
				dashSound _ reset
			}.
		}.
	}.

	method moveLeftInput: (state: Boolean8) ::=> Void := {
		state ifTrue: {
			direction x: -1.0.
			lookDirection x: -1.0.
		} ifFalse: {
			direction x < 0.0 ifTrue: {
				direction x: 0.0.
			}.
		}.
	}.

	method moveRightInput: (state: Boolean8) ::=> Void := {
		state ifTrue: {
			direction x: 1.0.
			lookDirection x: 1.0.
		} ifFalse: {
			direction x > 0.0 ifTrue: {
				direction x: 0.0.
			}.
		}.
	}.

	method jump => Void := {
		isOnFloor ifTrue: {
			velocity y: 10.0.
			remainingDashTime := 0.0f.
			audioMutex withLock: {
				jumpSound _ reset
			}.
		}.
	}.

	method shoot => Void := {
		audioMutex withLock: {
			shootSound _ reset
		}.

		let bullet mutable := Bullet nativeNew.
		bullet _
			color: Float32x4(0.8, 0.8, 0.8, 1.0);
			halfExtent: 0.2;
			shooter: self address;
			position: position;
			velocity: Float32x2(velocity x, 0.0f) + 10.0f*lookDirection;
			damage: 20.0f;
			maxFlyingTime: 0.5f.
		entities add: bullet
	}.

	override method update: (delta: Float32) ::=> Void := {
		remainingDashTime > 0.0f ifTrue: {
			remainingDashTime := remainingDashTime - delta.
			velocity x: dashDirection x * speed.
		} ifFalse: {
			velocity x: direction x * speed.
		}.

		super update: delta.

		isOnFloor ifTrue: {
			remainingDashTime <= 0.0f ifTrue: {
				speed := 3.0f
			}.
		}.
	}.
}.

class SoundChannel definition: {
	virtual method reset => Void := {
		## By default do nothing
	}.

	virtual method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		## By default do nothing.
	}.
}.

class SoundChannelWithEnvelope; superclass: SoundChannel; definition: {
	public field attackTime type: Float32.
	public field decayTime type: Float32.
	public field sustainLevel type: Float32.
	public field sustainTime type: Float32.
	public field releaseTime type: Float32.
	public field paused type: Boolean8.

	field currentSampleIndex type: UInt32.

	override method reset => Void := {
		currentSampleIndex := 0.
		paused := false.
	}.

	method computeEnvelopeFactorAt: (time: Float32) ::=> Float32 := {
		(attackTime > 0.0f) && (time < attackTime) ifTrue: {
			return: time / attackTime
		}.
		(decayTime > 0.0f) && (time < attackTime + decayTime) ifTrue: {
			return: (1.0 interpolateTo: sustainLevel at: time - attackTime / decayTime)
		}.

		(sustainTime > 0.0f) && (time < attackTime + decayTime + sustainTime) ifTrue: {
			return: sustainLevel
		}.

		(releaseTime > 0.0f) && (time < attackTime + decayTime + sustainTime + releaseTime) ifTrue: {
			return: (sustainLevel interpolateTo: 0.0 at: (time - (attackTime + decayTime + sustainTime)) / releaseTime)
		}.

		paused := true.
		return: 0.0
	}
}.

class NoiseChannel; superclass: SoundChannelWithEnvelope; definition: {
	public field amplitude type: Float32.

	field randomState type: UInt64.

	method nextRandomSample => Float32 := {
		randomState = 0 ifTrue: {randomState := 1}.

		## Xor shift generator.
		## https://en.wikipedia.org/wiki/Xorshift [January 3th, 2020]
		let x mutable := randomState.
		x := x ^ (x << 13).
		x := x ^ (x >> 7).
		x := x ^ (x << 17).
		randomState := x.

		let unormValue := (randomState castTo: Float64) / 18446744073709551615.0.
		unormValue*2.0 - 1.0 castTo: Float32
	}.

	override method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		paused ifTrue: {return: nil}.

		## Mix the samples
		0 until: sampleCount do: {:i :: Void |
			let absoluteSampleTime := (currentSampleIndex + i)*samplePeriod.
			let envelopeFactor := self computeEnvelopeFactorAt: absoluteSampleTime.
			let sample := self nextRandomSample * amplitude * envelopeFactor.
			mixBuffer[i] := mixBuffer[i] + sample
		}.

		currentSampleIndex := currentSampleIndex + sampleCount.
	}.
}.

template ToneFunctionSoundChannel(toneFunction: _FunctionType ref)
	:= class superclass: SoundChannelWithEnvelope; definition: {
	public field amplitude type: Float32.
	public field frequency type: Float32.
	public field phase type: Float32.
	public field extraParam type: Float32.

	override method mixSamples: (sampleCount: UInt32) samplePeriod: (samplePeriod: Float32) intoBuffer: (mixBuffer: Float32x2 pointer) ::=> Void := {
		paused ifTrue: {return: nil}.

		## Mix the samples
		0 until: sampleCount do: {:i :: Void |
			let absoluteSampleTime := (currentSampleIndex + i)*samplePeriod.
			let envelopeFactor := self computeEnvelopeFactorAt: absoluteSampleTime.
			let sample := toneFunction(absoluteSampleTime * frequency + phase, extraParam) * amplitude * envelopeFactor.
			mixBuffer[i] := mixBuffer[i] + sample
		}.

		currentSampleIndex := currentSampleIndex + sampleCount.
	}.
}.

compileTime constant SineChannel := ToneFunctionSoundChannel(
	function(x: Float32, _: Float32) => Float32
		:= (x * Float32 twoPi) sin
).

compileTime constant PulseChannel := ToneFunctionSoundChannel(
	function(x: Float32, pulseWidth: Float32) => Float32
		:= (x fract stepValue: pulseWidth)*2.0f - 1.0f
).

compileTime constant SawChannel := ToneFunctionSoundChannel(
	function(x: Float32, _: Float32) => Float32
		:= x fract*2.0f - 1.0f
).

global entities mutable type: (Stdn Collections Vector(Entity pointer)).
global soundChannels mutable type: (Stdn Collections Vector(SoundChannel pointer)).

global player mutable type: Player pointer.
global viewMatrix mutable type: Float32x2x3.

class MainWindowEventHandler superclass: EventHandler; definition: {
	method renderEntitiesOn: (canvas: Canvas ref) ::=> Void := {
		## Compute the view transform
		{
			canvas transform
				setIdentity;

				## Convert into NDC space.
				scaleBy: Float32x2(320.0f, -240.0f);
				translateBy: Float32x2(1.0f, -1.0f);

				## Scale the view.
				scaleBy: 0.2f;

				## Set the camera position.
				translateBy: player _ position negated + Float32x2(-2.0f, -2.0f).

		}.


		## Draw the entities.
		entities do: {:entity :: Void |
			entity _ renderOn: canvas.
		}.
	}.

	method drawHealthOn: (canvas: Canvas ref) ::=> Void := {
		## Red border
		let fullHealthRect := RectangleF32 min: Float32x2(20, 20) extent: Float32x2(250, 15).

		let healthPercentage := player _ hitPoints / 100.0f clampMin: 0.0f max: 1.0.
		let currentHealthRect := RectangleF32 min: fullHealthRect min extent: fullHealthRect extent * Float32x2(healthPercentage, 1.0f).

		canvas
			color: Float32x4(1.0f, 0.6f, 0.0f, 1.0f);
			fillRectangle: fullHealthRect;

			color: Float32x4(1.0f, 0.0f, 0.0f, 1.0f);
			drawRectangle: currentHealthRect.
	}.

	method renderHUDOn: (canvas: Canvas ref) ::=> Void := {
		canvas transform setIdentity.

		self drawHealthOn: canvas
	}.

	method render => Void := {
		let canvas := mainDrawingSurface _ beginDrawingWithCanvas.
		canvas ifNil: {return: void}.

		canvas _
			color: Float32x4(0.1f, 0.4f, 0.4f, 1.0f);
			clear.

		self
			renderEntitiesOn: canvas _;
			renderHUDOn: canvas _.
	}.

	override method onExposeEvent: (event: ExposeEvent ref) ::=> Void := {
		self render
	}.

	override method onTickEvent: (event: TickEvent ref) ::=> Void := {
		let updateDelta := event deterministicDeltaSeconds castTo: Float32.
		0 until: event deterministicFrameCount do: {
			update(updateDelta).
		}.

        self render
    }.

	override method onWindowCloseRequestEvent: (event: WindowCloseRequestEvent ref) ::=> Void := {
		mainWindow _ close
	}.

	override method onKeyPressedEvent: (event: KeyPressedEvent ref) ::=> Void := {
		event isRepeat ifTrue: {return: void}.

		event symbol selectCase: #{
		KeySymbol Escape : {mainWindow _ close}.
		KeySymbol A : {player _ moveLeftInput: true}.
		KeySymbol D : {player _ moveRightInput: true}.
		KeySymbol W : {player _ jump}.
		KeySymbol Space : {player _ shoot}.
		KeySymbol LShift : {player _ dash}.
		}
	}.

	override method onKeyReleasedEvent: (event: KeyReleasedEvent ref) ::=> Void := {
		event isRepeat ifTrue: {return: void}.

		event symbol selectCase: #{
		KeySymbol A : {player _ moveLeftInput: false}.
		KeySymbol D : {player _ moveRightInput: false}.
		}
	}.
}.

function update(delta: Float32) => Void := {
	entities do: {:entity :: Void |
		entity _ update: delta.
	}.

	## Remove the dead entities
	let destIndex mutable type: UIntPointer := 0.
	0 until: entities size do: {:i :: Void |
		let entity := entities[i].
		entity _ shouldBeRemoved ifTrue: {
			entity nativeDelete
		} ifFalse: {
			entities[destIndex] := entity.
			destIndex := destIndex + 1
		}.
	}.
	entities resizeTo: destIndex.
}.

function mixAudioSamples(mixBuffer: Float32x2 pointer, sampleCount: UInt32) => Void := {
	let samplePeriod := 1.0f / audioDeviceSpec freq.

	## Clear the mixing buffer.
	Stdn memset(mixBuffer, 0, sampleCount * Float32x2 instanceSize).

	audioMutex withLock: {
		## Add each one of the sound channels into the mixing buffer.
		soundChannels do: {:channel :: Void |
			channel _ mixSamples: sampleCount samplePeriod: samplePeriod intoBuffer: mixBuffer
		}.
	}.
}.

function audioCallback(userdata: Void pointer, stream: UInt8 pointer, len: Int32) => Void := {
	let channels := audioDeviceSpec channels.
	let sampleByteSize := audioDeviceSpec sampleByteSize.
	let sampleCount := len / (sampleByteSize * channels) castTo: UInt32.

	audioDeviceSpec format = AUDIO_F32 ifTrue: {
		mixAudioSamples(stream reinterpretCastTo: Float32x2 pointer, sampleCount).
		return: nil
	}.

	mixAudioSamples(audioTemporaryBuffer, sampleCount).

	audioDeviceSpec format selectCase: #{
		AUDIO_S16 : {
			let targetBuffer := stream reinterpretCastTo: Int16x2 pointer.
			0 until: sampleCount do: {:i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample clampMin: -1.0 max: 1.0)*32767.0 castTo: Int16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		AUDIO_U16 : {
			let targetBuffer := stream reinterpretCastTo: UInt16x2 pointer.
			0 until: sampleCount do: {:i :: Void |
				let sample := audioTemporaryBuffer[i].
				let convertedSample := (sample*0.5 + 0.5 clampMin: 0.0 max: 1.0)*65535.0 castTo: UInt16x2.
				targetBuffer[i] := convertedSample.
			}.
		}.
		let _ : {
			Stdn memset(stream, 0, len).
		}.
	}.
}.

method createWallMin: (min: Float32x2) max: (max: Float32x2) color: (color: Float32x4) ::=> Void := {
	let wall mutable := Wall nativeNew.
	wall _
		position: (max + min) *0.5f;
		halfExtent: (max - min) *0.5f;
		color: color.
	entities add: wall.
}.

function main externC (argc: Int32, argv: Char8 const pointer pointer) => Int32 := {
	## Create the window system.
	let windowSystem := createWindowSystem().
	windowSystem _ targetFrameRate: 60.

	## Create the main window.
    mainWindow := windowSystem _ createWindowWithTitle: "Sample Native Game" asMutableString extent: Int32x2(640, 480).
    mainWindow ifNil: {
        return: 0.
    }.

    ## Create the main window drawing surface.
    mainDrawingSurface := mainWindow _ createDefaultDrawingSurface.
    mainDrawingSurface ifNil: {
        return: 0.
    }.

	## Create the event handler.
    {
        let eventHandler := MainWindowEventHandler sharedNew.
        mainWindow _ eventHandler: (eventHandler upCastFor: EventHandler)
    }.

	{
		let desiredAudioSpec mutable := SDL_AudioSpec newValue
			freq: 48000;
			format: AUDIO_S16;
			channels: 2;
			samples: 2048;
			callback: audioCallback address;
			yourself.
		audioDeviceID := SDL_OpenAudioDevice(nil, 0, desiredAudioSpec address, audioDeviceSpec address, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_FORMAT_CHANGE | SDL_AUDIO_ALLOW_SAMPLES_CHANGE).
		audioDeviceSpec format ~= AUDIO_F32 ifTrue: {
			audioTemporaryBuffer := Stdn malloc(audioDeviceSpec samples * 8) reinterpretCastTo: Float32x2 pointer.
		}.
	}.

	## Create the floor
	{
		createWallMin: Float32x2(-5.0f, -5.0f) max: Float32x2(20.0f, -4.0f) color: Float32x4(0.2f, 0.2f, 0.2f, 0.2f).

		createWallMin: Float32x2(3.0f, -1.0f) max: Float32x2(8.0f, 0.0f) color: Float32x4(0.2f, 0.2f, 0.2f, 0.2f).
	}.

	{
		player := Player nativeNew.
		entities add: player.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(4.0, 2.0).
		entities add: enemy.
	}.

	{
		let enemy mutable := Enemy nativeNew.
		enemy _ position: Float32x2(15.0, 0.0).
		entities add: enemy.
	}.

	## Shoot sound.
	{
		let pulseChannel mutable := PulseChannel nativeNew.
		pulseChannel _
			frequency: 150.0;
			amplitude: 0.1;
			extraParam: 0.15;

			paused: true;

			attackTime: 0.025;
			decayTime: 0.025;
			sustainLevel: 0.4;
			sustainTime: 0.1;
			releaseTime: 0.3.

		shootSound := pulseChannel.
		soundChannels add: pulseChannel.
	}.

	## Jump sound.
	{
		let noiseChannel mutable := NoiseChannel nativeNew.
		noiseChannel _
			amplitude: 0.1;

			paused: true;

			attackTime: 0.015f;
			decayTime: 0.015f;
			sustainLevel: 0.2f;
			sustainTime: 0.05f;
			releaseTime: 0.1f.
		jumpSound := noiseChannel.
		soundChannels add: noiseChannel.
	}.

	## Dash sound.
	{
		let noiseChannel mutable := NoiseChannel nativeNew.
		noiseChannel _
			amplitude: 0.1;

			paused: true;

			attackTime: 0.025f;
			decayTime: 0.02f;
			sustainLevel: 0.2f;
			sustainTime: 0.1f;
			releaseTime: 0.2f.
		dashSound := noiseChannel.
		soundChannels add: noiseChannel.
	}.

	audioDeviceID ~= 0 ifTrue: {
		SDL_PauseAudioDevice(audioDeviceID, 0).
	}.

	## Enter into the main loop.
	windowSystem _ runMainLoop.

	audioDeviceID ~= 0 ifTrue: {
		SDL_CloseAudioDevice(audioDeviceID).
		Stdn free(audioTemporaryBuffer).
	}.

	entities do: #nativeDelete.
	soundChannels do: #nativeDelete.

	SDL_Quit().

    return: 0.
}.
