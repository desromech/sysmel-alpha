Compiler
	importModuleNamed: #"Sysmel.Graphics.Headfull".

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

let mainWindow mutable type: Window sharedPointer.
let mainDrawingSurface mutable type: Surface sharedPointer.
let fontFaceWithSize mutable type: FontFaceWithSize sharedPointer.

let currentTime mutable type: Float32.
let lastFrameRenderingTime mutable type: Float32.

let colorBuffer mutable type: Form sharedPointer.
let colorBufferTextureView mutable type: TextureView sharedPointer.
let depthBuffer mutable type: Form sharedPointer.

let cameraOrientation mutable := Float32x3x3 identity.
let cameraPosition mutable := Float32x3(0, 1, 3).
let cameraAngle mutable := Float32x3(0, 0, 0).

let projectionMatrix mutable type: Float32x4x4.
let viewMatrix mutable type: Float32x4x4.
let modelMatrix mutable type: Float32x4x4.

class Mesh definition: {
	public field vertices type: Stdn Collections Vector(Float32x4).
	public field indices type: Stdn Collections Vector(UInt32).

	method addVertex: (p: Float32x3) ::=> Void := {
		vertices add: Float32x4(p, 1)
	}.

	method addVertex: (p: Float32x4) ::=> Void := {
		vertices add: p
	}.

	method addTriangle: (i1: UInt32) i2: (i2: UInt32) i3: (i3: UInt32) ::=> Void := {
		indices
			add: i1; add: i2; add: i3
	}.

	method addQuad: (i1: UInt32) i2: (i2: UInt32) i3: (i3: UInt32) i4: (i4: UInt32) ::=> Void := {
		indices
			add: i1; add: i2; add: i4;
			add: i4; add: i3; add: i1
	}.

}.

let planeMesh mutable type: Mesh.
let cubeMesh mutable type: Mesh.

compileTime constant ClipEpsilon := 0.00001f.
let ClipPlane := Float32x4(0f, 0f, 0f, 1f).

inline function isFrontPoint(p: Float32x4) => Boolean8 := {
	(p dot: ClipPlane) > ClipEpsilon.
}.
inline function intersectSegmentWithFrontPlane(pa: Float32x4, pb: Float32x4) => Float32x4 := {
	let d := pb - pa.
	##let t := (ClipEpsilon - pa w) / d w.
	let t := (ClipEpsilon - (pa dot: ClipPlane)) / (d dot: ClipPlane).
	let result := pa + t*d.
	## Stdn stdout << pa << "|" << pb << " -> " << result; nl.
	result.
}.

class SoftwareGraphicsPipeline definition: {
	public field colorBufferBlitter type: Blitter.
	public field depthStencilBufferBlitter type: Blitter.

	public method drawClippedTriangleP1: (p1: Float32x4) p2: (p2: Float32x4) p3: (p3: Float32x4) fragmentShader: (fragmentShader: (Float32x3 => Float32x4) nativeBlockClosure) ::=> Void := {
		let extent := colorBufferBlitter extent castTo: Float32x2.
		##let viewportTransform := (Float32x2x2 scale: extent) * Float32x2x3(Float32x2(0.5f, 0.0f), Float32x2(0.0f, -0.5f), Float32x2(0.5f, 0.5f)).
		let viewportTransform := (Float32x2x2 scale: extent) * Float32x2x3(Float32x2(0.5f, 0.0f), Float32x2(0.0f, 0.5f), Float32x2(0.5f, 0.5f)).

		let iw1 := 1.0f / p1 w.
		let iw2 := 1.0f / p2 w.
		let iw3 := 1.0f / p3 w.

		let w := Float32x3(p1 w, p2 w, p3 w).

		let sv1 := viewportTransform * Float32x3(p1 xy / p1 w, 1).
		let sv2 := viewportTransform * Float32x3(p2 xy / p2 w, 1).
		let sv3 := viewportTransform * Float32x3(p3 xy / p3 w, 1).

		(sv2 - sv1 cross: sv3 - sv1) >= 0 ifTrue: {
			return: void
		}.

		colorBufferBlitter
			blendTriangle: sv1 p2: sv2 p3: sv3 pixelsWith: {:(Float32x2)p :(Float32x3)barycentricCoordinates :(Float32x4)originalDestPixelValue :: Float32x4 |
				let bc := barycentricCoordinates / w.

				fragmentShader(bc / (bc dot: Float32x3 ones))
		}.
	}.


	public method drawTriangleP1: (p1: Float32x4) p2: (p2: Float32x4) p3: (p3: Float32x4) fragmentShader: (fragmentShader: (Float32x3 => Float32x4) nativeBlockClosure) ::=> Void := {
		let sourcePolygon mutable type: (Float32x4 array: 4).
		sourcePolygon[0] := p1.
		sourcePolygon[1] := p2.
		sourcePolygon[2] := p3.
		sourcePolygon[3] := p1.

		let sourcePolygonInFront mutable type: (Boolean8 array: 4).
		sourcePolygonInFront[0] := isFrontPoint(p1).
		sourcePolygonInFront[1] := isFrontPoint(p2).
		sourcePolygonInFront[2] := isFrontPoint(p3).
		sourcePolygonInFront[3] := sourcePolygonInFront[0].

		## Passthrough the not clipped polygon.
		sourcePolygonInFront[0] && sourcePolygonInFront[1] && sourcePolygonInFront[2] ifTrue: {
			self drawClippedTriangleP1: p1 p2: p2 p3: p3 fragmentShader: fragmentShader.
			return: void
		}.

		## Discard the completely clipped polygon.
		sourcePolygonInFront[0] not && sourcePolygonInFront[1] not && sourcePolygonInFront[2] not ifTrue: {
			return: void
		}.

		let clippedPolygon mutable type: (Float32x4 array: 6).
		let clippedPolygonDestIndex mutable type: UIntPointer.
		0 until: 3 do: {:i :: Void|
			let pa := sourcePolygon[i].
			let pb := sourcePolygon[i + 1].

			let fa := sourcePolygonInFront[i].
			let fb := sourcePolygonInFront[i + 1].

			fa && fb ifTrue: {
				clippedPolygon[clippedPolygonDestIndex] := pa.
				clippedPolygonDestIndex := clippedPolygonDestIndex + 1
			}.
			fa not && fb ifTrue: {
				clippedPolygon[clippedPolygonDestIndex] := intersectSegmentWithFrontPlane(pa, pb).
				clippedPolygonDestIndex := clippedPolygonDestIndex + 1
			}.
			fa && fb not ifTrue: {
				clippedPolygon[clippedPolygonDestIndex] := pa.
				clippedPolygon[clippedPolygonDestIndex + 1] := intersectSegmentWithFrontPlane(pa, pb).
				clippedPolygonDestIndex := clippedPolygonDestIndex + 2
			}.
		}.

		## Stdn stdout << "clippedPolygonDestIndex " << clippedPolygonDestIndex; nl.
		clippedPolygonDestIndex >= 3 ifTrue: {
			self drawClippedTriangleP1: clippedPolygon[0] p2: clippedPolygon[1] p3: clippedPolygon[2] fragmentShader: {:(Float32x3)barycentricCoordinates :: Float32x4 |
				Float32x4 red
			}.

			clippedPolygonDestIndex >= 4 ifTrue: {
				self drawClippedTriangleP1: clippedPolygon[0] p2: clippedPolygon[2] p3: clippedPolygon[3] fragmentShader: {:(Float32x3)barycentricCoordinates :: Float32x4 |
					Float32x4 blue
				}.
			}
		}.
	}.

}.

function fuzzyXor(a: Float32, b: Float32) => Float32 := {
	(a max: b) - (a min: b)
}.


Mesh definition: {
	method drawOn: (pipeline: SoftwareGraphicsPipeline ref) ::=> Void := {
		let nextSourceIndex mutable := 0.
		let projectionModelViewMatrix := projectionMatrix * (viewMatrix * modelMatrix).
		0 until: indices size / 3 do: {:triangleIndex :: Void |
			let v1 := vertices[indices[nextSourceIndex]].
			let v2 := vertices[indices[nextSourceIndex + 1]].
			let v3 := vertices[indices[nextSourceIndex + 2]].

			let N := ((v2 xyz - v1 xyz) cross: (v3 xyz - v1 xyz)) normalized.

			let c1 := Float32x4 red.
			let c2 := Float32x4 green.
			let c3 := Float32x4 blue.

			let pv1 := projectionModelViewMatrix * v1.
			let pv2 := projectionModelViewMatrix * v2.
			let pv3 := projectionModelViewMatrix * v3.

			pipeline drawTriangleP1: pv1 p2: pv2 p3: pv3 fragmentShader: {:(Float32x3)barycentricCoordinates :: Float32x4 |
				##let v := v1*barycentricCoordinates x + v2*barycentricCoordinates y + v3*barycentricCoordinates z.
				##let v := Float32x3x3(v1, v2, v3) * barycentricCoordinates.

				let c := barycentricCoordinates * (Float32x3x4 rows: (c1, c2, c3)).
				let vh := barycentricCoordinates * (Float32x3x4 rows: (v1, v2, v3)).
				let v := vh xyz / vh w.

				let x := v.
				let edge := 0.48f smoothStepTo: 0.52f value: 2*(x - (x + 0.5f) floor) abs. ##((x - x floor)*2 - 1) abs.
				let aliasFactor := 10.0f smoothStepTo: 30.0f value: v length.

				let stipple := fuzzyXor(fuzzyXor(edge x, edge y), edge z) interpolateTo: 0.5f at: aliasFactor.
				let albedo := stipple * Float32x3(1,1,1).
				## let albedo := edge.
				let L := Float32x3(1, 1, 1) normalized.
				let NdotL := (N dot: L) max: 0.0f.

				Float32x4(albedo*(0.2f + 0.8f*NdotL), 1.0f).
				##Float32x4(N *0.5f + 0.5f, 1.0f).
			}.

			##Stdn stdout << "tv1 " << tv1; nl.
			##Stdn stdout << "tv2 " << tv2; nl.
			##Stdn stdout << "tv3 " << tv3; nl.

			nextSourceIndex := nextSourceIndex + 3
		}
	}.
}.

function doRender3D => Void := {
	let pipeline mutable type: SoftwareGraphicsPipeline.
	pipeline
		colorBufferBlitter: colorBuffer _ makeBlitter;
		depthStencilBufferBlitter: depthBuffer _ makeBlitter.

	pipeline colorBufferBlitter setAllPixelsToColor: UInt8x4(64, 64 , 64, 64). ##Float32x4 zeros.
	pipeline depthStencilBufferBlitter setAllPixelsToColor: UInt8x4 zeros.

	modelMatrix := Float32x4x4 identity.
	planeMesh drawOn: pipeline.

	modelMatrix := Float32x4x4 translation: Float32x3(0, 1, 0).
	cubeMesh drawOn: pipeline.
}.

function doRenderOn(canvas: Canvas ref) => Void := {
	doRender3D().

	canvas
		copyTexture: colorBufferTextureView at: Float32x2 zeros.

	{
		let frameTime := lastFrameRenderingTime * 1000.0f.
		let frameTimeString := Stdn String textStreamContents: {:out :: Void |
			out << "Current time " << currentTime; nl.
			out << "Rendering time " << frameTime << " ms"; nl.
		}.

		canvas
			fontFaceWithSize: fontFaceWithSize;
			color: Float32x4 green;
			drawUTF8String: frameTimeString at: Float32x2(15.0f, 30.0f).
	}.

}.

class MainWindowEventHandler superclass: EventHandler; definition: {
    method render ::=> Void := {
		let canvas := mainDrawingSurface _ beginDrawingWithCanvas.
		canvas ifNil: {return: void}.

		lastFrameRenderingTime := (Stdn Chrono profileTimeToRun: {
			doRenderOn(canvas _).
		}) castTo: Float32.
    }.

    override method onTickEvent: (event: TickEvent ref) ::=> Void := {
        currentTime := event seconds castTo: Float32.

		cameraOrientation := (Float32x3x3 yRotation: cameraAngle y) * (Float32x3x3 xRotation: cameraAngle x).
		viewMatrix := (Float32x4x4 mat3: cameraOrientation transpose)*(Float32x4x4 translation: cameraPosition negated).

        self render
    }.

    override method onExposeEvent: (event: ExposeEvent ref) ::=> Void := {
        self render
    }.

    override method onWindowCloseRequestEvent: (event: WindowCloseRequestEvent ref) ::=> Void := {
        mainWindow _ close
    }.

	override method onMouseMoveEvent: (event: MouseMoveEvent ref) ::=> Void := {
		event isLeftButtonPressed ifTrue: {
			cameraAngle := cameraAngle + Float32x3(event delta y negated, event delta x negated, 0.0f)*0.01f.
		}.

		event isRightButtonPressed ifTrue: {
			cameraPosition := cameraPosition + cameraOrientation * Float32x3(event delta x, event delta y negated , 0.0f) *0.01f.
		}.
    }.

	override method onMouseWheelEvent: (event: MouseWheelEvent ref) ::=> Void := {
		cameraPosition := cameraPosition + cameraOrientation * Float32x3(0.0f, 0.0f, event scrollDelta y * -0.1f).
    }.
}.

function main externC (argc: Int32, argv: UInt8 const pointer pointer) => Int32 := {
    let windowSystem mutable := createWindowSystem().
    windowSystem ifNil: {
        return: 0
    }.
    windowSystem _ targetFrameRate: 60.

    ## Create the main window.
    mainWindow := windowSystem _ createWindowWithTitle: "Test Window" asMutableString extent: Int32x2(640, 480).
    mainWindow ifNil: {
        return: 0.
    }.

    ## Create the main window drawing surface.
    mainDrawingSurface := mainWindow _ createDefaultDrawingSurface.
    mainDrawingSurface ifNil: {
        return: 0.
    }.

	## Create the color and depth buffer.
	colorBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat B8G8R8A8_UNormSRGB.
	colorBufferTextureView := FormTextureView for: colorBuffer.
	depthBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat D32_Float.

	## Set the projection and model view matrix.
	## projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: false.
	projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: true.

    ## Use the default font face.
    let fontFace mutable := FontRegistry default defaultSans _ normalFace.
    fontFaceWithSize := fontFace _ getOrCreateFaceWithSize: 12.

	## Build the plane
	{
		planeMesh
			addVertex: Float32x3(0, 0, 0);
			addVertex: Float32x4(-1, 0, -1, 0);
			addVertex: Float32x4(1, 0, -1, 0);
			addVertex: Float32x4(-1, 0, 1, 0);
			addVertex: Float32x4(1, 0, 1, 0);

			addTriangle: 0 i2: 2 i3: 1;
			addTriangle: 0 i2: 4 i3: 2;
			addTriangle: 0 i2: 3 i3: 4;
			addTriangle: 0 i2: 1 i3: 3
	}.

	## Build the cube
	{
		cubeMesh
			addVertex: Float32x3(-1, -1, -1);
			addVertex: Float32x3(1, -1, -1);
			addVertex: Float32x3(-1, 1, -1);
			addVertex: Float32x3(1, 1, -1);

			addVertex: Float32x3(-1, -1, 1);
			addVertex: Float32x3(1, -1, 1);
			addVertex: Float32x3(-1, 1, 1);
			addVertex: Float32x3(1, 1, 1);

			addQuad: 2 i2: 0 i3: 6 i4: 4;
			addQuad: 1 i2: 3 i3: 5 i4: 7;

			addQuad: 0 i2: 1 i3: 4 i4: 5;
			addQuad: 3 i2: 2 i3: 7 i4: 6;

			addQuad: 1 i2: 0 i3: 3 i4: 2;
			addQuad: 4 i2: 5 i3: 6 i4: 7.
	}.

    ## Create the event handler.
    {
        let eventHandler := MainWindowEventHandler sharedNew.
        mainWindow _ eventHandler: (eventHandler upCastFor: EventHandler)
    }.

    ## Run the actual main loop.
    return: windowSystem _ runMainLoop.
}.
