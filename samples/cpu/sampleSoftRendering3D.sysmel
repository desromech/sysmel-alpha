Compiler
	importModuleNamed: #"Sysmel.Graphics.Headfull".

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

let mainWindow mutable type: Window sharedPointer.
let mainDrawingSurface mutable type: Surface sharedPointer.
let fontFaceWithSize mutable type: FontFaceWithSize sharedPointer.

let currentTime mutable type: Float32.
let lastFrameRenderingTime mutable type: Float32.

let colorBuffer mutable type: Form sharedPointer.
let colorBufferTextureView mutable type: TextureView sharedPointer.
let depthBuffer mutable type: Form sharedPointer.

let cameraOrientation mutable := Float32x3x3 identity.
let cameraPosition mutable := Float32x3(0, 0, 3).
let cameraAngle mutable := Float32x3(0, 0, 0).

let projectionMatrix mutable type: Float32x4x4.
let viewMatrix mutable type: Float32x4x4.
let modelViewMatrix mutable type: Float32x4x4.

let meshVertices mutable type: Stdn Collections Vector(Float32x3).
let meshIndices mutable type: Stdn Collections Vector(UInt32).

function addQuad(i1: UInt32, i2: UInt32, i3: UInt32, i4: UInt32) => Void := {
	meshIndices
		add: i1; add: i2; add: i4;
		add: i4; add: i3; add: i1
}.

class SoftwareGraphicsPipeline definition: {
	public field colorBufferBlitter type: Blitter.
	public field depthStencilBufferBlitter type: Blitter.

	public method drawTriangleP1: (p1: Float32x4) p2: (p2: Float32x4) p3: (p3: Float32x4) fragmentShader: (fragmentShader: (Float32x3 => Float32x4) nativeBlockClosure) ::=> Void := {
		let extent := colorBufferBlitter extent castTo: Float32x2.
		let iw1 := 1.0f / p1 w.
		let iw2 := 1.0f / p2 w.
		let iw3 := 1.0f / p3 w.

		let w := Float32x3(p1 w, p2 w, p3 w).

		let sv1 := ((p1 xy / p1 w)*0.5 + 0.5) * extent.
		let sv2 := ((p2 xy / p2 w)*0.5 + 0.5) * extent.
		let sv3 := ((p3 xy / p3 w)*0.5 + 0.5) * extent.

		(sv2 - sv1 cross: sv3 - sv1) < 0 ifTrue: {
			return: void
		}.

		colorBufferBlitter
            blendTriangle: sv1 p2: sv2 p3: sv3 pixelsWith: {:(Float32x2)p :(Float32x3)barycentricCoordinates :(Float32x4)originalDestPixelValue :: Float32x4 |
				let bc := barycentricCoordinates / w.

				fragmentShader(bc / (bc dot: Float32x3 ones))
        }.
	}.
}.

function doRender3D => Void := {
	let pipeline mutable type: SoftwareGraphicsPipeline.
	pipeline
		colorBufferBlitter: colorBuffer _ makeBlitter;
		depthStencilBufferBlitter: depthBuffer _ makeBlitter.

	pipeline colorBufferBlitter setAllPixelsToColor: UInt8x4(127, 127 , 127, 127). ##Float32x4 zeros.
	pipeline depthStencilBufferBlitter setAllPixelsToColor: UInt8x4 zeros.

	let nextSourceIndex mutable := 0.
	0 until: meshIndices size / 3 do: {:triangleIndex :: Void |
		let v1 := meshVertices[meshIndices[nextSourceIndex]].
		let v2 := meshVertices[meshIndices[nextSourceIndex + 1]].
		let v3 := meshVertices[meshIndices[nextSourceIndex + 2]].

		let c1 := Float32x4 red.
		let c2 := Float32x4 green.
		let c3 := Float32x4 blue.

		let pv1 := projectionMatrix * (modelViewMatrix * Float32x4(v1, 1)).
		let pv2 := projectionMatrix * (modelViewMatrix * Float32x4(v2, 1)).
		let pv3 := projectionMatrix * (modelViewMatrix * Float32x4(v3, 1)).

		pipeline drawTriangleP1: pv1 p2: pv2 p3: pv3 fragmentShader: {:(Float32x3)barycentricCoordinates :: Float32x4 |
			##let v := v1*barycentricCoordinates x + v2*barycentricCoordinates y + v3*barycentricCoordinates z.
			##let v := Float32x3x3(v1, v2, v3) * barycentricCoordinates.

			let c := barycentricCoordinates * (Float32x3x4 rows: (c1, c2, c3)).
			let v := barycentricCoordinates * (Float32x3x3 rows: (v1, v2, v3)).

			let x := v.
			let edge := 0.48f smoothStepTo: 0.52f value: 2*(x - (x + 0.5f) floor) abs. ##((x - x floor)*2 - 1) abs.

			Float32x4(edge, 1.0f).
		}.

		##Stdn stdout << "tv1 " << tv1; nl.
		##Stdn stdout << "tv2 " << tv2; nl.
		##Stdn stdout << "tv3 " << tv3; nl.

		nextSourceIndex := nextSourceIndex + 3
	}
}.

function doRenderOn(canvas: Canvas ref) => Void := {
	doRender3D().

	canvas
		copyTexture: colorBufferTextureView at: Float32x2 zeros.

	{
		let frameTime := lastFrameRenderingTime * 1000.0f.
		let frameTimeString := Stdn String textStreamContents: {:out :: Void |
			out << "Current time " << currentTime; nl.
			out << "Rendering time " << frameTime << " ms"; nl.
		}.

		canvas
			fontFaceWithSize: fontFaceWithSize;
			color: Float32x4 green;
			drawUTF8String: frameTimeString at: Float32x2(15.0f, 30.0f).
	}.

}.

class MainWindowEventHandler superclass: EventHandler; definition: {
    method render ::=> Void := {
		let canvas := mainDrawingSurface _ beginDrawingWithCanvas.
		canvas ifNil: {return: void}.

		lastFrameRenderingTime := (Stdn Chrono profileTimeToRun: {
			doRenderOn(canvas _).
		}) castTo: Float32.
    }.

    override method onTickEvent: (event: TickEvent ref) ::=> Void := {
        currentTime := event seconds castTo: Float32.

		cameraOrientation := (Float32x3x3 yRotation: cameraAngle y) * (Float32x3x3 xRotation: cameraAngle x).
		viewMatrix := (Float32x4x4 mat3: cameraOrientation transpose)*(Float32x4x4 translation: cameraPosition negated).
		modelViewMatrix := viewMatrix.

        self render
    }.

    override method onExposeEvent: (event: ExposeEvent ref) ::=> Void := {
        self render
    }.

    override method onWindowCloseRequestEvent: (event: WindowCloseRequestEvent ref) ::=> Void := {
        mainWindow _ close
    }.

	override method onMouseMoveEvent: (event: MouseMoveEvent ref) ::=> Void := {
		event isLeftButtonPressed ifTrue: {
			cameraAngle := cameraAngle + Float32x3(event delta y, event delta x negated, 0.0f)*0.01f.
		}.

		event isRightButtonPressed ifTrue: {
			cameraPosition := cameraPosition + cameraOrientation * Float32x3(event delta x, event delta y, 0.0f) *0.01f.
		}.
    }.

	override method onMouseWheelEvent: (event: MouseWheelEvent ref) ::=> Void := {
		cameraPosition := cameraPosition + cameraOrientation * Float32x3(0.0f, 0.0f, event scrollDelta y * -0.1f).
    }.
}.

function main externC (argc: Int32, argv: UInt8 const pointer pointer) => Int32 := {
    let windowSystem mutable := createWindowSystem().
    windowSystem ifNil: {
        return: 0
    }.
    windowSystem _ targetFrameRate: 60.

    ## Create the main window.
    mainWindow := windowSystem _ createWindowWithTitle: "Test Window" asMutableString extent: Int32x2(640, 480).
    mainWindow ifNil: {
        return: 0.
    }.

    ## Create the main window drawing surface.
    mainDrawingSurface := mainWindow _ createDefaultDrawingSurface.
    mainDrawingSurface ifNil: {
        return: 0.
    }.

	## Create the color and depth buffer.
	colorBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat B8G8R8A8_UNormSRGB.
	colorBufferTextureView := FormTextureView for: colorBuffer.
	depthBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat D32_Float.

	## Set the projection and model view matrix.
	projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: false.

    ## Use the default font face.
    let fontFace mutable := FontRegistry default defaultSans _ normalFace.
    fontFaceWithSize := fontFace _ getOrCreateFaceWithSize: 12.

	## Build the cube
	{
		meshVertices
			add: Float32x3(-1, -1, -1);
			add: Float32x3(1, -1, -1);
			add: Float32x3(-1, 1, -1);
			add: Float32x3(1, 1, -1);

			add: Float32x3(-1, -1, 1);
			add: Float32x3(1, -1, 1);
			add: Float32x3(-1, 1, 1);
			add: Float32x3(1, 1, 1).

		addQuad(2, 0, 6, 4).
		addQuad(1, 3, 5, 7).

		addQuad(0, 1, 4, 5).
		addQuad(3, 2, 7, 6).

		addQuad(1, 0, 3, 2).
		addQuad(4, 5, 6, 7).
	}.

    ## Create the event handler.
    {
        let eventHandler := MainWindowEventHandler sharedNew.
        mainWindow _ eventHandler: (eventHandler upCastFor: EventHandler)
    }.

    ## Run the actual main loop.
    return: windowSystem _ runMainLoop.
}.
