Compiler
	importModuleNamed: #"Sysmel.Graphics.Headfull".

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

struct SimpleVertex definition: {
	public field position type: Float32x4.
	public field color type: Float32x4.
	public field normal type: Float32x3.
}.

let simpleVertexLayout mutable type: VertexLayoutPtr.

class CameraTransformationState definition: {
	public field viewMatrix type: Float32x4x4.
    public field projectionMatrix type: Float32x4x4.
}.

class CameraState definition: {
    public field transformationState type: CameraTransformationState uniformBufferPointer.
}.

class ObjectTransformationState definition: {
    public field modelMatrix type: Float32x4x4.
}.

class ObjectState definition: {
    public field transformationState type: ObjectTransformationState uniformBufferPointer.
}.

class CheckboardShader definition: {
	public field cameraState type: CameraState bindingSetPointer.
	public field objectState type: ObjectState bindingSetPointer.

	class VertexIO definition: {
		public field position type: Float32x4; location: 0.
		public field color type: Float32x4; location: 1.
		public field normal type: Float32x3; location: 2.
    }.

	class FragmentOutput definition: {
		public field color0 type: Float32x4; location: 0.
    }.

    function vertex vertexShader(in: VertexIO inputChannel, out: VertexIO outputChannel, stageOut: GPU VertexStageOutput outputChannel) => Void := {
        let input := in receive.

		let worldPosition := objectState _ transformationState _ modelMatrix * input position.
		let viewPosition := cameraState _ transformationState _ viewMatrix * worldPosition.
		let screenPosition := cameraState _ transformationState _ projectionMatrix * viewPosition.

		let output mutable := input.
		output position: worldPosition.
		out send: output.

        stageOut send: (GPU VertexStageOutput()
            screenPosition: screenPosition;
            yourself
        ).
    }.

    function fragment fragmentShader(stageIn: VertexIO inputChannel, out: FragmentOutput outputChannel) => Void := {
        let input := stageIn receive.

		let P := input position xyz / input position w.
		let N := input normal normalized.
		let L := Float32x3(1, 1, 1) normalized.

		let x := P.
		let edge := 0.48f smoothStepTo: 0.52f value: 2*(x - (x + 0.5f) floor) abs. ##((x - x floor)*2 - 1) abs.
		let aliasFactor := 10.0f smoothStepTo: 30.0f value: P length.

		let stipple := fuzzyXor(fuzzyXor(edge x, edge y), edge z) interpolateTo: 0.5f at: aliasFactor.
		let albedo := stipple * Float32x3(1,1,1).
		## let albedo := edge.
		let NdotL := (N dot: L) max: 0.0f.

		let result := Float32x4(albedo*(0.2f + 0.8f*NdotL), 1.0f).
		##let result := Float32x4(N*0.5f + 0.5f, 1.0f).

        out send: (FragmentOutput() color0: result)
    }.
}.

let mainWindow mutable type: Window sharedPointer.
let mainDrawingSurface mutable type: Surface sharedPointer.
let fontFaceWithSize mutable type: FontFaceWithSize sharedPointer.
let renderingDevice mutable type: RenderingDevicePtr.

let shaderSignature mutable type: ShaderSignaturePtr.

let currentTime mutable type: Float32.
let lastFrameRenderingTime mutable type: Float32.

let renderingCommandQueue mutable type: CommandQueuePtr.
let commandListAllocator mutable type: CommandListAllocatorPtr.
let commandList mutable type: CommandListPtr.

let colorBuffer mutable type: Form sharedPointer.
let colorBufferTextureView mutable type: TextureView sharedPointer.
let depthBuffer mutable type: Form sharedPointer.
let mainFrameBuffer mutable type: FramebufferPtr.
let mainRenderPass mutable type: RenderPassPtr.

let cameraOrientation mutable := Float32x3x3 identity.
let cameraPosition mutable := Float32x3(0, 1, 3).
let cameraAngle mutable := Float32x3(0, 0, 0).

let renderingPipelineState mutable type: PipelineStatePtr.

let projectionMatrix mutable type: Float32x4x4.
let viewMatrix mutable type: Float32x4x4.
let modelMatrix mutable type: Float32x4x4.

let cameraStateBuffer mutable type: BufferPtr.
let cameraStateBinding mutable type: ShaderResourceBindingsPtr.

let cubeObjectStateBuffer mutable type: BufferPtr.
let cubeObjectStateBinding mutable type: ShaderResourceBindingsPtr.

let planeObjectStateBuffer mutable type: BufferPtr.
let planeObjectStateBinding mutable type: ShaderResourceBindingsPtr.

##let currentTransformationState mutable type: TransformationState.
##let currentObjectState mutable type: ObjectState.

class Mesh definition: {
	public field vertexBinding type: VertexBindingPtr.
	public field indexBuffer type: BufferPtr.
	public field indexCount type: UInt32.
}.
compileTime constant MeshPtr := Mesh sharedPointer.

class MeshBuilder definition: {
	public field baseVertex type: UInt32.
	public field vertices type: Stdn Collections Vector(SimpleVertex).
	public field indices type: Stdn Collections Vector(UInt32).

	method beginSubmesh => Void := {
		baseVertex := vertices size castTo: UInt32.
	}.

	method addVertex: (p: Float32x3) normal: (n: Float32x3) ::=> Void := {
		self addVertex: Float32x4(p, 1) normal: n
	}.

	method addVertex: (p: Float32x3) normal: (n: Float32x3) texcoord: (tc: Float32x2)::=> Void := {
		self addVertex: Float32x4(p, 1) normal: n texcoord: tc
	}.

	method addVertex: (p: Float32x4) normal: (n: Float32x3) ::=> Void := {
		self addVertex: p normal: n texcoord: 0
	}.

	method addVertex: (p: Float32x4) normal: (n: Float32x3) texcoord: (tc: Float32x2) ::=> Void := {
		vertices add: (SimpleVertex()
			position: p;
			normal: n;
			color: Float32x4 ones;
			yourself)
	}.

	method addTriangle: (i1: UInt32) i2: (i2: UInt32) i3: (i3: UInt32) ::=> Void := {
		indices
			add: i1 + baseVertex; add: i2 + baseVertex; add: i3 + baseVertex
	}.

	method finish => MeshPtr := {
		let vertexBuffers mutable := BufferPtr array (
			renderingDevice _ createBuffer: (BufferDescription()
				size: vertices size * SimpleVertex instanceSize;
				heapType: MemoryHeapType DeviceLocal;
				usageMode: BufferUsageMode Array;
				mainUsageMode: BufferUsageMode Array;
				stride: SimpleVertex instanceSize;
				yourself) initialData: vertices asArraySlice elements
		).

		let indexBuffer := renderingDevice _ createBuffer: (BufferDescription()
			size: indices size * 4;
			heapType: MemoryHeapType DeviceLocal;
			usageMode: BufferUsageMode ElementArray;
			mainUsageMode: BufferUsageMode ElementArray;
			stride: 4;
			yourself) initialData: indices asArraySlice elements.

		let vertexBinding := renderingDevice _ createVertexBindingFor: simpleVertexLayout.
		vertexBinding _ bindVertexBuffers: vertexBuffers.

		let result := Mesh sharedNew.
		result _
			vertexBinding: vertexBinding;
			indexBuffer: indexBuffer;
			indexCount: (indices size castTo: UInt32).
		result
	}.
}.

let planeMesh mutable type: MeshPtr.
let cubeMesh mutable type: MeshPtr.

function fuzzyXor(a: Float32, b: Float32) => Float32 := {
	(a max: b) - (a min: b)
}.

Mesh definition: {
	method drawWith: (commandList: CommandList ref) ::=> Void := {
		commandList
			useVertexBinding: vertexBinding;
			useIndexBuffer: indexBuffer;
			drawElements: indexCount instanceCount: 0 firstIndex: 0 baseVertex: 0 baseInstance: 0.
	}.
}.

#*
Mesh definition: {
	method drawOn: (pipeline: SoftGraphicsPipeline ref) ::=> Void := {
		pipeline vertexShader ifNil: {
			return: void
		}.

		let nextSourceIndex mutable := 0.
		currentTransformationState
			modelMatrix: modelMatrix;
			viewMatrix: viewMatrix;
			projectionMatrix: projectionMatrix.
		currentObjectState transformationState := currentTransformationState address reinterpretCastTo: TransformationState uniformBufferPointer.
		pipeline descriptorSetTable[0] := currentObjectState address.
		pipeline
			vertexLayout: simpleVertexLayout;
			vertexBinding: vertexBinding.

		0 until: indices size / 3 do: {:triangleIndex :: Void |
			let i1 := indices[nextSourceIndex].
			let i2 := indices[nextSourceIndex + 1].
			let i3 := indices[nextSourceIndex + 2].
			pipeline drawTriangleIndices: i1 i2: i2 i3: i3 instanceID: 0.
			nextSourceIndex := nextSourceIndex + 3
		}.
	}.
}.
*#

function doRender3D => Void := {
	commandListAllocator _ resetAllocator.
	commandList _
		resetFor: commandListAllocator;
		useShaderSignature: shaderSignature;
		usePipelineState: renderingPipelineState;
		useGraphicShaderBindings: cameraStateBinding;

		beginRenderPass: mainRenderPass on: mainFrameBuffer contentOnBundle: false.

	commandList _ useGraphicShaderBindings: planeObjectStateBinding.
	planeMesh _ drawWith: commandList _.

	commandList _ useGraphicShaderBindings: cubeObjectStateBinding.
	cubeMesh _ drawWith: commandList _.

	commandList _
		endRenderPass;
		close.

	renderingCommandQueue _
		submitCommandList: commandList;
		waitForIdle.

	#**
	let pipeline mutable type: SoftGraphicsPipeline.
	pipeline
		colorBufferBlitter: colorBuffer _ makeBlitter;
		depthStencilBufferBlitter: depthBuffer _ makeBlitter;
		depthFunction: CompareFunction GreaterOrEqual;
		blendingEquation: BlendingMode CompositeAlphaOver asBlendingEquation;


	pipeline colorBufferBlitter setAllPixelsToColor: UInt8x4(64, 64 , 64, 64). ##Float32x4 zeros.
	pipeline depthStencilBufferBlitter setAllPixelsToColor: UInt8x4 zeros.

	modelMatrix := Float32x4x4 identity.
	planeMesh _ drawOn: pipeline.

	modelMatrix := Float32x4x4 translation: Float32x3(0, 1, 0).
	cubeMesh _ drawOn: pipeline.
	*#
}.

function doRenderOn(canvas: Canvas ref) => Void := {
	doRender3D().

	canvas
		copyTexture: colorBufferTextureView at: Float32x2 zeros.

	{
		let frameTime := lastFrameRenderingTime * 1000.0f.
		let frameTimeString := Stdn String textStreamContents: {:out :: Void |
			out << "Current time " << currentTime; nl.
			out << "Rendering time " << frameTime << " ms"; nl.
		}.

		canvas
			fontFaceWithSize: fontFaceWithSize;
			color: Float32x4 green;
			drawUTF8String: frameTimeString at: Float32x2(15.0f, 30.0f).
	}.

}.

class MainWindowEventHandler superclass: EventHandler; definition: {
    method render ::=> Void := {
		let canvas := mainDrawingSurface _ beginDrawingWithCanvas.
		canvas ifNil: {return: void}.

		lastFrameRenderingTime := (Stdn Chrono profileTimeToRun: {
			doRenderOn(canvas _).
		}) castTo: Float32.
    }.

    override method onTickEvent: (event: TickEvent ref) ::=> Void := {
        currentTime := event seconds castTo: Float32.

		cameraOrientation := (Float32x3x3 yRotation: cameraAngle y) * (Float32x3x3 xRotation: cameraAngle x).
		viewMatrix := (Float32x4x4 mat3: cameraOrientation transpose)*(Float32x4x4 translation: cameraPosition negated).

        self render
    }.

    override method onExposeEvent: (event: ExposeEvent ref) ::=> Void := {
        self render
    }.

    override method onWindowCloseRequestEvent: (event: WindowCloseRequestEvent ref) ::=> Void := {
        mainWindow _ close
    }.

	override method onMouseMoveEvent: (event: MouseMoveEvent ref) ::=> Void := {
		event isLeftButtonPressed ifTrue: {
			cameraAngle := cameraAngle + Float32x3(event delta y negated, event delta x negated, 0.0f)*0.01f.
		}.

		event isRightButtonPressed ifTrue: {
			cameraPosition := cameraPosition + cameraOrientation * Float32x3(event delta x, event delta y negated , 0.0f) *0.01f.
		}.
    }.

	override method onMouseWheelEvent: (event: MouseWheelEvent ref) ::=> Void := {
		cameraPosition := cameraPosition + cameraOrientation * Float32x3(0.0f, 0.0f, event scrollDelta y * -0.1f).
    }.
}.

function main externC (argc: Int32, argv: UInt8 const pointer pointer) => Int32 := {
    let windowSystem mutable := createWindowSystem().
    windowSystem ifNil: {
        return: 0
    }.
    windowSystem _ targetFrameRate: 60.

    ## Create the main window.
    mainWindow := windowSystem _ createWindowWithTitle: "Test Window" asMutableString extent: Int32x2(640, 480).
    mainWindow ifNil: {
        return: 0.
    }.

	renderingDevice := mainWindow _ renderingDevice.

    ## Create the main window drawing surface.
    mainDrawingSurface := mainWindow _ createDefaultDrawingSurface.
    mainDrawingSurface ifNil: {
        return: 0.
    }.

	## Create the main framebuffer.
	{
		colorBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat B8G8R8A8_UNormSRGB.
		colorBufferTextureView := FormTextureView for: colorBuffer.

		depthBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat D32_Float.
		let depthBufferTextureView := FormTextureView for: depthBuffer.

		let colorAttachments mutable := TextureViewPtr array(colorBufferTextureView).
		mainFrameBuffer := renderingDevice _ createFramebuffer: UInt32x2(640, 480) colorViews: colorAttachments depthStencilView: depthBufferTextureView.
	}.

	## Create the main render pass
	{
		let colorAttachments mutable := RenderPassColorAttachmentDescription array (
			RenderPassColorAttachmentDescription()
				format: PixelFormat B8G8R8A8_UNormSRGB;
				beginAction: RenderPassAttachmentAction Clear;
				endAction: RenderPassAttachmentAction Keep;
				clearValue: 0.25f;
				yourself
		).

		let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
			format: PixelFormat D32_Float;
			beginAction: RenderPassAttachmentAction Clear;
			endAction: RenderPassAttachmentAction Discard;
			yourself.
		mainRenderPass := renderingDevice _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
	}.

	## Set the projection and model view matrix.
	## projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: false.
	projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: renderingDevice _ shouldInvertProjectionY.

    ## Use the default font face.
    let fontFace mutable := FontRegistry default defaultSans _ normalFace.
    fontFaceWithSize := fontFace _ getOrCreateFaceWithSize: 12.

	## Build the shader signature.
	{
		shaderSignature := renderingDevice _ createShaderSignatureBuilder _
			## Camera state
			beginBindingBank;
			addBankElementWithType: ShaderBindingType UniformBuffer;

			## Object state
			beginBindingBank;
			addBankElementWithType: ShaderBindingType UniformBuffer;
			build
	}.

	## Build the vertex layout.
	{
		let attributes mutable := VertexAttributeDescription array (
			VertexAttributeDescription()
				location: 0;
				format: PixelFormat R32G32B32A32_Float;
				offset: 0;
				yourself,
			VertexAttributeDescription()
				location: 1;
				format: PixelFormat R32G32B32A32_Float;
				offset: 16;
				yourself,
			VertexAttributeDescription()
				location: 2;
				format: PixelFormat R32G32B32_Float;
				offset: 32;
				yourself
		).

		let strides mutable := UInt32 array(VertexAttributeDescription instanceSize).

		simpleVertexLayout := renderingDevice _ createVertexLayout.
		simpleVertexLayout _ addVertexBuffers: strides withAttributes: attributes.
	}.

	## Build the graphics pipeline state.
	{
		renderingPipelineState := renderingDevice _ createGraphicsPipelineState: (GraphicsPipelineStateDescription()
			shaderSignature: shaderSignature;

			##vertexShader: CheckboardShader vertex shaderEntryPointInfo address;
			##fragmentShader: CheckboardShader fragment shaderEntryPointInfo address.

			vertexLayout: simpleVertexLayout;

			addColorAttachmentWithFormat: PixelFormat B8G8R8A8_UNormSRGB;
			setAllBlendingEquationsTo: BlendingMode CompositeAlphaOver asBlendingEquation;

			depthStencilFormat: PixelFormat D32_Float;
			yourself)
	}.

	## Get the rendering command queue.
	renderingCommandQueue := renderingDevice _ getDefaultCommandQueue.

	## Build the command allocator and list.
	{
		commandListAllocator := renderingDevice _ createCommandAllocatorOfType: CommandListType Direct for: renderingCommandQueue.
		commandList := renderingDevice _ createCommandListOfType: CommandListType Direct for: commandListAllocator.
	}.

	## Create the camera state buffer and binding
	{
	#*let cameraStateBuffer type: BufferPtr.
	let cameraStateBinding type: ShaderResourceBindingPtr.*#

	}.

	## Build the plane
	{
		planeMesh := MeshBuilder()
			addVertex: Float32x3(0, 0, 0) normal: Float32x3(0, 1, 0);
			addVertex: Float32x4(-1, 0, -1, 0) normal: Float32x3(0, 1, 0);
			addVertex: Float32x4(1, 0, -1, 0) normal: Float32x3(0, 1, 0);
			addVertex: Float32x4(-1, 0, 1, 0) normal: Float32x3(0, 1, 0);
			addVertex: Float32x4(1, 0, 1, 0) normal: Float32x3(0, 1, 0);

			addTriangle: 0 i2: 2 i3: 1;
			addTriangle: 0 i2: 4 i3: 2;
			addTriangle: 0 i2: 3 i3: 4;
			addTriangle: 0 i2: 1 i3: 3;

			finish

		#*
		let cubeObjectStateBuffer type: BufferPtr.
		let cubeObjectStateBinding type: ShaderResourceBindingPtr.

		let meshObjectStateBinding type: BufferPtr.
		let meshObjectStateBinding type: ShaderResourceBindingPtr.*#
	}.

	## Build the cube
	{
		let max := Float32x3 ones.
		let min := max negated.

		cubeMesh := MeshBuilder()
			## Left
	        beginSubmesh;
	        addVertex: Float32x3(min x, min y, min z) normal: Float32x3(-1.0f, 0.0f, 0.0f) texcoord: Float32x2(0.0f, 1.0f);
	        addVertex: Float32x3(min x, max y, min z) normal: Float32x3(-1.0f, 0.0f, 0.0f) texcoord: Float32x2(1.0f, 1.0f);
	        addVertex: Float32x3(min x, max y, max z) normal: Float32x3(-1.0f, 0.0f, 0.0f) texcoord: Float32x2(1.0f, 0.0f);
	        addVertex: Float32x3(min x, min y, max z) normal: Float32x3(-1.0f, 0.0f, 0.0f) texcoord: Float32x2(0.0f, 0.0f);
	        addTriangle: 1 i2: 0 i3: 2;
	        addTriangle: 3 i2: 2 i3: 0;

	        ## Right
	        beginSubmesh;
	        addVertex: Float32x3(max x, min y, min z) normal: Float32x3(1.0f, 0.0f, 0.0f) texcoord: Float32x2(1.0f, 1.0f);
	        addVertex: Float32x3(max x, max y, min z) normal: Float32x3(1.0f, 0.0f, 0.0f) texcoord: Float32x2(0.0f, 1.0f);
	        addVertex: Float32x3(max x, max y, max z) normal: Float32x3(1.0f, 0.0f, 0.0f) texcoord: Float32x2(0.0f, 0.0f);
	        addVertex: Float32x3(max x, min y, max z) normal: Float32x3(1.0f, 0.0f, 0.0f) texcoord: Float32x2(1.0f, 0.0f);
	        addTriangle: 0 i2: 1 i3: 2;
	        addTriangle: 2 i2: 3 i3: 0;

	        ## Top
	        beginSubmesh;
	        addVertex: Float32x3(min x, max y, min z) normal: Float32x3(0.0f, 1.0f, 0.0f) texcoord: Float32x2(0.0f, 1.0f);
	        addVertex: Float32x3(max x, max y, min z) normal: Float32x3(0.0f, 1.0f, 0.0f) texcoord: Float32x2(1.0f, 1.0f);
	        addVertex: Float32x3(max x, max y, max z) normal: Float32x3(0.0f, 1.0f, 0.0f) texcoord: Float32x2(1.0f, 0.0f);
	        addVertex: Float32x3(min x, max y, max z) normal: Float32x3(0.0f, 1.0f, 0.0f) texcoord: Float32x2(0.0f, 0.0f);
			addTriangle: 1 i2: 0 i3: 2;
	        addTriangle: 3 i2: 2 i3: 0;

	        ## Bottom
	        beginSubmesh;
	        addVertex: Float32x3(min x, min y, min z) normal: Float32x3(0.0f, -1.0f, 0.0f) texcoord: Float32x2(1.0f, 1.0f);
	        addVertex: Float32x3(max x, min y, min z) normal: Float32x3(0.0f, -1.0f, 0.0f) texcoord: Float32x2(0.0f, 1.0f);
	        addVertex: Float32x3(max x, min y, max z) normal: Float32x3(0.0f, -1.0f, 0.0f) texcoord: Float32x2(0.0f, 0.0f);
	        addVertex: Float32x3(min x, min y, max z) normal: Float32x3(0.0f, -1.0f, 0.0f) texcoord: Float32x2(1.0f, 0.0f);
			addTriangle: 0 i2: 1 i3: 2;
	        addTriangle: 2 i2: 3 i3: 0;

	        ## Back
	        beginSubmesh;
	        addVertex: Float32x3(min x, min y, min z) normal: Float32x3(0.0f, 0.0f, -1.0f) texcoord: Float32x2(0.0f, 1.0f);
	        addVertex: Float32x3(max x, min y, min z) normal: Float32x3(0.0f, 0.0f, -1.0f) texcoord: Float32x2(1.0f, 1.0f);
	        addVertex: Float32x3(max x, max y, min z) normal: Float32x3(0.0f, 0.0f, -1.0f) texcoord: Float32x2(1.0f, 0.0f);
	        addVertex: Float32x3(min x, max y, min z) normal: Float32x3(0.0f, 0.0f, -1.0f) texcoord: Float32x2(0.0f, 0.0f);
			addTriangle: 1 i2: 0 i3: 2;
	        addTriangle: 3 i2: 2 i3: 0;

	        ## Front
	        beginSubmesh;
	        addVertex: Float32x3(min x, min y, max z) normal: Float32x3(0.0f, 0.0f, 1.0f) texcoord: Float32x2(0.0f, 1.0f);
	        addVertex: Float32x3(max x, min y, max z) normal: Float32x3(0.0f, 0.0f, 1.0f) texcoord: Float32x2(1.0f, 1.0f);
	        addVertex: Float32x3(max x, max y, max z) normal: Float32x3(0.0f, 0.0f, 1.0f) texcoord: Float32x2(1.0f, 0.0f);
	        addVertex: Float32x3(min x, max y, max z) normal: Float32x3(0.0f, 0.0f, 1.0f) texcoord: Float32x2(0.0f, 0.0f);
			addTriangle: 0 i2: 1 i3: 2;
	        addTriangle: 2 i2: 3 i3: 0;

			finish
	}.

    ## Create the event handler.
    {
        let eventHandler := MainWindowEventHandler sharedNew.
        mainWindow _ eventHandler: (eventHandler upCastFor: EventHandler)
    }.

    ## Run the actual main loop.
    return: windowSystem _ runMainLoop.
}.
