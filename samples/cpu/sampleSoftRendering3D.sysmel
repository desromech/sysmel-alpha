Compiler
	importModuleNamed: #"Sysmel.Graphics.Headfull".

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

class TransformationState definition: {
    public field modelMatrix type: Float32x4x4.
	public field viewMatrix type: Float32x4x4.
    public field projectionMatrix type: Float32x4x4.
}.

class ObjectState definition: {
    public field transformationState type: TransformationState uniformBufferPointer.
}.

class CheckboardShader definition: {
	public field objectState type: ObjectState bindingSetPointer.

	class VertexIO definition: {
		public field position type: Float32x4; location: 0.
		public field color type: Float32x4; location: 1.
		public field normal type: Float32x3; location: 2.
    }.

	class FragmentOutput definition: {
		public field color0 type: Float32x4; location: 0.
    }.

    function vertex vertexShader(in: VertexIO inputChannel, out: VertexIO outputChannel, stageOut: GPU VertexStageOutput outputChannel) => Void := {
        let input := in receive.

		let worldPosition := objectState _ transformationState _ modelMatrix * input position.
		let viewPosition := objectState _ transformationState _ viewMatrix * worldPosition.
		let screenPosition := objectState _ transformationState _ projectionMatrix * viewPosition.

		let output mutable := input.
		output position: worldPosition.
		out send: output.

        stageOut send: (GPU VertexStageOutput()
            screenPosition: screenPosition;
            yourself
        ).
    }.

    function fragment fragmentShader(stageIn: VertexIO inputChannel, out: FragmentOutput outputChannel) => Void := {
        let input := stageIn receive.

		let P := input position xyz / input position w.
		let N := input normal normalized.
		let L := Float32x3(1, 1, 1) normalized.

		let x := P.
		let edge := 0.48f smoothStepTo: 0.52f value: 2*(x - (x + 0.5f) floor) abs. ##((x - x floor)*2 - 1) abs.
		let aliasFactor := 10.0f smoothStepTo: 30.0f value: P length.

		let stipple := fuzzyXor(fuzzyXor(edge x, edge y), edge z) interpolateTo: 0.5f at: aliasFactor.
		let albedo := stipple * Float32x3(1,1,1).
		## let albedo := edge.
		let NdotL := (N dot: L) max: 0.0f.

		let result := Float32x4(albedo*(0.2f + 0.8f*NdotL), 1.0f).
		##let result := Float32x4(N*0.5f + 0.5f, 1.0f).

        out send: (FragmentOutput() color0: result)
    }.
}.

let mainWindow mutable type: Window sharedPointer.
let mainDrawingSurface mutable type: Surface sharedPointer.
let fontFaceWithSize mutable type: FontFaceWithSize sharedPointer.

let currentTime mutable type: Float32.
let lastFrameRenderingTime mutable type: Float32.

let colorBuffer mutable type: Form sharedPointer.
let colorBufferTextureView mutable type: TextureView sharedPointer.
let depthBuffer mutable type: Form sharedPointer.

let cameraOrientation mutable := Float32x3x3 identity.
let cameraPosition mutable := Float32x3(0, 1, 3).
let cameraAngle mutable := Float32x3(0, 0, 0).

let projectionMatrix mutable type: Float32x4x4.
let viewMatrix mutable type: Float32x4x4.
let modelMatrix mutable type: Float32x4x4.
let currentTransformationState mutable type: TransformationState.
let currentObjectState mutable type: ObjectState.

class Mesh definition: {
	public field vertices type: Stdn Collections Vector(Float32x4).
	public field indices type: Stdn Collections Vector(UInt32).

	method addVertex: (p: Float32x3) ::=> Void := {
		vertices add: Float32x4(p, 1)
	}.

	method addVertex: (p: Float32x4) ::=> Void := {
		vertices add: p
	}.

	method addTriangle: (i1: UInt32) i2: (i2: UInt32) i3: (i3: UInt32) ::=> Void := {
		indices
			add: i1; add: i2; add: i3
	}.

	method addQuad: (i1: UInt32) i2: (i2: UInt32) i3: (i3: UInt32) i4: (i4: UInt32) ::=> Void := {
		indices
			add: i1; add: i2; add: i4;
			add: i4; add: i3; add: i1
	}.

}.

let planeMesh mutable type: Mesh.
let cubeMesh mutable type: Mesh.

function fuzzyXor(a: Float32, b: Float32) => Float32 := {
	(a max: b) - (a min: b)
}.


Mesh definition: {
	method drawOn: (pipeline: SoftwareGraphicsPipeline ref) ::=> Void := {
		pipeline vertexShader ifNil: {
			return: void
		}.

		let nextSourceIndex mutable := 0.
		currentTransformationState
			modelMatrix: modelMatrix;
			viewMatrix: viewMatrix;
			projectionMatrix: projectionMatrix.
		currentObjectState transformationState := currentTransformationState address reinterpretCastTo: TransformationState uniformBufferPointer.
		pipeline descriptorSetTable[0] := currentObjectState address.

		0 until: indices size / 3 do: {:triangleIndex :: Void |
			let v1 := vertices[indices[nextSourceIndex]].
			let v2 := vertices[indices[nextSourceIndex + 1]].
			let v3 := vertices[indices[nextSourceIndex + 2]].

			let N := ((v2 xyz - v1 xyz) cross: (v3 xyz - v1 xyz)) normalized.

			let c1 := Float32x4 red.
			let c2 := Float32x4 green.
			let c3 := Float32x4 blue.

			let iov1 mutable type: GPU NativeVertexShaderIOInterface.
			let iov2 mutable type: GPU NativeVertexShaderIOInterface.
			let iov3 mutable type: GPU NativeVertexShaderIOInterface.

			iov1 inputs locations[0] := v1.
			iov1 inputs locations[1] := c1.
			iov1 inputs locations[2] := Float32x4(N, 0.0f).

			iov2 inputs locations[0] := v2.
			iov2 inputs locations[1] := c2.
			iov2 inputs locations[2] := Float32x4(N, 0.0f).

			iov3 inputs locations[0] := v3.
			iov3 inputs locations[1] := c3.
			iov3 inputs locations[2] := Float32x4(N, 0.0f).

			## Invoke the vertex shader.
			pipeline
				invokeVertexShaderOn: iov1;
				invokeVertexShaderOn: iov2;
				invokeVertexShaderOn: iov3;
				drawTriangle: iov1 outputs v2: iov2 outputs v3: iov3 outputs.

			nextSourceIndex := nextSourceIndex + 3
		}
	}.
}.

function doRender3D => Void := {
	let pipeline mutable type: SoftwareGraphicsPipeline.
	pipeline
		colorBufferBlitter: colorBuffer _ makeBlitter;
		depthStencilBufferBlitter: depthBuffer _ makeBlitter;
		depthFunction: CompareFunction GreaterOrEqual;
		blendingEquation: BlendingMode CompositeAlphaOver asBlendingEquation;

		vertexShader: CheckboardShader vertex shaderEntryPointInfo address;
		fragmentShader: CheckboardShader fragment shaderEntryPointInfo address.

	pipeline colorBufferBlitter setAllPixelsToColor: UInt8x4(64, 64 , 64, 64). ##Float32x4 zeros.
	pipeline depthStencilBufferBlitter setAllPixelsToColor: UInt8x4 zeros.

	modelMatrix := Float32x4x4 identity.
	planeMesh drawOn: pipeline.

	modelMatrix := Float32x4x4 translation: Float32x3(0, 1, 0).
	cubeMesh drawOn: pipeline.
}.

function doRenderOn(canvas: Canvas ref) => Void := {
	doRender3D().

	canvas
		copyTexture: colorBufferTextureView at: Float32x2 zeros.

	{
		let frameTime := lastFrameRenderingTime * 1000.0f.
		let frameTimeString := Stdn String textStreamContents: {:out :: Void |
			out << "Current time " << currentTime; nl.
			out << "Rendering time " << frameTime << " ms"; nl.
		}.

		canvas
			fontFaceWithSize: fontFaceWithSize;
			color: Float32x4 green;
			drawUTF8String: frameTimeString at: Float32x2(15.0f, 30.0f).
	}.

}.

class MainWindowEventHandler superclass: EventHandler; definition: {
    method render ::=> Void := {
		let canvas := mainDrawingSurface _ beginDrawingWithCanvas.
		canvas ifNil: {return: void}.

		lastFrameRenderingTime := (Stdn Chrono profileTimeToRun: {
			doRenderOn(canvas _).
		}) castTo: Float32.
    }.

    override method onTickEvent: (event: TickEvent ref) ::=> Void := {
        currentTime := event seconds castTo: Float32.

		cameraOrientation := (Float32x3x3 yRotation: cameraAngle y) * (Float32x3x3 xRotation: cameraAngle x).
		viewMatrix := (Float32x4x4 mat3: cameraOrientation transpose)*(Float32x4x4 translation: cameraPosition negated).

        self render
    }.

    override method onExposeEvent: (event: ExposeEvent ref) ::=> Void := {
        self render
    }.

    override method onWindowCloseRequestEvent: (event: WindowCloseRequestEvent ref) ::=> Void := {
        mainWindow _ close
    }.

	override method onMouseMoveEvent: (event: MouseMoveEvent ref) ::=> Void := {
		event isLeftButtonPressed ifTrue: {
			cameraAngle := cameraAngle + Float32x3(event delta y negated, event delta x negated, 0.0f)*0.01f.
		}.

		event isRightButtonPressed ifTrue: {
			cameraPosition := cameraPosition + cameraOrientation * Float32x3(event delta x, event delta y negated , 0.0f) *0.01f.
		}.
    }.

	override method onMouseWheelEvent: (event: MouseWheelEvent ref) ::=> Void := {
		cameraPosition := cameraPosition + cameraOrientation * Float32x3(0.0f, 0.0f, event scrollDelta y * -0.1f).
    }.
}.

function main externC (argc: Int32, argv: UInt8 const pointer pointer) => Int32 := {
    let windowSystem mutable := createWindowSystem().
    windowSystem ifNil: {
        return: 0
    }.
    windowSystem _ targetFrameRate: 60.

    ## Create the main window.
    mainWindow := windowSystem _ createWindowWithTitle: "Test Window" asMutableString extent: Int32x2(640, 480).
    mainWindow ifNil: {
        return: 0.
    }.

    ## Create the main window drawing surface.
    mainDrawingSurface := mainWindow _ createDefaultDrawingSurface.
    mainDrawingSurface ifNil: {
        return: 0.
    }.

	## Create the color and depth buffer.
	colorBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat B8G8R8A8_UNormSRGB.
	colorBufferTextureView := FormTextureView for: colorBuffer.
	depthBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat D32_Float.

	## Set the projection and model view matrix.
	## projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: false.
	projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: true.

    ## Use the default font face.
    let fontFace mutable := FontRegistry default defaultSans _ normalFace.
    fontFaceWithSize := fontFace _ getOrCreateFaceWithSize: 12.

	## Build the plane
	{
		planeMesh
			addVertex: Float32x3(0, 0, 0);
			addVertex: Float32x4(-1, 0, -1, 0);
			addVertex: Float32x4(1, 0, -1, 0);
			addVertex: Float32x4(-1, 0, 1, 0);
			addVertex: Float32x4(1, 0, 1, 0);

			addTriangle: 0 i2: 2 i3: 1;
			addTriangle: 0 i2: 4 i3: 2;
			addTriangle: 0 i2: 3 i3: 4;
			addTriangle: 0 i2: 1 i3: 3
	}.

	## Build the cube
	{
		cubeMesh
			addVertex: Float32x3(-1, -1, -1);
			addVertex: Float32x3(1, -1, -1);
			addVertex: Float32x3(-1, 1, -1);
			addVertex: Float32x3(1, 1, -1);

			addVertex: Float32x3(-1, -1, 1);
			addVertex: Float32x3(1, -1, 1);
			addVertex: Float32x3(-1, 1, 1);
			addVertex: Float32x3(1, 1, 1);

			addQuad: 2 i2: 0 i3: 6 i4: 4;
			addQuad: 1 i2: 3 i3: 5 i4: 7;

			addQuad: 0 i2: 1 i3: 4 i4: 5;
			addQuad: 3 i2: 2 i3: 7 i4: 6;

			addQuad: 1 i2: 0 i3: 3 i4: 2;
			addQuad: 4 i2: 5 i3: 6 i4: 7.
	}.

    ## Create the event handler.
    {
        let eventHandler := MainWindowEventHandler sharedNew.
        mainWindow _ eventHandler: (eventHandler upCastFor: EventHandler)
    }.

    ## Run the actual main loop.
    return: windowSystem _ runMainLoop.
}.
