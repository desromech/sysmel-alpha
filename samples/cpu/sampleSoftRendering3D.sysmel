Compiler
	importModuleNamed: #"Sysmel.Graphics.Headfull".

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

let mainWindow mutable type: Window sharedPointer.
let mainDrawingSurface mutable type: Surface sharedPointer.
let fontFaceWithSize mutable type: FontFaceWithSize sharedPointer.

let currentTime mutable type: Float32.
let lastFrameRenderingTime mutable type: Float32.

let colorBuffer mutable type: Form sharedPointer.
let colorBufferTextureView mutable type: TextureView sharedPointer.
let depthBuffer mutable type: Form sharedPointer.

let cameraOrientation mutable := Float32x3x3 identity.
let cameraPosition mutable := Float32x3(0, 0, 3).
let cameraAngle mutable := Float32x3(0, 0, 0).

let projectionMatrix mutable type: Float32x4x4.
let viewMatrix mutable type: Float32x4x4.
let modelViewMatrix mutable type: Float32x4x4.

let meshVertices mutable type: Stdn Collections Vector(Float32x3).
let meshIndices mutable type: Stdn Collections Vector(UInt32).

function addQuad(i1: UInt32, i2: UInt32, i3: UInt32, i4: UInt32) => Void := {
	meshIndices
		add: i1; add: i2; add: i4;
		add: i4; add: i3; add: i1
}.

function doRender3D => Void := {
	let colorBufferBlitter := colorBuffer _ makeBlitter.
	let depthBufferBlitter := depthBuffer _ makeBlitter.

	colorBufferBlitter setAllPixelsToColor: Float32x4 zeros.
	depthBufferBlitter setAllPixelsToColor: Float32x4 zeros.

	let viewportTransform := (Float32x4x4 scale: Float32x4(640, 480, 1, 1))
 			* Float32x4x4 shadowMapBias.

	let nextSourceIndex mutable := 0.
	0 until: meshIndices size / 3 do: {:triangleIndex :: Void |
		let v1 := meshVertices[meshIndices[nextSourceIndex]].
		let v2 := meshVertices[meshIndices[nextSourceIndex + 1]].
		let v3 := meshVertices[meshIndices[nextSourceIndex + 2]].

		let c1 := Float32x4 red.
		let c2 := Float32x4 green.
		let c3 := Float32x4 blue.

		##Stdn stdout << "v1 " << v1; nl.
		##Stdn stdout << "v2 " << v2; nl.
		##Stdn stdout << "v3 " << v3; nl.

		let tv1 := viewportTransform * (projectionMatrix * (modelViewMatrix * Float32x4(v1, 1))).
		let tv2 := viewportTransform * (projectionMatrix * (modelViewMatrix * Float32x4(v2, 1))).
		let tv3 := viewportTransform * (projectionMatrix * (modelViewMatrix * Float32x4(v3, 1))).

		##Stdn stdout << "tv1 " << tv1; nl.
		##Stdn stdout << "tv2 " << tv2; nl.
		##Stdn stdout << "tv3 " << tv3; nl.

		let sv1 := tv1 xy / tv1 w.
		let sv2 := tv2 xy / tv2 w.
		let sv3 := tv3 xy / tv3 w.
		##Stdn stdout << "sv1 " << sv1; nl.
		##Stdn stdout << "sv2 " << sv2; nl.
		##Stdn stdout << "sv3 " << sv3; nl.

		colorBufferBlitter
            blendTriangle: sv1 p2: sv2 p3: sv3 pixelsWith: {:(Float32x2)p :(Float32x3)barycentricCoordinates :(Float32x4)originalDestPixelValue :: Float32x4 |
            let interpolatedColor := c1*barycentricCoordinates x + c2*barycentricCoordinates y + c3*barycentricCoordinates z.
            interpolatedColor
        }.

		nextSourceIndex := nextSourceIndex + 3
	}
}.

function doRenderOn(canvas: Canvas ref) => Void := {
	doRender3D().

	canvas
		copyTexture: colorBufferTextureView at: Float32x2 zeros.

	{
		let frameTime := lastFrameRenderingTime * 1000.0f.
		let frameTimeString := Stdn String textStreamContents: {:out :: Void |
			out << "Current time " << currentTime; nl.
			out << "Rendering time " << frameTime << " ms"; nl.
		}.

		canvas
			fontFaceWithSize: fontFaceWithSize;
			color: Float32x4 green;
			drawUTF8String: frameTimeString at: Float32x2(15.0f, 30.0f).
	}.

}.

class MainWindowEventHandler superclass: EventHandler; definition: {
    method render ::=> Void := {
		let canvas := mainDrawingSurface _ beginDrawingWithCanvas.
		canvas ifNil: {return: void}.

		lastFrameRenderingTime := (Stdn Chrono profileTimeToRun: {
			doRenderOn(canvas _).
		}) castTo: Float32.
    }.

    override method onTickEvent: (event: TickEvent ref) ::=> Void := {
        currentTime := event seconds castTo: Float32.

		cameraOrientation := (Float32x3x3 yRotation: cameraAngle y) * (Float32x3x3 xRotation: cameraAngle x).
		viewMatrix := (Float32x4x4 mat3: cameraOrientation transpose)*(Float32x4x4 translation: cameraPosition negated).
		modelViewMatrix := viewMatrix.

        self render
    }.

    override method onExposeEvent: (event: ExposeEvent ref) ::=> Void := {
        self render
    }.

    override method onWindowCloseRequestEvent: (event: WindowCloseRequestEvent ref) ::=> Void := {
        mainWindow _ close
    }.

	override method onMouseMoveEvent: (event: MouseMoveEvent ref) ::=> Void := {
		event isLeftButtonPressed ifTrue: {
			cameraAngle := cameraAngle + Float32x3(event delta y, event delta x negated, 0.0f)*0.01f.
		}.

		event isRightButtonPressed ifTrue: {
			cameraPosition := cameraPosition + cameraOrientation * Float32x3(event delta x, event delta y, 0.0f) *0.01f.
		}.
    }.

	override method onMouseWheelEvent: (event: MouseWheelEvent ref) ::=> Void := {
		cameraPosition := cameraPosition + cameraOrientation * Float32x3(0.0f, 0.0f, event scrollDelta y * -0.1f).
    }.
}.

function main externC (argc: Int32, argv: UInt8 const pointer pointer) => Int32 := {
    let windowSystem mutable := createWindowSystem().
    windowSystem ifNil: {
        return: 0
    }.
    windowSystem _ targetFrameRate: 60.

    ## Create the main window.
    mainWindow := windowSystem _ createWindowWithTitle: "Test Window" asMutableString extent: Int32x2(640, 480).
    mainWindow ifNil: {
        return: 0.
    }.

    ## Create the main window drawing surface.
    mainDrawingSurface := mainWindow _ createDefaultDrawingSurface.
    mainDrawingSurface ifNil: {
        return: 0.
    }.

	## Create the color and depth buffer.
	colorBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat B8G8R8A8_UNormSRGB.
	colorBufferTextureView := FormTextureView for: colorBuffer.
	depthBuffer := Form extent: UInt32x2(640, 480) pixelFormat: PixelFormat D32_Float.

	## Set the projection and model view matrix.
	projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: 640.0f / 480.0f near: 0.1f far: 100.0f invertedY: false.

    ## Use the default font face.
    let fontFace mutable := FontRegistry default defaultSans _ normalFace.
    fontFaceWithSize := fontFace _ getOrCreateFaceWithSize: 12.

	## Build the cube
	{
		meshVertices
			add: Float32x3(-1, -1, -1);
			add: Float32x3(1, -1, -1);
			add: Float32x3(-1, 1, -1);
			add: Float32x3(1, 1, -1);

			add: Float32x3(-1, -1, 1);
			add: Float32x3(1, -1, 1);
			add: Float32x3(-1, 1, 1);
			add: Float32x3(1, 1, 1).

		addQuad(0, 2, 4, 6).
		addQuad(1, 3, 5, 7).

		addQuad(0, 1, 4, 5).
		addQuad(2, 3, 6, 7).

		addQuad(0, 1, 2, 3).
		addQuad(4, 5, 6, 7).
	}.

    ## Create the event handler.
    {
        let eventHandler := MainWindowEventHandler sharedNew.
        mainWindow _ eventHandler: (eventHandler upCastFor: EventHandler)
    }.

    ## Run the actual main loop.
    return: windowSystem _ runMainLoop.
}.
