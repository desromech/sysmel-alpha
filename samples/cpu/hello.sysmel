## Main function

global testGlobal mutable := 42.

function printValue(value: Int32) => Void := {
    StdNative stdout << "printValue Int32: " << value; nl.
}.

function printValue(value: Float32) => Void := {
    StdNative stdout << "printValue Float32: " << value; nl.
}.

function testNativeErrorThrow() => Void := {
    StdNative error: "Test error"
}.

function testNativeError() => Void := {
    try: {
        testNativeErrorThrow().
    } catch: StdNative Error doing: {:exception :: Void |
        StdNative stdout << "Caught error exception: " << exception; nl.
    }.
}.

function testSmalltalkErrorThrow() => Void := {
    Smalltalk Object error: "Test smalltalk error".
}.

function testGCError() => Void := {
    try: {
        testSmalltalkErrorThrow().
    } catch: Smalltalk Error doing: {:exception :: Void |
        StdNative stdout << "Caught Smalltalk exception: " << exception; nl.
    }.
}.

function testNonLocalReturn() => Void := {
    let array type: Smalltalk ProtoObject := #(1 2 3 4 5).
    StdNative stdout << "Should print until 3"; nl.
    array do: {:(Smalltalk ProtoObject)v :: Void |
        StdNative stdout << v; nl.
        v == 3 ifTrue: {
            StdNative stdout << "Found 3, do non-local return."; nl.
            return: nil
        }.
    }.
}.

function testWriteFile() => Void := {
    let outFile mutable type: StdNative IO FileStream.
    (outFile open: "test.txt" mode: StdNative IO FileOpenMode CreateNew) ifTrue: {
        let out mutable := StdNative IO TextStreamWriter for: outFile address.
        out << "Hello World"; nl.
        out << "File written from sysmel"; nl.
        outFile close
    }.
}.

function main externC (argc: Int32, argv: Char8 const pointer pointer) => Int32 := {
    StdNative stdout << "testGlobal " << testGlobal; nl.
	StdNative stdout << "TestChar " << 'c'; nl.

    ##let s type: SomeStruct.

    1 to: 3 do: {:i :: Void |
        StdNative stdout << "Loop iteration " << i; nl
    }.

    let v3f := Float32x3 x: 1.0 y: 2.0 z: 3.0.
    StdNative stdout << "v3f " << v3f; nl.

    let vp := v3f + (Float32x3 x: 4.0 y: 5.0 z: 6.0).
    StdNative stdout << "vp " << v3f; nl.

    let vps := v3f + 3.0.
    StdNative stdout << "vps " << v3f; nl.

    let v3d := Float64x3 x: v3f x y: v3f y z: v3f z.
    StdNative stdout << "v3d " << v3f; nl.

    ##let matrix := Float32x3x3 identity + Float32x3x3 identity.
    ##let matrix := Float32x3x3 ones * Float32x3x3 ones.
    let matrix := Float32x3x3 rowMajorIndices.
    ##let matrix mutable := Float32x3x3 identity + Float32x3x3 identity.
    StdNative stdout nextPutAll: "zm "; nl;
	tab; nextPutVector: matrix firstRow; nl;
	tab; nextPutVector: matrix secondRow; nl;
	tab; nextPutVector: matrix thirdRow; nl.

    let mv3f := matrix * v3f.
    StdNative stdout << "mv3f " << mv3f; nl.

    let v3fm := v3f * matrix.
    StdNative stdout << "v3fm " << v3fm; nl.
    StdNative stdout << "v3f dot: v3f" << (v3f dot: v3f); nl.

    let v3fc := v3f cross: v3f.
    StdNative stdout << "v3fc cross: v3f " << v3fc; nl.

    printValue(1).
    printValue(1.0).

    1 until: argc do: {:i :: Void |
        i = 1 ifTrue: {
            StdNative stdout << "First "
        } ifFalse: {
            StdNative stdout << "Not first "

        }.

        StdNative stdout << "argv " << i << " " << (argv[i] address) << " " << (argv + i) << " "; nextPutCString: argv[i]; nl
    }.

    StdNative stdout << "Hello World: "; nextPutCString: argv value; nl.

    StdNative stdout << "Object: " << (Smalltalk Object reinterpretCastTo: Void pointer); nl.
    StdNative stdout << "Object class: " << (Smalltalk Object class reinterpretCastTo: Void pointer); nl.

    useNamespace: Smalltalk.

    let o := Object.
    StdNative stdout << "o: " << (o reinterpretCastTo: Void pointer) << " " << o; nl.
    StdNative stdout << "o class: " << (o class reinterpretCastTo: Void pointer) << " " << o class; nl.
    StdNative stdout << "Object basicNew: " << Object basicNew; nl.

	let n mutable type: ProtoObject := 42.
	let sumResult := n + 7.
    StdNative stdout << "(ProtoObject)42 + (ProtoObject)7 = " << sumResult; nl.

    let boolValue := true.
    let boolCast type: ProtoObject := boolValue.
    StdNative stdout << "Bool cast " << (boolCast reinterpretCastTo: Void pointer) << " " << boolCast; nl.

	let testArray type: ProtoObject := #("Hello world" 1 #symbol 2 3 4 5).
	testArray do: {:(ProtoObject)el :: Void |
	    StdNative stdout << "Array element " << el; nl.
	}.

    StdNative stdout << "Printing ProtoObject with all subclasses"; nl.
    ProtoObject withAllSubclassesDo: {:(ProtoObject)cls :: Void |
	    StdNative stdout << cls; nl.
	}.

    {
        let string type: ProtoObject := "class".
        let symbol := string asSymbol.

        StdNative stdout << "String '"  << string << "' asSymbol #'" << symbol << "' unique: " << (symbol == #class) << " sameResult: " << (symbol == string asSymbol); nl.
    }.

    testNativeError().
    testNonLocalReturn().
    testGCError().
    testWriteFile().

    StdNative stdout << (Smalltalk Object name -- " with concat"); nl.

    return: 0.
}.
