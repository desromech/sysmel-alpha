namespace Smalltalk definition: {

gcclass PharoBridgeServerClientConnection definition: {
    public field server.
    field clientSocket type: StdNative IO Socket.
    field clientReceptionProcess.
    field clientTransmissionProcess.
    field messageToClientQueue.

    method initialize := {
        messageToClientQueue := AtomicSharedQueue new.
        self.
    }.

    method handleAcceptedClient: (theClientSocket: StdNative IO Socket ref) := {
        clientSocket := theClientSocket asMoveReference.
        clientReceptionProcess := {:: Void | self processClientConnection} fork.
        clientTransmissionProcess := {:: Void | self sendMessagesToClient } fork.
        self.
    }.

    method processClientConnection := {
        {
            let magicCode mutable type: (UInt8 array: 4).

            (self receiveBytes: 4 into: magicCode[0] address) && (StdNative memcmp(magicCode[0] address, "PHRS", 4) == 0) ifFalse: {
                clientSocket close.
                return: self.
            }.
        }.

        StdNative stdout << "Accepted Pharo bridge client with endpoint " << clientSocket endpoint << "."; nl.
        while: clientSocket isValid do: {
            self receiveAndProcessCommand
        }.
        messageToClientQueue nextPut: nil.
        self
    }.

    method sendMessagesToClient := {
        while: clientSocket isValid do: {
            let nextMessage := messageToClientQueue next.
            nextMessage ifNotNil: {
                self sendMessageToClient: nextMessage
            }
        }.

        self.
    }.

    method sendMessageToClient: message := {
        let outputStream mutable type: StdNative IO MemoryStream.
        let encoder mutable type: StdNative Serialization MessagePack Encoder.
        encoder
            beginEncodingIntoStream: outputStream address;
            encodeObject: message.

        let messageSize mutable type: UInt32 := outputStream size castTo: UInt32.
        self
            sendBytes: 4 from: messageSize address;
            sendBytes: messageSize from: outputStream buffer.

        self
    }.

    inline method receiveBytes: (expectedByteCount: UIntPointer) into: (buffer: Void pointer) ::=> Boolean8 := {
        let dest mutable := buffer reinterpretCastTo: UInt8 pointer.
        let remainingToRead mutable := expectedByteCount.
        while: remainingToRead > 0 do: {
            let readedCount := clientSocket read: dest size: remainingToRead.
            readedCount <= 0 ifTrue: {
                clientSocket close.
                return: false
            }.

            dest := dest[readedCount] address.
            remainingToRead := remainingToRead - (readedCount castTo: UIntPointer).
        }.

        return: true
    }.

    inline method sendBytes: (expectedByteCount: UIntPointer) from: (buffer: Void const pointer) ::=> Boolean8 := {
        let source mutable := buffer reinterpretCastTo: UInt8 pointer.
        let remainingToSend mutable := expectedByteCount.
        while: remainingToSend > 0 do: {
            let readedCount := clientSocket write: source size: remainingToSend.
            readedCount <= 0 ifTrue: {
                clientSocket close.
                return: false
            }.

            source := source[readedCount] address.
            remainingToSend := remainingToSend - (readedCount castTo: UIntPointer).
        }.

        return: true
    }.

    method enqueueMessageToClient: message := {
        messageToClientQueue nextPut: message.
        self
    }.

    method receiveAndProcessCommand := {
        let messageSize mutable type: UInt32 := 0.
        (self receiveBytes: 4 into: messageSize address) ifFalse: {
            return: self
        }.

        ## FIXME: use an unique_ptr here.
        let messageBuffer := StdNative malloc(messageSize) reinterpretCastTo: UInt8 pointer.
        let decodedMessage mutable.
        try: {
            ## Receive the message.
            (self receiveBytes: messageSize into: messageBuffer) ifFalse: {
                return: self
            }.

            ## Decode the message.
            decodedMessage := StdNative Serialization MessagePack GCObjectDecoder decodeFrom: messageBuffer withSize: messageSize.
        } finally: {
            StdNative free(messageBuffer)
        }.

        self processClientCommand: decodedMessage.

        self
    }.

    method processClientCommand: command := {
        ## Discard invalid commands.
        command isArray && command size = 3 ifFalse: {
            return: self
        }.

        let cookie := command first.
        let callType := command second.
        let request := command third.

        ## Asynchronous call, with
        callType == #cast ifTrue: {
            return: (self processAsynchronousClientRequest: request)
        }.
        callType == #call ifTrue: {
            return: (self processSynchronousClientRequest: request cookie: cookie)
        }.

        self
    }.

    method processAsynchronousClientRequest: request := {
        server defer: { :: Void |
            self tryToPerformClientRequest: request
        }.

        self
    }.

    method processSynchronousClientRequest: request cookie: cookie := {
        server defer: { :: Void |
            let result := self tryToPerformClientRequest: request.
            self enqueueMessageToClient: (Array with: #response with: cookie with: result)
        }.
        self
    }.

    method performClientRequest: request := {
        self error: "Unimplemented request".
    }.

    method tryToPerformClientRequest: request := {
        try: {
            return: (Array with: #result with: (self performClientRequest: request))
        } catch: Smalltalk Error doing: { :error :: Void |
            return: (Array with: #error with: error asString)
        }.
        nil
    }.
}.

gcclass PharoBridgeServer definition: {
    field listenEndpoint type: StdNative IO Endpoint.
    field listenSocket type: StdNative IO Socket.
    field mainLoopCommandQueue.
    field listeningThreadProcess.

    method start := {
        listenEndpoint := StdNative IO Endpoint ipv4SourcePort: 1234.
        listenSocket := StdNative IO Socket tcpIPv4.
        listenSocket isValid ifFalse: {
            self error: "Failed to create the Pharo bridge server listening socket.".
            return: nil
        }.

        listenSocket setOption: StdNative IO SocketOption ReuseAddress value: 1.

        (listenSocket bind: listenEndpoint) ifFalse: {
            self error: "Failed to bind the listening socket.".
            return: nil
        }.

        listenSocket listen: 1.

        self startListeningThread.
    }.

    method defer: aBlock := {
        mainLoopCommandQueue nextPut: aBlock.
        self.
    }.

    method mainLoop := {
        while: listenSocket isValid do: {
            self waitForCommands
        }.
        self
    }.

    method waitForCommands := {
        let command mutable.
        while: (command := mainLoopCommandQueue next) isNotNil do: {
            command value
        }.
        self.
    }.

    method startListeningThread := {
        mainLoopCommandQueue := AtomicSharedQueue new.
        listeningThreadProcess := {:: Void | self listeningThreadProcessLoop} fork.
        self
    }.

    method listeningThreadProcessLoop := {
        while: listenSocket isValid do: {
            let clientSocket mutable := listenSocket accept.
            clientSocket isValid ifTrue: {
                PharoBridgeServerClientConnection new
                    server: self;
                    handleAcceptedClient: clientSocket.
                nil
            }.
        }.

        self
    }.

}.

}.
