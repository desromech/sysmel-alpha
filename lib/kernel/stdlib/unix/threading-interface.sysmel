namespace StdNative definition: {

/**
 * Pthread mutex wrapper.
 */
class Mutex
definition: {
    field handle public type: Unix pthread_mutex_t.

    message initialize => Void := {
        Unix pthread_mutex_init(handle address, nil).
    }.

    message finalize => Void := {
        Unix pthread_mutex_destroy(handle address).
    }.

    message lock => Void := {
        Unix pthread_mutex_lock(handle address).
    }.

    message unlock => Void := {
        Unix pthread_mutex_unlock(handle address).
    }.

    macro expansionRule heldInThisContext := ``{
        `,self lock.
        ensureCleanup: (`,self unlock)
    } node.

    macro expansionRule withLock: aBlock := ``{
        `,self heldInThisContext.
        aBlock __macroInlineBlock.
    }.
}.

/**
 * Pthread condition variable wrapper.
 */
class ConditionVariable
definition: {
    field handle public type: Unix pthread_cond_t.

    message initialize => Void := {
        Unix pthread_cond_init(handle address, nil).
    }.

    message finalize => Void := {
        Unix pthread_cond_destroy(handle address).
    }.

    message wait: (mutex: Mutex ref) ::=> Void := {
        Unix pthread_cond_wait(handle address, mutex handle address).
    }.

    message notifyOne => Void := {
        Unix pthread_cond_signal(handle address).
    }.

    message notifyAll => Void := {
        Unix pthread_cond_broadcast(handle address).
    }.
}.

/**
 * Semaphore implementation.
 */
class Semaphore
definition: {
    field mutex type: Mutex.
    field condition type: ConditionVariable.
    field count type: UIntPointer.

    message initializeWithCount: (initialCount: UIntPointer) ::=> Void := {
        count := initialCount.
    }.

    message lock => Void := {
        self wait: 1
    }.

    message unlock => Void := {
        self signal: 1
    }.

    message signal => Void
        := self signal: 1.

    message wait => Void
        := self wait: 1.

    message signal: (n: UIntPointer) ::=> Void := {
        n == 0 ifTrue: {
            return: nil
        }.

        mutex withLock: {
            count := count + n.
            n > 1 ifTrue: {
                condition notifyAll.
            } ifFalse: {
                condition notifyOne.
            }
        }
    }.

    message wait: (n: UIntPointer) ::=> Void := {
        n == 0 ifTrue: {
            return: nil
        }.

        mutex withLock: {
            while: (count < n) do: {
                condition wait: mutex
            }.

            count := count - n
        }.
    }.

}.

alias MemoryHeapMutex := Mutex.
}. // End of namespace StdNative
