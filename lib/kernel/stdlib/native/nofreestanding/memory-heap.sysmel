namespace StdNative definition: {

template FixedSizeBuddyMemoryAllocator(MNOSB: _LiteralInteger)
    := class definition: {

    ## Compute the size of the buddy bitmap.
    compileTimeConstant MaxNumberOfSmallestBlocks := MNOSB.

    ## The size of the bitmap.
    compileTimeConstant TotalBlockCount := MaxNumberOfSmallestBlocks*2.
    compileTimeConstant BlockIndexType := UInt16.

    ## The number of levels.
    compileTimeConstant LevelCount := MaxNumberOfSmallestBlocks highBit.
    compileTimeConstant LeafLevelBlockCount := 1<<(LevelCount - 1).

    compileTimeConstant InvalidBlockIndex := -1 castTo: BlockIndexType.
    compileTimeConstant InvalidAllocation := -1 castTo: UIntPointer.

    field allBlocks_nextFreePointer type: (BlockIndexType array: TotalBlockCount).
    field leafBlocks_startRunIndex type: (BlockIndexType array: LeafLevelBlockCount).
    field leafBlocks_allocatedLevel type: (UInt8 array: LeafLevelBlockCount).
    field freeLeafBlockCount type: BlockIndexType.

    field perLevelFreeListHeads type: (BlockIndexType array: LevelCount).

    message initialize => Void := {
        ## Mark the top level as free.
        perLevelFreeListHeads[0] := 0.
        allBlocks_nextFreePointer[0] := InvalidBlockIndex.

        ## Mark the remaining levels as unallocated.
        ##stdout << "init buddy with levels " << (LevelCount castTo: UInt32) << " blocks " << (MaxNumberOfSmallestBlocks castTo: UInt32); nl.
        for: (let i mutable := 1) while: (i < LevelCount) do: {
            perLevelFreeListHeads[i] := InvalidBlockIndex
        } continueWith: (i := i + 1).

        ## Initialize the leaf blocks.
        for: (let i mutable := 0) while: (i < LeafLevelBlockCount) do: {
            leafBlocks_startRunIndex[i] := InvalidBlockIndex.
            leafBlocks_allocatedLevel[i] := 16rff.
        } continueWith: (i := i + 1).

        ## Count all of the leaf blocks as free.
        freeLeafBlockCount := LeafLevelBlockCount.
    }.

    message currentFreeLeafBlockCount => BlockIndexType
        := freeLeafBlockCount.

    message blocksPerLevel: (level: UIntPointer) ::=> UIntPointer := 1<<level.
    message smallBlockCountPerLevel: (level: UIntPointer) ::=> UIntPointer := 1 << (LevelCount - level - 1).

    message totalBlocksBeforeLevel: (level: UIntPointer) ::=> UIntPointer := {
        level == 0
            ifTrue: (0)
            ifFalse: (self blocksPerLevel: level - 1) * 2 - 1
    }.

    message findLevelForBlockCount: (blockCount: UIntPointer) ::=> UIntPointer
        := LevelCount - blockCount log2Ceil - 1.

    message allocateBlocks: (blockCount: UIntPointer) forSlab: (isForSlab: BooleanBit) ::=> UIntPointer := {
        let targetLevel := self findLevelForBlockCount: blockCount.

        let allocatedBlock := self allocateBlockInLevel: targetLevel.
        allocatedBlock == InvalidBlockIndex ifTrue: {
            InvalidAllocation
        } ifFalse: {
            let allocationBlockCount := self smallBlockCountPerLevel: targetLevel.
            assert: freeLeafBlockCount >= allocationBlockCount.
            freeLeafBlockCount := freeLeafBlockCount - allocationBlockCount castTo: BlockIndexType.

            let leafBlockIndex := (allocatedBlock - (self totalBlocksBeforeLevel: targetLevel)) * allocationBlockCount.

            ## Store pointer into all of the starting blocks. This is needed for multi-run slab allocators.
            for: (let i mutable type: UIntPointer := 0) while: i < allocationBlockCount do: {
                leafBlocks_startRunIndex[leafBlockIndex + i] := leafBlockIndex castTo: BlockIndexType.
            } continueWith: (i := i + 1).

            ## Store the target allocated level, and a bit to indicate the presence of a slab.
            leafBlocks_allocatedLevel[leafBlockIndex] := targetLevel | ((isForSlab ifTrue: 16r80 ifFalse: 16r0) castTo: UInt8) castTo: UInt8.

            leafBlockIndex
        }
    }.

    message freeAtBlock: (blockIndex: UIntPointer) ::=> Void := {
        ## Get the index of the first leaf block corresponding to this leaf.
        let leafBlockIndex := leafBlocks_startRunIndex[blockIndex].
        assert: leafBlockIndex ~~ InvalidBlockIndex.

        ## Get the index of the allocated level.
        let allocatedLevel := leafBlocks_allocatedLevel[leafBlockIndex] & 16r7f.
        let allocationBlockCount := self smallBlockCountPerLevel: allocatedLevel.
        freeLeafBlockCount := freeLeafBlockCount + allocationBlockCount castTo: BlockIndexType.

        ## Clear the leaf block metadata.
        for: (let i mutable type: UIntPointer := 0) while: i < allocationBlockCount do: {
            leafBlocks_startRunIndex[leafBlockIndex + i] := InvalidBlockIndex.
        } continueWith: (i := i + 1).

        ## Clear the target allocated level.
        leafBlocks_allocatedLevel[leafBlockIndex] := 16rff.

        ## Compute the level indices.
        let levelIndex := blockIndex / allocationBlockCount.

        self freeBlock: (levelIndex castTo: BlockIndexType) inLevel: allocatedLevel.
    }.

    message freeBlock: (levelIndex: BlockIndexType) inLevel: (level: UIntPointer) ::=> Void := {
        let rawBlockIndex := levelIndex + (self totalBlocksBeforeLevel: level) castTo: BlockIndexType.
        let buddyBlockIndex := (levelIndex isEven ifTrue: (rawBlockIndex + 1) ifFalse: (rawBlockIndex - 1)) castTo: BlockIndexType.

        level > 0 && (self removeBlock: buddyBlockIndex fromFreeListInLevel: level) ifTrue: {
            ##stdout << "TODO: freeBlock inLevel: " << level << " coalesce " << rawBlockIndex << " " << buddyBlockIndex; nl.
            self freeBlock: (levelIndex / 2 castTo: BlockIndexType)inLevel: level - 1
        } ifFalse: {
            ## Put the block in the level free list.
            allBlocks_nextFreePointer[rawBlockIndex] := perLevelFreeListHeads[level].
            perLevelFreeListHeads[level] := rawBlockIndex.

            ##stdout << "TODO: freeBlock " << levelIndex << " inLevel: " << level << " " << levelIndex << " " << rawBlockIndex << " " << buddyBlockIndex; nl.
        }
    }.

    message removeBlock: (buddyBlockIndex: BlockIndexType) fromFreeListInLevel: (level: UIntPointer) ::=> BooleanBit := {
        ## Handle in the first element as a special case.
        perLevelFreeListHeads[level] == buddyBlockIndex ifTrue: {
            perLevelFreeListHeads[level] := allBlocks_nextFreePointer[buddyBlockIndex].
            return: true
        }.

        ## Go through the linked list until we find the element, or the end of the list.
        let currentPosition mutable := perLevelFreeListHeads[level].
        let nextPosition mutable type: BlockIndexType.
        while: ((nextPosition := allBlocks_nextFreePointer[currentPosition]) ~= InvalidBlockIndex) do: {
            nextPosition == buddyBlockIndex ifTrue: {
                allBlocks_nextFreePointer[currentPosition] := allBlocks_nextFreePointer[nextPosition].
                return: true
            }

        } continueWith: (currentPosition := nextPosition).

        false
    }.

    message carveBlockInLevel: (level: UIntPointer) ::=> BlockIndexType := {
        let freeBlock mutable := perLevelFreeListHeads[level].

        freeBlock == InvalidBlockIndex ifTrue: {
            ## Did we reach the root?
            level == 0 ifTrue: {
                return: InvalidBlockIndex
            }.

            ## Carve in the previous level.
            freeBlock := self carveBlockInLevel: level - 1.
            freeBlock == InvalidBlockIndex ifTrue: {
                return: InvalidBlockIndex
            }
        }.

        ##stdout << "Carve level " << level << " free block: " << freeBlock; nl.

        ## Remove the block from the free list.
        perLevelFreeListHeads[level] := allBlocks_nextFreePointer[freeBlock].

        ## Compute the indices of the children.
        let leftIndex := freeBlock * 2 + 1 castTo: BlockIndexType.
        let rightIndex := leftIndex + 1 castTo: BlockIndexType.

        ## Add the children into the free list of the next level.
        allBlocks_nextFreePointer[rightIndex] := perLevelFreeListHeads[level + 1].
        allBlocks_nextFreePointer[leftIndex] := rightIndex.
        perLevelFreeListHeads[level + 1] := leftIndex.

        ## Return the left child.
        leftIndex
    }.

    message allocateBlockInLevel: (targetLevel: UIntPointer) ::=> BlockIndexType := {
        let freeBlock mutable := perLevelFreeListHeads[targetLevel].
        ##stdout << self address << " Level:  " << targetLevel << " free list head " << freeBlock << " next free " << perLevelFreeListHeads[targetLevel + 1]; nl.

        freeBlock == InvalidBlockIndex ifTrue: {
            freeBlock := self carveBlockInLevel: targetLevel - 1.
            freeBlock == InvalidBlockIndex ifTrue: {
                return: InvalidBlockIndex
            }
        }.

        ## We found a block.
        ##stdout << "Found free block: " << freeBlock << " in level " << targetLevel << " next free " << allBlocks_nextFreePointer[freeBlock]; nl.

        ## Remove the block from the linked list.
        perLevelFreeListHeads[targetLevel] := allBlocks_nextFreePointer[freeBlock].

        ## Return the block.
        freeBlock
    }.

    message getAllocatedBlockCountAt: (blockIndex: UIntPointer) ::=> UIntPointer := {
        ## Get the index of the first leaf block corresponding to this leaf.
        let firstBlockIndex := leafBlocks_startRunIndex[blockIndex].
        assert: firstBlockIndex ~~ InvalidBlockIndex.

        ## Get the index of the allocated level.
        assert: leafBlocks_allocatedLevel[firstBlockIndex] ~~ 16rff.
        let allocatedLevel := leafBlocks_allocatedLevel[firstBlockIndex] & 16r7f.
        self smallBlockCountPerLevel: allocatedLevel
    }.

    message getSlabBlockOrInvalid: (blockIndex: UIntPointer) ::=> BlockIndexType := {
        ## Get the index of the first leaf block corresponding to this leaf.
        let firstBlockIndex := leafBlocks_startRunIndex[blockIndex].
        assert: firstBlockIndex ~~ InvalidBlockIndex.

        ## Get the index of the allocated level.
        let allocatedLevel := leafBlocks_allocatedLevel[firstBlockIndex].
        ##stdout << blockIndex << " first block " << firstBlockIndex << " allocatedLevel " << allocatedLevel; nl.
        assert: allocatedLevel ~= 16rff.

        ## Check the slab flag.
        (allocatedLevel & 16r80) ~~ 0 ifTrue: {
            firstBlockIndex
        } ifFalse: {
            InvalidBlockIndex
        }
    }.

    message hasFreeBlockInLevel: (targetLevel: UIntPointer) ::=> BooleanBit := {
        let freeBlock := perLevelFreeListHeads[targetLevel].

        freeBlock == InvalidBlockIndex ifTrue: {
            ## Did we reach the root?
            targetLevel == 0 ifTrue: {
                false
            } ifFalse: {
                self hasFreeBlockInLevel: targetLevel - 1
            }
        } ifFalse:{
            true
        }
    }.

}.

#**
 * NativeMemoryHeap
 * A data structure for implementing malloc/free and family.
 * This implementation is partially based on jemalloc:
 *        this is jemalloc (A Scalable Concurrent malloc(3) Implementation for FreeBSD
 *        -- https:##www.bsdcan.org/2006/papers/jemalloc.pdf )
 * TODO: - Per processor arenas.
 *       - Dedicated chunk allocation.
 *#
class NativeMemoryHeap definition: {
    compileTimeConstant MemoryChunkSize := 16r200000 castTo: UIntPointer.
    compileTimeConstant MemoryChunkAlignment := 16r200000 castTo: UIntPointer.
    compileTimeConstant HugeAllocationThreshold := MemoryChunkSize / 2 castTo: UIntPointer.
    compileTimeConstant LargeAllocationThreshold := 16r1000 castTo: UIntPointer.

    compileTimeConstant MemoryChunkBlockSize := 16r800.
    compileTimeConstant MemoryChunkBlockCount := MemoryChunkSize / MemoryChunkBlockSize.

    compileTimeConstant ChunkBuddyMemoryAllocator := FixedSizeBuddyMemoryAllocator(MemoryChunkBlockCount).

    compileTimeConstant AllocationType_Small := 0.
    compileTimeConstant AllocationType_Large := 1.
    compileTimeConstant AllocationType_Huge := 2.

    compileTimeConstant QuantumSpacedCategories := 512 / 16.

    #**
     * A common chunk header
     *#
    struct CommonChunkHeader definition: {
        field isHugeAllocation public type: BooleanBit.
    }.

    struct HugeChunkHeader definition: {
        field commonHeader public type: CommonChunkHeader.
        field allocationSize public type: UIntPointer.
    }.

    compileTimeConstant HugeChunkHeaderSize := HugeChunkHeader instanceSize alignedTo: 16.

    #**
     * A memory allocation chunk header.
     *#
    struct NormalChunkHeader definition: {
        field commonHeader public type: CommonChunkHeader.

        field previousChunk public type: NormalChunkHeader pointer.
        field nextChunk public type: NormalChunkHeader pointer.

        field initialFreeBlockCount public type: ChunkBuddyMemoryAllocator BlockIndexType.

        field buddyMemoryAllocator public type: ChunkBuddyMemoryAllocator.

        message isCompletelyFree => BooleanBit
            := initialFreeBlockCount == buddyMemoryAllocator currentFreeLeafBlockCount.
    }.

    #**
     * Quantum spaced category run
     *#
    struct SlabHeader definition: {
        compileTimeConstant MaxNumberOfElements := 256.
        compileTimeConstant WordBitCount := UIntPointer instanceSize*8.
        compileTimeConstant BitmapWords := MaxNumberOfElements / WordBitCount.
        compileTimeConstant FullWord := -1 castTo: UIntPointer.

        ## Linked list between all slabs.
        field previousSlab public type: SlabHeader pointer.
        field nextSlab public type: SlabHeader pointer.

        ## Linked list between active slabs.
        field previousActiveSlab public type: SlabHeader pointer.
        field nextActiveSlab public type: SlabHeader pointer.

        field elementSize public type: UInt16.
        field elementCount public type: UInt16.
        field freeCount public type: UInt16.
        field category public type: UInt8.
        field _ type: UInt8.

        field bitmap public type: (UIntPointer array: BitmapWords).

        message setupForElements: (count: UIntPointer) ::=> Void := {
            elementCount := count castTo: UInt16.
            freeCount := count castTo: UInt16.

            let bitmapWordCount := self bitmapWordCount.
            let lastWordFreeElements := elementCount % WordBitCount castTo: UInt16.
            lastWordFreeElements ~~ 0 ifTrue: {
                ## Mark the unused elements in the bitmap as allocated.
                let lastWordFreeElementsMask := ((1 castTo: UIntPointer) << lastWordFreeElements) - 1.
                let lastWordUnusedElementsMask := lastWordFreeElementsMask bitInvert.
                bitmap[bitmapWordCount - 1] := lastWordUnusedElementsMask.
            }.
        }.

        message bitmapWordCount => UIntPointer
            := (elementCount + WordBitCount - 1) / WordBitCount.

        message findFreeElementIndex => Int32 := {
            let bitmapWordCount := self bitmapWordCount.

            for: (let i mutable type: UIntPointer := 0) while: (i < bitmapWordCount) do: {
                bitmap[i] ~~ FullWord ifTrue: {
                    let freeBit := bitmap[i] bitInvert lowBit.
                    freeBit ~= 0 ifTrue: {
                        return: (i*WordBitCount + freeBit - 1 castTo: Int32)
                    }.
                }
            } continueWith: (i := i + 1).

            -1
        }.

        message markElement: (elementIndex: UIntPointer) ::=> Void := {
            let wordIndex := elementIndex / WordBitCount.
            let wordBitIndex := elementIndex % WordBitCount.
            let bit := (1 castTo: UIntPointer) << wordBitIndex.
            bitmap[wordIndex] := bitmap[wordIndex] | bit.

            freeCount := freeCount - 1 castTo: UInt16
        }.

        message unmarkElement: (elementIndex: UIntPointer) ::=> Void := {
            let wordIndex := elementIndex / WordBitCount.
            let wordBitIndex := elementIndex % WordBitCount.
            let bit := (1 castTo: UIntPointer) << wordBitIndex.
            bitmap[wordIndex] := bitmap[wordIndex] & bit bitInvert.

            freeCount := freeCount + 1 castTo: UInt16
        }.

        message isCompletelyFree => BooleanBit
            := freeCount == elementCount.
    }.

    compileTimeConstant SlabHeaderSize := SlabHeader instanceSize alignedTo: 16.

    #**
     * Quantum space category active run state.
     *#
    struct QuantumSpacedCategoryState definition: {
        field firstActiveSlab public type: SlabHeader pointer.
        field lastActiveSlab public type: SlabHeader pointer.

        field firstSlab public type: SlabHeader pointer.
        field lastSlab public type: SlabHeader pointer.

        message isActiveSlab: (slab: SlabHeader pointer) ::=> BooleanBit
            := firstActiveSlab == slab || lastActiveSlab == slab ||
            slab _ previousActiveSlab isNotNil || slab _ nextActiveSlab isNotNil.

        message addSlab: (slab: SlabHeader pointer) ::=> Void := {
            firstSlab ifNil: {
                assert: lastSlab isNil.
                firstSlab := lastSlab := slab
            } ifNotNil: {
                slab _ nextSlab: firstSlab.
                firstSlab _ previousSlab: slab.
                firstSlab := slab
            }.
        }.

        message removeSlab: (slab: SlabHeader pointer) ::=> Void := {
            slab _ previousSlab ifNil: {
                firstSlab := slab _ nextSlab.
            } ifNotNil: {
                slab _ previousSlab _ nextSlab: slab _ nextSlab.
            }.

            slab _ nextSlab ifNil: {
                lastSlab := slab _ previousSlab.
            } ifNotNil: {
                slab _ nextSlab _ previousSlab: slab _ previousSlab.
            }.

            slab _
                previousSlab: nil;
                nextSlab: nil.
        }.

        message activateSlab: (slab: SlabHeader pointer) ::=> Void := {
            assert: slab _ previousActiveSlab isNil.
            assert: slab _ nextActiveSlab isNil.
            firstActiveSlab ifNil: {
                assert: lastActiveSlab isNil.
                firstActiveSlab := lastActiveSlab := slab
            } ifNotNil: {
                slab _ nextActiveSlab: firstActiveSlab.
                firstActiveSlab _ previousActiveSlab: slab.
                firstActiveSlab := slab
            }
        }.

        message deactivateSlab: (slab: SlabHeader pointer) ::=> Void := {
            slab _ previousActiveSlab ifNil: {
                firstActiveSlab := slab _ nextActiveSlab.
            } ifNotNil: {
                slab _ previousActiveSlab _ nextActiveSlab: slab _ nextActiveSlab.
            }.

            slab _ nextActiveSlab ifNil: {
                lastActiveSlab := slab _ previousActiveSlab.
            } ifNotNil: {
                slab _ nextActiveSlab _ previousActiveSlab: slab _ previousActiveSlab.
            }.

            slab _
                previousActiveSlab: nil;
                nextActiveSlab: nil.
        }.

    }.

    field mutex private type: MemoryHeapMutex.
    field firstChunk private type: NormalChunkHeader pointer.
    field lastChunk private type: NormalChunkHeader pointer.

    field quantumSpacedCategoryStates type: (QuantumSpacedCategoryState array: QuantumSpacedCategories + 1).

    message allocateInitializedWithZero: (size: UIntPointer) ::=> Void pointer := {
        let result := self allocate: size.
        result ifNotNil: {
            StdNative memset(result, 0, size).
        }.

        result
    }.

    message reallocate: (pointer: Void pointer) withNewSize: (newSize: UIntPointer) ::=> Void pointer := {
        pointer ifNil: {
            return: (self allocate: newSize)
        }.


        let size := self getAllocationSize: pointer.
        size >= newSize ifTrue: {
            pointer
        } ifFalse: {
            let newPointer := self allocate: newSize.
            memcpy(newPointer, pointer, size).
            self free: pointer.
            newPointer
        }
    }.

    message allocate: (size: UIntPointer) ::=> Void pointer := {
        size == 0 ifTrue: {
            return: nil
        }.

        ## Is this a large allocation?
        size >= LargeAllocationThreshold ifTrue: {
            ## Is this a huge allocation?
            size >= HugeAllocationThreshold ifTrue: {
                self allocateHuge: size.
            } ifFalse: {
                self allocateLarge: size
            }
        } ifFalse: {
            self allocateSmall: size
        }
    }.

    message getAllocationSize: (pointer: Void pointer) ::=> UIntPointer := {
        pointer ifNil: {
            return: 0
        }.

        ## Get the base address of the chunk.
        let pointerAddress := pointer reinterpretCastTo: UIntPointer.
        let chunkAddress := pointerAddress floorAlignedTo: MemoryChunkAlignment.
        let commonChunkPointer := chunkAddress reinterpretCastTo: CommonChunkHeader pointer.

        ## Is this a chunk for a huge allocation?.
        commonChunkPointer _ isHugeAllocation ifTrue: {
            let hugeChunkHeader := chunkAddress reinterpretCastTo: HugeChunkHeader pointer.
            return: hugeChunkHeader _ allocationSize.
        }.

        mutex withLock: {
            ## We are dealing with a normal chunk.
            let normalChunkHeader := chunkAddress reinterpretCastTo: NormalChunkHeader pointer.
            let chunkOffset := pointerAddress - chunkAddress.
            let buddyBlockIndex := chunkOffset / MemoryChunkBlockSize.

            ## Get the starting block of the slab.
            let slabBlockIndex := normalChunkHeader _ buddyMemoryAllocator getSlabBlockOrInvalid: buddyBlockIndex.

            slabBlockIndex ~~ ChunkBuddyMemoryAllocator InvalidBlockIndex ifTrue: {
                let slabAddress := chunkAddress + (slabBlockIndex * MemoryChunkBlockSize castTo: UIntPointer).
                let slabHeader := slabAddress reinterpretCastTo: SlabHeader pointer.

                slabHeader _ elementSize
            } ifFalse: {
                ## This is a large allocation, ask the buddy memory allocator about the allocated block count.
                (normalChunkHeader _ buddyMemoryAllocator getAllocatedBlockCountAt: buddyBlockIndex) * MemoryChunkBlockSize
            }

        }.
    }.

    message free: (pointer: Void pointer) ::=> Void := {
        ## Ignore null pointers.
        pointer ifNil: {
            return: nil
        }.

        ## Get the base address of the chunk.
        let pointerAddress := pointer reinterpretCastTo: UIntPointer.
        let chunkAddress := pointerAddress floorAlignedTo: MemoryChunkAlignment.
        let commonChunkPointer := chunkAddress reinterpretCastTo: CommonChunkHeader pointer.

        ## Is this a chunk for a huge allocation?.
        commonChunkPointer _ isHugeAllocation ifTrue: {
            ## Just unmap the huge allocation.
            let hugeChunkHeader := chunkAddress reinterpretCastTo: HugeChunkHeader pointer.
            NativeVirtualMemoryInterface freeAddressSpace: hugeChunkHeader size: hugeChunkHeader _ allocationSize.
            return: nil.
        }.

        mutex withLock: {
            ## We are dealing with a normal chunk.
            let normalChunkHeader := chunkAddress reinterpretCastTo: NormalChunkHeader pointer.
            let chunkOffset := pointerAddress - chunkAddress.
            let buddyBlockIndex := chunkOffset / MemoryChunkBlockSize.

            ## Get the starting block of the slab.
            let slabBlockIndex := normalChunkHeader _ buddyMemoryAllocator getSlabBlockOrInvalid: buddyBlockIndex.

            ##stdout << pointer << " normalChunkHeader " << normalChunkHeader << " " << buddyBlockIndex << " " << slabBlockIndex; nl.

            slabBlockIndex ~~ ChunkBuddyMemoryAllocator InvalidBlockIndex ifTrue: {
                let slabAddress := chunkAddress + (slabBlockIndex * MemoryChunkBlockSize castTo: UIntPointer).
                let slabHeader := slabAddress reinterpretCastTo: SlabHeader pointer.
                let slabElementIndex := (pointerAddress - (slabAddress + SlabHeaderSize)) / slabHeader _ elementSize.

                ##stdout << "Slab " << slabHeader << " element size " << slabHeader _ elementSize << " index " << slabElementIndex; nl.

                ## Mark the element as free in the slab.
                slabHeader _  unmarkElement: slabElementIndex.

                ## Ensure the slab is active, or it is freed.
                self processSlabWithFreedElement: slabHeader blockIndex: slabBlockIndex inChunk: normalChunkHeader.

            } ifFalse: {
                ## This is a large allocation, we need to free the corresponding buddy.
                self freeLargeAllocationBlock: buddyBlockIndex inChunk: normalChunkHeader.
            }
        }
    }.


    #**
     * This makes sure the slab is active, or it is completely freed, after freeing an element.
     *#
    message processSlabWithFreedElement: (slabHeader: SlabHeader pointer) blockIndex: (slabBlockIndex: UIntPointer) inChunk: (normalChunkHeader: NormalChunkHeader pointer) ::=> Void := {
        let categoryState ref := quantumSpacedCategoryStates[slabHeader _ category].
        let isActiveSlab := categoryState isActiveSlab: slabHeader.

        slabHeader _ isCompletelyFree ifTrue: {
            isActiveSlab ifTrue: {
                categoryState deactivateSlab: slabHeader.
            }.
            categoryState removeSlab: slabHeader.
            self freeLargeAllocationBlock: slabBlockIndex inChunk: normalChunkHeader
        } ifFalse: {
            ## Maybe we need to make sure this slab active
            slabHeader _ freeCount > 0 ifTrue: {
                isActiveSlab ifFalse: {
                    categoryState activateSlab: slabHeader.
                }.
            }.
        }
    }.

    #**
     * This frees a large allocation through the buddy memory allocator.
     *#
    message freeLargeAllocationBlock: (buddyBlockIndex: UIntPointer) inChunk: (normalChunkHeader: NormalChunkHeader pointer) ::=> Void := {
        ##stdout << normalChunkHeader << " normalChunkHeader initialFreeBlockCount " << normalChunkHeader _ initialFreeBlockCount << " " << normalChunkHeader _ buddyMemoryAllocator currentFreeLeafBlockCount; nl.

        normalChunkHeader _ buddyMemoryAllocator freeAtBlock: buddyBlockIndex.

        ##stdout << normalChunkHeader << " normalChunkHeader initialFreeBlockCount " << normalChunkHeader _ initialFreeBlockCount << " " << normalChunkHeader _ buddyMemoryAllocator currentFreeLeafBlockCount; nl.
        normalChunkHeader _ isCompletelyFree ifTrue: {
            self removeChunk: normalChunkHeader.
            NativeVirtualMemoryInterface freeAddressSpace: normalChunkHeader size: MemoryChunkSize.
            ## stdout << "Free chunk " << normalChunkHeader; nl.
        }.
    }.

    #**
     * Small allocation
     *#
    message allocateSmall: (size: UIntPointer) ::=> Void pointer := {
        size <= 512 ifTrue: {
            self allocateQuantumSpaced: size
        } ifFalse: {
            self allocateLarge: size
        }
    }.

    #**
     * Quantum spaced allocations.
     *#
    message allocateQuantumSpaced: (size: UIntPointer) ::=> Void pointer := {
        let category := (size + 15) / 16.

        mutex withLock: {
            ## Make sure there is an active run in the category.
            let categoryState ref := quantumSpacedCategoryStates[category].
            categoryState firstActiveSlab ifNil: {
                self createSlabForQuantumSpacedCategory: category.
                categoryState firstActiveSlab ifNil: {
                    return: nil
                }
            }.

            ## Fetch the slab and some of its pointers.
            let slab := categoryState firstActiveSlab.
            let slabBytes := slab reinterpretCastTo: UInt8 pointer.
            let slabData := slabBytes[SlabHeaderSize] address.

            let freeElementIndex := slab _ findFreeElementIndex.
            assert: freeElementIndex >= 0.

            ##stdout << "Allocate from active category slab: " << categoryState firstActiveSlab << " element " << freeElementIndex; nl.
            slab _ markElement: (freeElementIndex castTo: UIntPointer).

            ## If we fill the slab, make it unactive.
            slab _ freeCount == 0 ifTrue: {
                categoryState deactivateSlab: slab
            }.

            ## Compute the pointer into the allocated slab element.
            let slabElementPointer := slabData[slab _ elementSize * freeElementIndex] address.

            ## Return the slab element pointer
            slabElementPointer
        }
    }.

    #**
     * Creates a slab
     *#
    message createSlabForQuantumSpacedCategory: (category: UIntPointer) ::=> SlabHeader pointer := {
        let categoryElementSize := category * 16.
        let allocationSize := SlabHeaderSize + categoryElementSize * 33 alignedTo: 4096. ## Go for no more than 3 % of overheader

        ## Compute an initial best element count estimate.
        let elementCount := (allocationSize - SlabHeaderSize) / categoryElementSize.

        ## Allocate the slab
        let slab := (self doAllocateLarge: allocationSize forSlab: true) reinterpretCastTo: UInt8 pointer.
        slab ifNil: {
            return: nil
        }.

        ## Clear the slab memory.
        memset(slab, 0, allocationSize).

        ## Set the slab header.
        let slabHeader := slab reinterpretCastTo: SlabHeader pointer.
        slabHeader _
            elementSize: (categoryElementSize castTo: UInt16);
            category: (category castTo: UInt8);
            setupForElements: elementCount.

        ## Put the slab in the linked list.
        let categoryState ref := quantumSpacedCategoryStates[category].
        categoryState
            addSlab: slabHeader;
            activateSlab: slabHeader.

        ##stdout << "Slab category: " << category << " allocationSize " << allocationSize << " element count " << elementCount; nl.
        slabHeader
    }.

    #**
     * Large allocation. Buddy memory allocation system.
     *#
    message allocateLarge: (size: UIntPointer) ::=> Void pointer := {
        mutex withLock: {
            self doAllocateLarge: size forSlab: false
        }
    }.

    message doAllocateLarge: (size: UIntPointer) forSlab: (isForSlab: BooleanBit) ::=> Void pointer := {
        ## Find or create the chunk.
        let chunk := self findOrCreateChunkWithAvailableSize: size.
        chunk ifNil: {
            return: nil
        }.

        ##stdout << "Allocate in chunk " << chunk << " size " << size; nl.

        ## Allocate the blocks
        let blockCount := self blockCountForSize: size.
        let allocatedBlock := chunk _ buddyMemoryAllocator allocateBlocks: blockCount forSlab: isForSlab.
        assert: allocatedBlock ~~ ChunkBuddyMemoryAllocator InvalidAllocation.

        ## Get the allocation memory.
        let chunkOffset := allocatedBlock*MemoryChunkBlockSize.
        let allocationMemory := (chunk reinterpretCastTo: UInt8 pointer)[chunkOffset] address.

        ##stdout << "Allocated block " << allocatedBlock << " pointer: " << allocationMemory; nl.

        ## Return a pointer into the actual allocated memory
        allocationMemory
    }.

    #**
     * Huge allocation. This creates a dedicated mmap.
     *#
    message allocateHuge: (size: UIntPointer) ::=> Void pointer := {
        mutex withLock: {
            ## Compute the size of the allocation.
            let allocationSize := size + HugeChunkHeaderSize alignedTo: 4096.
            ##stdout << "Allocate large memory chunk of size " << allocationSize; nl.

            ## Allocate the super-chunk.
            let largeAllocation := (NativeVirtualMemoryInterface reserveAndCommitAddressSpace: allocationSize alignment: MemoryChunkAlignment) reinterpretCastTo: UInt8 pointer.
            largeAllocation ifNil: {
                return: nil
            }.

            ##stdout << "Allocated large memory chunk: " << largeAllocation; nl.

            ## Set the header.
            let header := largeAllocation reinterpretCastTo: HugeChunkHeader pointer.
            header _ commonHeader isHugeAllocation: true.
            header _ allocationSize: size.

            ## Return the allocated memory.
            largeAllocation[HugeChunkHeaderSize] address.
        }
    }.

    #**
     * Allocates a new memory chunk.
     *#
    message allocateNewChunk => NormalChunkHeader pointer := {
        let chunk := (NativeVirtualMemoryInterface reserveAndCommitAddressSpace: MemoryChunkSize alignment: MemoryChunkAlignment) reinterpretCastTo: NormalChunkHeader pointer.
        ##stdout << "Allocated memory chunk: " << chunk; nl.

        chunk ifNil: {
            return: nil
        }.

        ## Store the chunk in a linked list.
        self addChunk: chunk.

        ## Allocate the chunk header in the buddy memory allocator.
        ##stdout << "NormalChunkHeader instanceSize " << (NormalChunkHeader instanceSize castTo: UIntPointer); nl.
        chunk _ buddyMemoryAllocator
            initialize;
            allocateBlocks: (self blockCountForSize: NormalChunkHeader instanceSize) forSlab: false.
        chunk _ initialFreeBlockCount: chunk _ buddyMemoryAllocator currentFreeLeafBlockCount.

        chunk
    }.

    #**
     * Adds a chunk into the list of chunks.
     *#
    message addChunk: (chunk: NormalChunkHeader pointer) ::=> Void := {
        ## Put the chunk in the beginning of the double linked list.
        firstChunk ifNil: {
            firstChunk := lastChunk := chunk.
        } ifNotNil: {
            chunk _ nextChunk: firstChunk.
            firstChunk _ previousChunk: chunk.
            firstChunk := chunk.
        }.
    }.

    #**
     * Removes a chunk from the linked list of chunks.
     *#
    message removeChunk: (chunk: NormalChunkHeader pointer) ::=> Void := {
        chunk _ previousChunk ifNil: {
            firstChunk := chunk _ nextChunk.
        } ifNotNil: {
            chunk _ previousChunk _ nextChunk: chunk _ nextChunk
        }.

        chunk _ nextChunk ifNil: {
            lastChunk := chunk _ previousChunk.
        } ifNotNil: {
            chunk _ nextChunk _ previousChunk: chunk _ previousChunk
        }.

        chunk _
            nextChunk: nil;
            previousChunk: nil.
    }.

    #**
     * This computes the number of required blocks for a given size.
     *#
    message blockCountForSize: (size: UIntPointer) ::=> UIntPointer
        := (size + MemoryChunkBlockSize - 1) / MemoryChunkBlockSize.

    #**
     * Finds a chunk with the required available size.
     *#
    message findChunkWithAvailableSize: (requiredSize: UIntPointer) ::=> NormalChunkHeader pointer := {
        firstChunk ifNil: {
            return: nil
        }.

        let requiredBlocks := self blockCountForSize: requiredSize.
        let requiredLevel := firstChunk _ buddyMemoryAllocator findLevelForBlockCount: requiredBlocks.
        ##stdout << "findChunkWithAvailableSize level " << requiredLevel; nl.

        ## Linearly find a chunk with the requred size.
        ## TODO: Sort the chunks in an AVL tree.
        let currentChunk mutable := firstChunk.
        while: currentChunk isNotNil do: {
            (currentChunk _ buddyMemoryAllocator hasFreeBlockInLevel: requiredLevel) ifTrue: {
                return: currentChunk
            }
        } continueWith: (currentChunk := currentChunk _ nextChunk).

        nil
    }.

    #**
     * Finds a chunk with the required available size.
     *#
    message findOrCreateChunkWithAvailableSize: (requiredSize: UIntPointer) ::=> NormalChunkHeader pointer := {
        let chunk := self findChunkWithAvailableSize: requiredSize.
        chunk
            ifNotNil: {chunk}
            ifNil: {self allocateNewChunk}.
    }.
}.

global globalNativeMemoryHeap mutable type: NativeMemoryHeap.

function malloc(size: UIntPointer) => Void pointer
    := globalNativeMemoryHeap allocate: size.

function zmalloc(size: UIntPointer) => Void pointer
    := globalNativeMemoryHeap allocateInitializedWithZero: size.

function calloc(numberOfElements: UIntPointer, elementSize: UIntPointer) => Void pointer
    := globalNativeMemoryHeap allocateInitializedWithZero: numberOfElements*elementSize.

function realloc(pointer: Void pointer, size: UIntPointer) => Void pointer
    := globalNativeMemoryHeap reallocate: pointer withNewSize: size.

function free(pointer: Void pointer) => Void
    := globalNativeMemoryHeap free: pointer.


## basicNativeNew macro
_PrimitiveType meta macro expansionRule basicNativeNew := ``(
    (StdNative zmalloc(`,self instanceSize) reinterpretCastTo: `,self pointer) _
        basicInitialize;
        address
).

_StructureType meta macro expansionRule basicNativeNew := ``(
    (StdNative zmalloc(`,self instanceSize) reinterpretCastTo: `,self pointer) _
        basicInitialize;
        address
).

## basicNativeDelete
_PointerType macro expansionRule basicNativeDelete := ``(
    StdNative free(`,self)
).

## Native new
_PrimitiveType meta macro expansionRule nativeNew := ``(
    (`,self basicNativeNew) _
        initialize;
        address
).

_StructureType meta macro expansionRule nativeNew := ``(
    (`,self basicNativeNew) _
        initialize;
        address
).

## nativeDelete
_PointerType macro expansionRule nativeDelete := ``(
    `,self ifNotNil: {
        (`,self _
            finalize;
            address) basicNativeDelete
    }
).

}. ## End of namespace StdNative
