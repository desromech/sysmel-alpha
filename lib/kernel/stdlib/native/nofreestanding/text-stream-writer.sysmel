namespace StdNative definition: {

#**
 * Text stream writer
 *#
class TextStreamWriter definition: {
    field stream public type: BinaryStream pointer.

    meta message for: (stream: BinaryStream pointer) ::=> SelfType
        := SelfType newValue
            stream: stream;
            yourself.

    message nextPut: (character: Int32) ::=> BooleanBit := {
        let buffer mutable type: UInt8 := character castTo: UInt8.
        (stream _ write: buffer address size: 1) == 1
    }.

    message nextPutAll: (string: StdNative StringLiteral) ::=> BooleanBit := {
        (stream _ write: string [0] address size: string size) == (string size castTo: IntPointer)
    }.

    message write: (string: Void const pointer) size: (size: UIntPointer) ::=> BooleanBit := {
        (stream _ write: string size: size) == (size castTo: IntPointer)
    }.

    message nextPutHexDigit: (digit: Int32) ::=> Void := {
        if: 0 <= digit && digit <= 9 then: {
            self nextPut: '0' + digit
        } else: {
            self nextPut: 'a' + digit - 10
        }
    }.

    ## Integer formatting.
    message nextPutInteger: (value: Int64) ::=> Void := {
        ## Extract the digits, in reverse order.
        let currentValue mutable := value < 0 ifTrue: -value ifFalse: value.
        let digitCount mutable := 0.
        let buffer mutable type: (UInt8 array: 32).

        do: {
            let digit := '0' + currentValue % 10.
            buffer[digitCount] := digit castTo: UInt8.

            digitCount := digitCount + 1.
            currentValue := currentValue / 10
        } while: (currentValue ~= 0).

        ## Put the sign.
        if: value < 0 then: {
            self nextPut: '-'
        }.

        ## Print the digits in the correct order
        while: (digitCount > 0) do: {
            digitCount := digitCount - 1.
            self nextPut: buffer[digitCount]
        }.
    }.

    message nextPutUnsignedInteger: (value: UInt64) ::=> Void := {
        ## Extract the digits, in reverse order.
        let currentValue mutable := value.
        let digitCount mutable := 0.
        let buffer mutable type: (UInt8 array: 32).

        do: {
            let digit := '0' + currentValue % 10.
            buffer[digitCount] := digit castTo: UInt8.

            digitCount := digitCount + 1.

            currentValue := currentValue / 10
        } while: (currentValue ~= 0).

        ## Print the digits in the correct order
        while: (digitCount > 0) do: {
            digitCount := digitCount - 1.
            self nextPut: buffer[digitCount]
        }.
    }.

    message nextPutBigInteger: (bigInteger: FloatStringConversionBigInteger const ref) ::=> Void := {
        0 to: FloatStringConversionBigInteger WordCount do: {|(i: UIntPointer) => Void|.
            self nextPutLittleUInt32: bigInteger words[i]
        }
    }.

    ## Floating point formatting
    message nextPutDouble: (double: Float64) ::=> Void := {
        let doubleMemory mutable := double.
        let ieee754Double := (doubleMemory address reinterpretCastTo: UInt64 pointer) value.

        let negative := (ieee754Double >> 63) ~= 0.
        let exponent := (ieee754Double >> 52) & ((1<<11) - 1).
        let rawMantissa := ieee754Double & ((1<<52) - 1).

        exponent == 0 && rawMantissa == 0 ifTrue: {
            negative ifTrue: {
                self << "-0.0".
            } ifFalse: {
                self << "0.0".
            }.

            return: nil
        }.

        exponent == 16r7FF ifTrue: {
            rawMantissa == 0 ifTrue: {
                negative ifTrue: {
                    self << "-inf".
                } ifFalse: {
                    self << "inf".
                }.

            } ifFalse: {
                self << "nan"
            }.

            return: nil
        }.

        negative ifTrue: {
            self nextPut: '-'.
        }.

        let mantissa := rawMantissa | (1 <<52).

        let numerator mutable type: FloatStringConversionBigInteger.
        let denominator mutable type: FloatStringConversionBigInteger.
        exponent == 0 ifTrue: {
        } ifFalse: {
        }.

        self << "e" << exponent << "m" << mantissa.
        ##let decimalPart mutable type: FloatStringConversionBigInteger := mantissa.
        ##self << "e" << exponent << "m" << mantissa << "dp" << decimalPart words[0] << ":" << decimalPart words[1] << ":" << decimalPart words[2] << ":"; nextPutBigInteger: decimalPart.
    }.

    ## Pointer formatting.
    message nextPutLittleUInt32: (value: UInt32) ::=> Void := {
        0 until: 32 by: 4 do: {|(i: UInt32) => Void|.
            self nextPutHexDigit: ((value >> i) & 16rF castTo: Int32)
        }.
    }.

    message nextPutHexPointer: (address: UInt32) ::=> Void := {
        for: (let i mutable type: Int32 := 28) while: i >= 0 do: {
            self nextPutHexDigit: ((address >> (i castTo: UInt32)) & 16rF castTo: Int32)
        } continueWith: (i := i - 4).
    }.

    message nextPutHexPointer: (address: UInt64) ::=> Void := {
        for: (let i mutable type: Int32 := 60) while: i >= 0 do: {
            self nextPutHexDigit: ((address >> (i castTo: UInt64)) & 16rF castTo: Int32)
        } continueWith: (i := i - 4).
    }.

    message nextPutHexPointer: (pointer: Void pointer) ::=> Void := {
        self nextPutHexPointer: (pointer reinterpretCastTo: UIntPointer).
    }.

    message nextPutCString:(cstring: UInt8 const pointer) ::=> BooleanBit := {
        cstring ifNil: {
            true
        } ifNotNil: {
            let length := cstrlen(cstring).
            (stream _ write: cstring size: length) == (length castTo: IntPointer)
        }
    }.

    ## Special characters
    message tab => SelfType ref
        := self nextPut: '\t'; yourself.

    message lf => SelfType ref
        := self nextPut: '\n'; yourself.

    message cr => SelfType ref
        := self nextPut: '\r'; yourself.

    message crlf => SelfType ref
        := self nextPutAll: "\r\n"; yourself.

    message nl => SelfType ref
        := self lf; yourself.

    ## Convenience printing methods.
    message << (string: StdNative StringLiteral) => SelfType ref
        := self nextPutAll: string; yourself.

    message << (integer: Int8) => SelfType ref
        := self nextPutInteger: integer; yourself.

    message << (integer: Int16) => SelfType ref
        := self nextPutInteger: integer; yourself.

    message << (integer: Int32) => SelfType ref
        := self nextPutInteger: integer; yourself.

    message << (integer: Int64) => SelfType ref
        := self nextPutInteger: integer; yourself.

    message << (integer: UInt8) => SelfType ref
        := self nextPutUnsignedInteger: integer; yourself.

    message << (integer: UInt16) => SelfType ref
        := self nextPutUnsignedInteger: integer; yourself.

    message << (integer: UInt32) => SelfType ref
        := self nextPutUnsignedInteger: integer; yourself.

    message << (integer: UInt64) => SelfType ref
        := self nextPutUnsignedInteger: integer; yourself.

    message << (pointer: Void pointer) => SelfType ref
        := self nextPutHexPointer: pointer; yourself.

    message << (float: Float32) => SelfType ref
        := self nextPutDouble: float; yourself.

    message << (double: Float64) => SelfType ref
        := self nextPutDouble: double; yourself.
}.

#*PrimitiveVectorTypeTemplate extend: {
    let VectorType := SelfType.

    TextStreamWriter extend: {
        message << (vector: VectorType) => SelfType ref := {
            self << vector x.
            compileTimeIf: ElementCount > 1 then: {
                self nextPut: ' '.
                self << vector y.
                compileTimeIf: ElementCount > 2 then: {
                    self nextPut: ' '.
                    self << vector z.
                    compileTimeIf: ElementCount > 3 then: {
                        self nextPut: ' '.
                        self << vector w.
                    }
                }
            }.

            self
        }.
    }.
}.*#

global stdout mutable := TextStreamWriter for: stdoutFile address.
global stderr mutable := TextStreamWriter for: stderrFile address.
}.
