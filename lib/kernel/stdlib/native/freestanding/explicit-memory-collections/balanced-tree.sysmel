namespace StdNative definition: {
namespace ExplicitMemoryCollections definition: {

/**
 * I am the definition for a balanced tree node with explicit memory management semantics.
 * AVL tree: https://en.wikipedia.org/wiki/AVL_tree
 */
template BalancedTree(KT: Type, VT: Type)
    := struct definition: {

    alias Node := SelfType.
    alias KeyType := KT.
    alias ValueType := VT.

    alias BalanceFactorMask := 3 castTo: UIntPointer.
    alias ChildPointerMask := ~BalanceFactorMask.

    field left_ type: UIntPointer. // Use the left pointer to encode the balance factor.
    field right public type: Node pointer.
    field key public type: KeyType.

    // Having a different value is optional.
    if: ValueType isVoidType not then: {
        field value public type: ValueType.

        message replaceValueWith: (otherNode: SelfType pointer) ::=> Void := {
            value := otherNode _ value
        }
    } else: {
        message replaceValueWith: (otherNode: SelfType pointer) ::=> Void := {
            // Do nothing.
        }
    }.

    // Left pointer accessor.
    message left => Node pointer
        := left_ & ChildPointerMask reinterpretCastTo: Node pointer.

    message left: (newLeftNode: Node pointer) ::=> Void := {
        left_ := (left_ & BalanceFactorMask) | ((newLeftNode reinterpretCastTo: UIntPointer) & ChildPointerMask)
    }.

    // Balance factor accessor.
    message balanceFactor => Int32
        := (left_ & BalanceFactorMask castTo: Int32) - 1.

    message balanceFactor: (newFactor: Int32) ::=> Void := {
        left_ := (left_ & ChildPointerMask) | ((newFactor + 1 castTo: UIntPointer) & BalanceFactorMask)
    }.

    // Binary tree search
    message search: (searchKey: KeyType) ::=> SelfType pointer := {
        let position mutable := self address.
        while: position isNotNil do: {
            searchKey < position _ key ifTrue: {
                position := position _ left.
            } ifFalse: {
                position _ key < searchKey ifTrue: {
                    position := position _ right.
                } ifFalse: {
                    return: position
                }
            }
        }.

        return: nil
    }.

    /**
     * This finds the first element that is at least as big as the key.
     */
    message lowerBound: (searchKey: KeyType) ::=> SelfType pointer := {
        let position mutable := self address.
        let bestFound mutable type: SelfType pointer := nil.

        while: position isNotNil do: {
            searchKey < position _ key ifTrue: {
                bestFound := position.
                position := position _ left.
            } ifFalse: {
                // position <= searchKey
                position _ key < searchKey ifTrue: {
                    position := position _ right.
                } ifFalse: {
                    // Same key
                    bestFound := position.
                    position := position _ left
                }
            }
        }.

        return: bestFound
    }.

    /**
     * This finds the first element that is at greater than the search key.
     */
    message upperBound: (searchKey: KeyType) ::=> SelfType pointer := {
        let position mutable := self address.
        let bestFound mutable type: SelfType pointer := nil.

        while: position isNotNil do: {
            searchKey < position _ key ifTrue: {
                bestFound := position.
                position := position _ right.
            } ifFalse: {
                position _ key < searchKey ifTrue: {
                    position := position _ left
                } ifFalse: {
                    // Same key
                    position := position _ right.
                }
            }
        }.

        return: bestFound
    }.

    message isLeaf => BooleanBit
        := self left isNil && self right isNil.

    // Insert node.
    message insertOrReplace: (newNode: SelfType pointer) ::=> SelfType pointer := {
        // If self is nil, just return the node.
        self address ifNil: {
            return: newNode
        }.

        // Left child.
        newNode _ key < key ifTrue: {
            self left: (self left _ insertOrReplace: newNode)
        } ifFalse: {
            key < newNode _ key ifTrue: {
                // Right child
                self right: (self right _ insertOrReplace: newNode)
            } ifFalse: {
                // This is the node, replace the value.
                self replaceValueWith: newNode.
                return: self address.
            }
        }.

        // TODO. Rebalance the tree.

        self address
    }.

    message insertNode: (newNode: SelfType pointer) ::=> SelfType pointer := {
        // If self is nil, just return the node.
        self address ifNil: {
            return: newNode
        }.

        // Left child.
        newNode _ key < key ifTrue: {
            self left: (self left _ insertNode: newNode)
        } ifFalse: {
            key < newNode _ key ifTrue: {
                // Right child
                self right: (self right _ insertNode: newNode)
            } ifFalse: {
                // Prefer inserting on the right side.
                self right: (self right _ insertNode: newNode)
            }
        }.

        // TODO. Rebalance the tree.

        self address
    }.

    // Remove unique node.
    message removeUniqueNode: (oldNode: SelfType pointer) ::=> SelfType pointer := {
        self address ifNil: {
            return: nil
        }.

        // Left node.
        oldNode _ key < key ifTrue: {
            self left: (self left _ removeUniqueNode: oldNode)
        } ifFalse: {
            key < oldNode _ key ifTrue: {
                // Right child
                self right: (self right _ removeUniqueNode: oldNode)
            } ifFalse: {
                // Do I have one leaf? or none?
                self right isNil ifTrue: {
                    return: self left
                }.
                self left isNil ifTrue: {
                    return: self right
                }.

                // The two leaves are valid, remove the immediate successor.
                let successor := self right _ removeLowerLeftNode.
                successor _ left: self left.
                // TODO: Rebalance the successor
                return: successor
            }
        }.

        // TODO: Rebalance the tree.
        self address
    }.

    // Remove node with duplicated key.
    message removeNode: (oldNode: SelfType pointer) ::=> SelfType pointer := {
        self address ifNil: {
            return: nil
        }.

        // Is this the target node?
        self address == oldNode ifTrue: {
            // Do I have one leaf? or none?
            self right isNil ifTrue: {
                return: self left
            }.
            self left isNil ifTrue: {
                return: self right
            }.

            // The two leaves are valid, remove the immediate successor.
            let successor := self right _ removeLowerLeftNode.
            successor _ left: self left.

            // TODO: Rebalance the successor
            return: successor
        }.

        // Left node.
        oldNode _ key < key ifTrue: {
            self left: (self left _ removeNode: oldNode)
        } ifFalse: {
            key < oldNode _ key ifTrue: {
                // Right child
                self right: (self right _ removeNode: oldNode)
            } ifFalse: {
                // Same key. Check the two children.
                self left: (self left _ removeNode: oldNode).
                self right: (self right _ removeNode: oldNode).
            }
        }.

        // TODO: Rebalance the tree.
        self address
    }.

    /**
     * This removes the lower left node of the tree, and returns the old lower left node.
     */
    message removeLowerLeftNode ::=> SelfType pointer := {
        self isLeaf ifTrue: {
            self address.
        } ifFalse: {
            self left _ isLeaf ifTrue: {
                let lowerLeft := self left.
                self left: nil.
                lowerLeft
            } ifFalse: {
                self left _ removeLowerLeftNode
            }
        }
    }.
}.

}. // End of namespace ExplicitMemoryCollections
}. // End of namespace StdNative
