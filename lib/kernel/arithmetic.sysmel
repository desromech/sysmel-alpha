// Arithmetic coercions
PrimitiveSignedIntegerType meta message
    generateArithmeticMessage: (messageNode: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType)
        left: (left: _CompilerObjectType) right: (right: _CompilerObjectType)
        at: (aPosition: _CompilerObjectType)  ::-> _CompilerObjectType := {
    return: (self generatePrimitiveSignedIntegerArithmeticMessage: messageNode withBuilder: builder left: left right: right at: messageNode)
}.

PrimitiveUnsignedIntegerType meta message
    generateArithmeticMessage: (messageNode: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType)
        left: (left: _CompilerObjectType) right: (right: _CompilerObjectType)
        at: (aPosition: _CompilerObjectType)  ::-> _CompilerObjectType := {
    return: (self generatePrimitiveUnsignedIntegerArithmeticMessage: messageNode withBuilder: builder left: left right: right at: messageNode)
}.

PrimitiveFloatingPointType meta message
    generateArithmeticMessage: (messageNode: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType)
        left: (left: _CompilerObjectType) right: (right: _CompilerObjectType)
        at: (aPosition: _CompilerObjectType)  ::-> _CompilerObjectType := {
    return: (self generatePrimitiveFloatingPointArithmeticMessage: messageNode withBuilder: builder left: left right: right at: messageNode)
}.

_LiteralInteger arithmeticCoercionWith: PrimitiveIntegerType do: $$Pharo {
coerce: left with: right
    right instanceSize >= 4 ifTrue: [
        ^ right
    ] ifFalse: [
        self halt
    ]
}.

// Unsigned arithmetic coercion rules.
UInt8 arithmeticCoercionWith: UInt16 into: Int32.
UInt8 | UInt16 arithmeticCoercionWith: UInt32 into: UInt32.
UInt8 | UInt16 | UInt32 arithmeticCoercionWith: UInt64 into: UInt64.

// Signed arithmetic coercion rules.
Int8 arithmeticCoercionWith: Int16 into: Int32.
Int8 | Int16 arithmeticCoercionWith: Int32 into: Int32.
Int8 | Int16 | Int32 arithmeticCoercionWith: Int64 into: Int64.

// Floating point arithmetic coercion
Int8 | Int16 | Int32 arithmeticCoercionWith: Float32 into: Float32.
UInt8 | UInt16 | UInt32 arithmeticCoercionWith: Float32 into: Float32.

Int8 | Int16 | Int32 | Int64 arithmeticCoercionWith: Float64 into: Float64.
UInt8 | UInt16 | UInt32 | UInt64  arithmeticCoercionWith: Float64 into: Float64.

Float32 arithmeticCoercionWith: Float64 into: Float64.

// Pointer

// Binary operators
NumericalType macro selectors: #(+ - * / % < > <= >= = ~= == ~~) doOn: {
evaluation: $$Pharo {
    node: node environment: environment
        | left right coercionType valueType selector |
        coercionType := node coercionType.
        valueType := node valueType.
        left := node coercionRule first convertValue: (node receiver evaluateInEnvironment: environment) into: coercionType at: node.
        right := node coercionRule second convertValue: (node arguments first evaluateInEnvironment: environment) into: coercionType at: node.
        selector := node selector.
        (selector == #/ and: [ valueType isIntegerType]) ifTrue: [
            selector := #//
        ].

        ^ (left value perform: selector with: right value) sysmelValueWithType: valueType inEnvironment: environment
}.

semanticAnalysis: $$Pharo {
    node: node environment: environment position: aSourcePosition
        | left right leftType rightType coercionType resultType coercionRules |
        left := node receiver semanticAnalysisInEnvironment: environment.
        right := node arguments first semanticAnalysisInEnvironment: environment.
        leftType := left evaluateTypeInEnvironment: environment.
        rightType := right evaluateTypeInEnvironment: environment.

        coercionType := leftType cleanValueTypeKeepLiteral arithmeticCoerceWith: rightType cleanValueTypeKeepLiteral at: aSourcePosition.
        coercionType ifNil: [
            self error: 'Failed to find coercion type for operands of type {1} and {2}.' format: {leftType printString . rightType printString} at: aSourcePosition
        ].

        resultType := (#(< > <= >= = ~= == ~~) includes: node selector)
            ifTrue: [ self compilationTarget booleanType ]
            ifFalse: [ coercionType ].

        coercionType isLiteralType ifTrue: [
            ^ node buildLiteralWithValue: ((left value value perform: node selector with: right value value) sysmelValueWithType: resultType inEnvironment: environment)
        ].


        coercionRules := {
            leftType node: left coercedImplicitlyInto: coercionType at: node.
            rightType node: right coercedImplicitlyInto: coercionType at: node.
        }.

        ^ node copy
            metaMethod: self;
            receiver: left;
            arguments: {right};
            coercionType: coercionType;
            coercionRule: coercionRules;
            valueType: resultType;
            yourself

}.

// Code generation
codeGeneration: $$Pharo {
    node: messageNode builder: builder
        | coercionType leftNode leftValue rightNode rightValue |
        "Convert the arguments"
        coercionType := messageNode coercionType.
        leftNode := messageNode receiver.
        leftValue := messageNode coercionRule first convertSSAValue: (leftNode generateSSACodeWith: builder) to: coercionType with: builder at: messageNode.

        rightNode := messageNode arguments first.
        rightValue := messageNode coercionRule second convertSSAValue: (rightNode generateSSACodeWith: builder) to: coercionType with: builder at: messageNode.

        ^ (coercionType __sysmel generateArithmeticMessage: messageNode selector withBuilder: builder left: leftValue right: rightValue at: messageNode)
            unwrapSysmelValue
}.

}.

// Logical negation
BooleanType macro selector: #not doOn: {
    // Compile time evaluation
    evaluation: $$Pharo {
        node: node environment: environment
            | operand coercionType |
            coercionType := node coercionType.
            operand := node coercionRule convertValue: (node receiver evaluateInEnvironment: environment) into: coercionType at: node.
            ^ (operand value perform: node selector) sysmelValueWithType: coercionType inEnvironment: environment
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
	        | operand operandType coercionType resultType coercionRule |
	        operand := node receiver semanticAnalysisInEnvironment: environment.
            operandType := operand evaluateCleanValueTypeInEnvironment: environment.

            coercionType := operandType.
            coercionType isLiteralType ifTrue: [
                ^ node buildLiteralWithValue: ((operand value value perform: node selector) sysmelValueWithType: coercionType inEnvironment: environment)
            ].

            coercionRule := (operand evaluateTypeInEnvironment: environment) node: operand coercedImplicitlyInto: coercionType at: node.
			resultType := coercionType.

            ^ node copy
                metaMethod: self;
                receiver: operand;
                arguments: #();
                coercionType: coercionType;
                coercionRule: coercionRule;
                valueType: resultType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
			| coercionType operandNode operandValue |
			"Convert the arguments"
			coercionType := messageNode coercionType.
			operandNode := messageNode receiver.
			operandValue := messageNode coercionRule convertSSAValue: (operandNode generateSSACodeWith: builder) to: coercionType with: builder at: messageNode.
            ^ builder lnot: operandValue
    }.
}.
