namespace SysmelKernel definition: {

## Add a testing method into type about primitive vector types.
Type extend: {
    message isPrimitiveVectorType => BooleanBit := {
        return: false
    }.
}.

## Common trait for primitive vectors
trait PrimitiveVectorType
    uses: PrimitiveType;
definition: {
    meta message isPrimitiveVectorType => BooleanBit := {
        return: true
    }.
}.

## Primitive vector template.
template PrimitiveVectorTypeTemplate(E: Type, N: _LiteralInteger)
    := type uses: PrimitiveVectorType;
definition: {
    compileTimeConstant ElementType := E.
    compileTimeConstant ElementCount := N.
    compileTimeConstant AlignmentMultiplier := (if: N == 3 then: 4 else: N).

    meta message elementType => _CompilerObjectType := {
        return: ElementType
    }.

    meta message elements => _LiteralInteger := {
        return: ElementCount
    }.

    meta message instanceAlignment => Int32 := {
        return: ElementType instanceAlignment * AlignmentMultiplier
    }.

    meta message instanceSize => Int32 := {
        return: ElementType instanceSize * ElementCount
    }.

    meta message buildSSAType => _CompilerObjectType := {
        return: (Compiler compilationTarget ssaVector: ElementType ssaType elements: ElementCount)
    }.

    meta message createSysmelMangledValue => _CompilerObjectType := {
        return: (ElementType sysmelMangledValue -- #v -- ElementCount asString)
    }.

    meta message createPrintingName => _CompilerObjectType := {
        return: (ElementType printingName -- "x" -- ElementCount printString)
    }.

    ## Macros for implementing element - element operations.
    if: N = 2 then: {
        macro expansionRule _binaryOperation: (selector: _LiteralSymbol) with: other := ``(
            SelfType (
                `,self x __macroSend: selector with: `,other x,
                `,self y __macroSend: selector with: `,other y
            )
        ).
    }.

    if: N = 3 then: {
        macro expansionRule _binaryOperation: (selector: _LiteralSymbol) with: other := ``(
            SelfType (
                `,self x __macroSend: selector with: `,other x,
                `,self y __macroSend: selector with: `,other y,
                `,self z __macroSend: selector with: `,other z
            )
        ).
    }.

    if: N = 4 then: {
        macro expansionRule _binaryOperation: (selector: _LiteralSymbol) with: other := ``(
            SelfType (
                `,self x __macroSend: selector with: `,other x,
                `,self y __macroSend: selector with: `,other y,
                `,self z __macroSend: selector with: `,other z,
                `,self w __macroSend: selector with: `,other w,
            )
        ).
    }.

    if: ElementType isNumericalType then: {
        ## Vector arithmetic
        message + (other: SelfType) => SelfType := {
            <intrinsic: #"vector.add">
            return: (self _binaryOperation: #+ with: other)
        }.

        message - (other: SelfType) => SelfType := {
            <intrinsic: #"vector.sub">
            return: (self _binaryOperation: #- with: other)
        }.

        message * (other: SelfType) => SelfType := {
            <intrinsic: #"vector.mul">
            return: (self _binaryOperation: #* with: other)
        }.

        message / (other: SelfType) => SelfType := {
            <intrinsic: #"vector.div">
            return: (self _binaryOperation: #/ with: other)
        }.

        message % (other: SelfType) => SelfType := {
            <intrinsic: #"vector.rem">
            return: (self _binaryOperation: #% with: other)
        }.

        ## Dot product
        message dot: (other: SelfType) ::=> ElementType := {
            <intrinsic: #"vector.dot">
        }.

        ## Length2
        message length2 ::=> ElementType := {
            return: (self dot: self)
        }.

        ## Length
        if: ElementType isFloatingPointType then: {
            message length ::=> ElementType := {
                <intrinsic: #"vector.length">
            }.
        }.

        ## Cross product
        if: ElementCount = 2 then: {
            message cross: (other: SelfType) ::=> ElementType := {
                return: (self x * other y - other x * self y)
            }.
        }.

        if: ElementCount = 3 then: {
            message cross: (other: SelfType) ::=> SelfType := {
                <intrinsic: #"vector.cross">
            }.
        }.
    }

}.

PrimitiveType extend: {
    meta message vector: (elementCount: _LiteralInteger) ::=> _CompilerObjectType := {
        return: PrimitiveVectorTypeTemplate(self, elementCount)
    }.
}.

## Float32 based vectors.
compileTimeConstant Float32x2 := Float32 vector: 2.
compileTimeConstant Float32x3 := Float32 vector: 3.
compileTimeConstant Float32x4 := Float32 vector: 4.

## Float64 based vectors.
compileTimeConstant Float64x2 := Float64 vector: 2.
compileTimeConstant Float64x3 := Float64 vector: 3.
compileTimeConstant Float64x4 := Float64 vector: 4.

}
