namespace SysmelKernel definition: {

// Add a testing method into type about primitive vector types.
Type extend: {
    message isPrimitiveVectorType => BooleanBit := {
        return: false
    }.
}.

// Common trait for primitive vectors
trait PrimitiveVectorType
    uses: PrimitiveType;
definition: {
    meta message isPrimitiveVectorType => BooleanBit := {
        return: true
    }.
}.

// Primitive vector template.
template PrimitiveVectorTypeTemplate(E: Type, N: _LiteralInteger)
    := type uses: PrimitiveVectorType;
definition: {
    alias ElementType := E.
    alias ElementCount := N.
    alias AlignmentMultiplier := (if: N == 3 then: 4 else: N).

    meta message elementType => _CompilerObjectType := {
        return: ElementType
    }.

    meta message elements => _LiteralInteger := {
        return: ElementCount
    }.

    meta message instanceAlignment => Int32 := {
        return: ElementType instanceAlignment * AlignmentMultiplier
    }.

    meta message instanceSize => Int32 := {
        return: ElementType instanceSize * ElementCount
    }.

    meta message buildSSAType => _CompilerObjectType := {
        return: (Compiler compilationTarget ssaVector: ElementType ssaType elements: ElementCount)
    }.

    meta message createSysmelMangledValue => _CompilerObjectType := {
        return: (ElementType sysmelMangledValue -- #v -- ElementCount asString)
    }.

    meta message createPrintingName => _CompilerObjectType := {
        return: (ElementType printingName -- "x" -- ElementCount printString)
    }.

    meta macro selector: #applyWithArguments: doOn: {
        evaluation: $$Pharo {
            node: node environment: environment
            "Evaluate V4"
            self halt
        }.

        metaMessageAnalysis: $$Pharo {
            node: node type: type environment: environment position: aSourcePosition
                | arguments elements vectorElements argumentsArity argumentType expectedElementType expectedArgumentType coercionTypes coercionRules arity |
                arguments := node arguments first elements.

                "Analyze the arguments"
                arguments := arguments collect: [:arg | arg semanticAnalysisInEnvironment: environment ].

                "Compute the arguments arity."
                argumentsArity := 0.
                expectedElementType := type cachedNullary: #elementType.

                coercionTypes := arguments collect: [:arg |
                    argumentType := arg evaluateCleanTypeInEnvironment: environment.
                    argumentType isReferenceType ifTrue: [argumentType := argumentType referenced].

                    "Is the argument a scalar?"
                    (argumentType cachedNullary: #isPrimitiveOrPrimitiveLiteralType) ifTrue: [
                        argumentsArity := argumentsArity + 1.
                        expectedArgumentType := expectedElementType.
                    ] ifFalse: [
                        "Is the argument a vector?"
                        (argumentType cachedNullary: #isPrimitiveVectorType) ifTrue: [
                            arity := argumentType cachedNullary: #elements.
                            argumentsArity := argumentsArity + arity.
                            expectedArgumentType := expectedElementType cachedUnary: #vector: arg: arity.
                        ] ifFalse: [
                            self error: 'Invalid argument type {1} for construction vector of type {2}.'
                                format: {argumentType printString . type printString } at: arg.
                        ]
                    ].

                    expectedArgumentType
                ].

                "Check the arguments arity."
                vectorElements := type cachedNullary: #elements.
                argumentsArity > vectorElements ifTrue: [
                    self error: 'Cannot construct vector that requires {1} elements with {2} elements.'
                        format: {vectorElements printString . argumentsArity printString } at: aSourcePosition
                ].

                "Compute the coercion rules."
                coercionRules := arguments collectWithIndex: [:arg :index |
                    argumentType := arg evaluateTypeInEnvironment: environment.
                    expectedArgumentType := coercionTypes at: index.
                    argumentType node: node coercedImplicitlyInto: expectedArgumentType at: node.
                ].

                ^ node shallowCopy
                    arguments: arguments;
                    metaMethod: self;
                    coercionType: coercionTypes;
                    coercionRule: coercionRules;
                    valueType: type;
                    yourself
        }.

        codeGeneration: $$Pharo {
            node: messageNode builder: builder
                | coercionTypes coercionRules arguments resultType resultElementType argumentsArity argumentType extraValues |
                coercionTypes := messageNode coercionType.
                coercionRules := messageNode coercionRule.

                arguments := messageNode arguments collectWithIndex: [:arg :index |
                    (coercionRules at: index) convertSSAValue: (arg generateSSACodeWith: builder) to: (coercionTypes at: index) with: builder at: messageNode.
                ].

                "Get the result type"
                resultType := messageNode valueType ssaType.
                resultElementType := resultType baseType.

                "Compute the arity of the arguments"
                argumentsArity := 0.
                arguments do: [:arg |
                    argumentType := arg type.
                    argumentsArity := argumentsArity + (argumentType isVectorType ifTrue: [ argumentType elements ] ifFalse: [1])
                ].

                self assert: argumentsArity <= resultType elements.
                extraValues := (1 to: resultType elements - argumentsArity) collect: [:i | resultElementType defaultConstant ].

                "Build the vector"
                ^ builder makeVector: resultType arguments: arguments , extraValues
        }.
    }.

    // Implicit conversion from scalar into vector.
    ElementType conversionTo: SelfType doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                "Construct vector"
                self halt
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                "Construct vector"
                | vectorElements |
                vectorElements := targetType cachedNullary: #elements.
                ^ builder
                    makeVector: targetType ssaType
                    arguments: ((1 to: vectorElements) collect: [:i | sourceValue])
        }.
    }.

    meta macro expansionRule x: x := ``(
        self __macroExpand (x __macroExpand)
    ).

    // Accessors
    (SelfType addIntrinsicField: #x slotIndex: 0)
        type: ElementType;
        public;
        createAccessors.

    // Common methods for at least two elements.
    if: N >= 2 then: {
        (SelfType addIntrinsicField: #y slotIndex: 1)
            type: ElementType;
            public;
            createAccessors.

        meta macro expansionRule x: x y: y := ``(
            self __macroExpand (x __macroExpand, y __macroExpand)
        ).

        meta macro expansionRule y: y := ``(
            self __macroExpand (0.0, y __macroExpand)
        ).
    }.

    // Common methods for at least three elements.
    if: N >= 3 then: {
        (SelfType addIntrinsicField: #z slotIndex: 2)
            type: ElementType;
            public;
            createAccessors.

        meta macro expansionRule x: x y: y z: z := ``(
            self __macroExpand (x __macroExpand, y __macroExpand, z __macroExpand)
        ).

        meta macro expansionRule z: z := ``(
            self __macroExpand (0.0, 0.0, z __macroExpand)
        ).

    }.

    // Common methods for at least four elements.
    if: N >= 4 then: {
        (SelfType addIntrinsicField: #w slotIndex: 3)
            type: ElementType;
            public;
            createAccessors.

        meta macro expansionRule x: x y: y z: z w: w := ``(
            self __macroExpand (x __macroExpand, y __macroExpand, z __macroExpand, w __macroExpand)
        ).

        meta macro expansionRule w: w := ``(
        	self __macroExpand (0.0, 0.0, 0.0, w __macroExpand)
        ).
    }.

    // Macros for implementing element - element operations.
    if: N = 2 then: {
        macro expansionRule _binaryOperation: (selector: _LiteralSymbol) with: other := ``(
            SelfType (
                self __macroExpand x __macroSend: selector with: other __macroExpand x,
                self __macroExpand y __macroSend: selector with: other __macroExpand y
            )
        ).
    }.

    if: N = 3 then: {
        macro expansionRule _binaryOperation: (selector: _LiteralSymbol) with: other := ``(
            SelfType (
                self __macroExpand x __macroSend: selector with: other __macroExpand x,
                self __macroExpand y __macroSend: selector with: other __macroExpand y,
                self __macroExpand z __macroSend: selector with: other __macroExpand z
            )
        ).
    }.

    if: N = 4 then: {
        macro expansionRule _binaryOperation: (selector: _LiteralSymbol) with: other := ``(
            SelfType (
                self __macroExpand x __macroSend: selector with: other __macroExpand x,
                self __macroExpand y __macroSend: selector with: other __macroExpand y,
                self __macroExpand z __macroSend: selector with: other __macroExpand z,
                self __macroExpand w __macroSend: selector with: other __macroExpand w,
            )
        ).
    }.

    if: ElementType isNumericalType then: {
        // Vector arithmetic
        message + (other: SelfType) => SelfType := {
            <intrinsic: #"vector.add">
            return: (self _binaryOperation: #+ with: other)
        }.

        message - (other: SelfType) => SelfType := {
            <intrinsic: #"vector.sub">
            return: (self _binaryOperation: #- with: other)
        }.

        message * (other: SelfType) => SelfType := {
            <intrinsic: #"vector.mul">
            return: (self _binaryOperation: #* with: other)
        }.

        message / (other: SelfType) => SelfType := {
            <intrinsic: #"vector.div">
            return: (self _binaryOperation: #/ with: other)
        }.

        message % (other: SelfType) => SelfType := {
            <intrinsic: #"vector.rem">
            return: (self _binaryOperation: #% with: other)
        }.

        // Dot product
        message dot: (other: SelfType) ::=> ElementType := {
            <intrinsic: #"vector.dot">
        }.

        // Length2
        message length2 ::=> ElementType := {
            return: (self dot: self)
        }.

        // Length
        if: ElementType isFloatingPointType then: {
            message length ::=> ElementType := {
                <intrinsic: #"vector.length">
            }.
        }.

        // Cross product
        if: ElementCount = 2 then: {
            message cross: (other: SelfType) ::=> ElementType := {
                return: (self x * other y - other x * self y)
            }.
        }.

        if: ElementCount = 3 then: {
            message cross: (other: SelfType) ::=> SelfType := {
                <intrinsic: #"vector.cross">
            }.
        }.
    }

}.

PrimitiveType extend: {
    meta message vector: (elementCount: _LiteralInteger) ::=> _CompilerObjectType := {
        return: PrimitiveVectorTypeTemplate(self, elementCount)
    }.
}.

// Float32 based vectors.
alias Float32x2 := Float32 vector: 2.
alias Float32x3 := Float32 vector: 3.
alias Float32x4 := Float32 vector: 4.

// Float64 based vectors.
alias Float64x2 := Float64 vector: 2.
alias Float64x3 := Float64 vector: 3.
alias Float64x4 := Float64 vector: 4.

}
