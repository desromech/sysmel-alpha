// Arithmetic coercions
PrimitiveSignedIntegerType meta message
    generateArithmeticMessage: (messageNode: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType)
        left: (left: _CompilerObjectType) right: (right: _CompilerObjectType)
        at: (aPosition: _CompilerObjectType)  ::=> _CompilerObjectType := {
    return: (self generatePrimitiveSignedIntegerArithmeticMessage: messageNode withBuilder: builder left: left right: right at: messageNode)
}.

PrimitiveUnsignedIntegerType meta message
    generateArithmeticMessage: (messageNode: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType)
        left: (left: _CompilerObjectType) right: (right: _CompilerObjectType)
        at: (aPosition: _CompilerObjectType)  ::=> _CompilerObjectType := {
    return: (self generatePrimitiveUnsignedIntegerArithmeticMessage: messageNode withBuilder: builder left: left right: right at: messageNode)
}.

PrimitiveFloatingPointType meta message
    generateArithmeticMessage: (messageNode: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType)
        left: (left: _CompilerObjectType) right: (right: _CompilerObjectType)
        at: (aPosition: _CompilerObjectType)  ::=> _CompilerObjectType := {
    return: (self generatePrimitiveFloatingPointArithmeticMessage: messageNode withBuilder: builder left: left right: right at: messageNode)
}.

_LiteralInteger arithmeticCoercionWith: PrimitiveIntegerType do: $$Pharo {
coerce: left node: literalNode with: right node: valueNode
    | literalValue |
    literalValue := literalNode value value.

    "For zero, always prefer the right type."
    literalValue = 0 ifTrue: [
        ^ right
    ].

    "If the literal is positive, try to keep the signed-ness of the type"
    literalValue > 0 ifTrue: [
        right instanceSize >= 4 ifTrue: [
            ^ right
        ] ifFalse: [
            ^ right isUnsigned
                ifTrue: [ self compilationTarget uint32Type ]
                ifFalse: [ self compilationTarget int32Type]
        ]
    ].

    "If the literal is negative, into a signed type."
    literalValue < 0 ifTrue: [
        right instanceSize >= 4 ifTrue: [
            right isSigned ifTrue: [ ^ right ].
            ^ right instanceSize = 4
                ifTrue: [self compilationTarget int32Type]
                ifFalse: [self compilationTarget int64Type]
        ] ifFalse: [
            ^ self compilationTarget int32Type
        ]
    ].
}.

// Literal arithmetic coercion rules.
_LiteralInteger arithmeticCoercionWith: _LiteralFraction into: _LiteralFraction.
_LiteralFraction arithmeticCoercionWith: _LiteralFloat into: _LiteralFloat.
_LiteralInteger arithmeticCoercionWith: _LiteralFloat into: _LiteralFloat.

// Unsigned arithmetic coercion rules.
UInt8 arithmeticCoercionWith: UInt16 into: Int32.
UInt8 | UInt16 arithmeticCoercionWith: UInt32 into: UInt32.
UInt8 | UInt16 | UInt32 arithmeticCoercionWith: UInt64 into: UInt64.

// Signed arithmetic coercion rules.
Int8 | UInt8 arithmeticCoercionWith: Int16 into: Int32.
Int8 | UInt8 | Int16 | UInt16 arithmeticCoercionWith: Int32 into: Int32.
Int8 | UInt8 | Int16 | UInt16 | Int32 | UInt32 arithmeticCoercionWith: Int64 into: Int64.

// Floating point arithmetic coercion
Int8 | Int16 | Int32 arithmeticCoercionWith: Float32 into: Float32.
UInt8 | UInt16 | UInt32 arithmeticCoercionWith: Float32 into: Float32.

Int8 | Int16 | Int32 | Int64 arithmeticCoercionWith: Float64 into: Float64.
UInt8 | UInt16 | UInt32 | UInt64  arithmeticCoercionWith: Float64 into: Float64.

Float32 arithmeticCoercionWith: Float64 into: Float64.

// Pointer

// Binary operators
// TODO: Only allow the bitwise operations with integer types.
NumericalType macro selectors: #(
    + - * / %
    < > <= >= = ~= == ~~
    | & << >>
) doOn: {
evaluation: $$Pharo {
    node: node environment: environment
        | left right coercionType valueType selector |
        coercionType := node coercionType.
        valueType := node valueType.
        left := node coercionRule first convertValue: (node receiver evaluateInEnvironment: environment) into: coercionType at: node.
        right := node coercionRule second convertValue: (node arguments first evaluateInEnvironment: environment) into: coercionType at: node.
        selector := node selector.
        (selector == #/ and: [ valueType isIntegerType]) ifTrue: [
            selector := #//
        ].

        ^ (left value perform: selector with: right value) sysmelValueWithType: valueType inEnvironment: environment
}.

semanticAnalysis: $$Pharo {
    node: node environment: environment position: aSourcePosition
        | left right leftType rightType coercionType resultType coercionRules foldSelector |
        left := node receiver semanticAnalysisInEnvironment: environment.
        right := node arguments first semanticAnalysisInEnvironment: environment.
        leftType := left evaluateTypeInEnvironment: environment.
        rightType := right evaluateTypeInEnvironment: environment.

        coercionType := leftType cleanValueTypeKeepLiteral arithmeticCoerceNode: left withType: rightType cleanValueTypeKeepLiteral node: right at: aSourcePosition.
        coercionType ifNil: [
            self error: 'Failed to find coercion type for operands of type {1} and {2}.' format: {leftType printString . rightType printString} at: aSourcePosition
        ].

        resultType := (#(< > <= >= = ~= == ~~) includes: node selector)
            ifTrue: [ self compilationTarget booleanType ]
            ifFalse: [ coercionType ].

        coercionType isLiteralType ifTrue: [
            foldSelector := node selector.
            (foldSelector == #/ and: [ coercionType isIntegerType]) ifTrue: [
                foldSelector := #//
            ].

            ^ node buildLiteralWithValue: ((left value value perform: foldSelector with: right value value) sysmelValueWithType: resultType inEnvironment: environment)
        ].


        coercionRules := {
            leftType node: left coercedImplicitlyInto: coercionType at: node.
            rightType node: right coercedImplicitlyInto: coercionType at: node.
        }.

        ^ node copy
            metaMethod: self;
            receiver: left;
            arguments: {right};
            coercionType: coercionType;
            coercionRule: coercionRules;
            valueType: resultType;
            yourself

}.

// Code generation
codeGeneration: $$Pharo {
    node: messageNode builder: builder
        | coercionType leftNode leftValue rightNode rightValue |
        "Convert the arguments"
        coercionType := messageNode coercionType.
        leftNode := messageNode receiver.
        leftValue := messageNode coercionRule first convertSSAValue: (leftNode generateSSACodeWith: builder) to: coercionType with: builder at: messageNode.

        rightNode := messageNode arguments first.
        rightValue := messageNode coercionRule second convertSSAValue: (rightNode generateSSACodeWith: builder) to: coercionType with: builder at: messageNode.

        ^ (coercionType __sysmel generateArithmeticMessage: messageNode selector withBuilder: builder left: leftValue right: rightValue at: messageNode)
            unwrapSysmelValue
}.

}.

NumericalType macro selectors: #(#"prefix-+" negated #"prefix--" bitInvert #"prefix-~" highBit lowBit) doOn: {
    // Compile time evaluation
    evaluation: $$Pharo {
        node: node environment: environment
            | operand coercionType |
            coercionType := node coercionType.
            operand := node coercionRule convertValue: (node receiver evaluateInEnvironment: environment) into: coercionType at: node.

            "Perform with the actual selector."
            ^ (operand value perform: node selector) sysmelValueWithType: coercionType inEnvironment: environment
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
	        | operand operandType coercionType resultType coercionRule actualSelector |
	        operand := node receiver semanticAnalysisInEnvironment: environment.
            operandType := operand evaluateTypeInEnvironment: environment.

            "Rewrite the prefix selectors"
            actualSelector := node selector.
            actualSelector = #'prefix-+' ifTrue: [actualSelector := #yourself].
            actualSelector = #'prefix--' ifTrue: [actualSelector := #negated].
            actualSelector = #'prefix-~' ifTrue: [actualSelector := #bitInvert].

            "Nop operation."
            actualSelector == #yourself ifTrue: [^ operand].

            coercionType := operandType cleanValueTypeKeepLiteral.
            coercionType isLiteralType ifTrue: [
                ^ node buildLiteralWithValue: ((operand value value perform: actualSelector) sysmelValueWithType: coercionType inEnvironment: environment)
            ].

            coercionRule := (operand evaluateTypeInEnvironment: environment) node: operand coercedImplicitlyInto: coercionType at: node.
			resultType := coercionType.

            ^ node copy
                metaMethod: self;
                selector: actualSelector;
                receiver: operand;
                arguments: #();
                coercionType: coercionType;
                coercionRule: coercionRule;
                valueType: resultType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
			| coercionType operandNode operandValue |
			"Convert the arguments"
			coercionType := messageNode coercionType.
			operandNode := messageNode receiver.
			operandValue := messageNode coercionRule convertSSAValue: (operandNode generateSSACodeWith: builder) to: coercionType with: builder at: messageNode.

            messageNode selector == #negated ifTrue: [
                ^ coercionType isFloatingPointType ifTrue: [
                    builder fneg: operandValue
                ] ifFalse: [
                    builder neg: operandValue
                ]
            ].
            messageNode selector == #bitInvert ifTrue: [
                ^ builder not: operandValue
            ].

            messageNode selector == #highBit ifTrue: [
                ^ builder highBit: operandValue
            ].

            messageNode selector == #lowBit ifTrue: [
                ^ builder lowBit: operandValue
            ].

            self error: 'Unsupported unary operation'.
    }.
}.
