namespace SysmelKernel definition: {

// A generic type
trait AnyValue
definition: {
    // Add the yourself macro to rewrite to the receiver by default.
    macro selector: #yourself doOn: {
        semanticAnalysis: $$Pharo {
            semanticAnalyzeMessage: message inEnvironment: environment at: aPosition
                ^ message receiver semanticAnalysisInEnvironment: environment
        }.
    }.
}.

// The type meta type
trait Type definition: {
    message asConcreteTypeForFunctionAnalysis => SelfType := self.
    message asReceiverType => SelfType := self.
    message asVariableValueType => SelfType := self.
    message asGCClassFieldType => SelfType := self.

    message isType => BooleanBit := true.
    message isCompilerObjectType => BooleanBit := false.
    message isDynamicObjectType => BooleanBit := false.

    message isAnyDynamicObjectType => BooleanBit := false.
    message isArrayType => BooleanBit := false.
    message isGCClassVariableDataArrayType => BooleanBit := false.
    message isUndeterminedArrayType => BooleanBit := false.
    message isUndefinedType => BooleanBit := false.
    message isLiteralType => BooleanBit := false.
    message isPrimitiveType => BooleanBit := false.
    message isPrimitiveLiteralType => BooleanBit := false.
    message isPrimitiveOrPrimitiveLiteralType => BooleanBit := false.
    message isOpaqueType => BooleanBit := false.
    message isBooleanType => BooleanBit := false.
    message isNumericalType => BooleanBit := false.
    message isIntegerType => BooleanBit := false.
    message isFractionalType => BooleanBit := false.
    message isFloatingPointType => BooleanBit := false.
    message isPointerType => BooleanBit := false.
    message isReferenceType => BooleanBit := false.
    message isPointerOrReferenceType => BooleanBit := false.
    message isTupleType => BooleanBit := false.
    message isFunctionType => BooleanBit := false.
    message isFunctionGroupType => BooleanBit := false.
    message isConstantType => BooleanBit := false.
    message isVolatileType => BooleanBit := false.
    message instanceSize => _LiteralInteger := 0.
    message instanceAlignment => _LiteralInteger := 1.
    message cleanType => SelfType := self.
    message valueType => SelfType := self.
    message valueTypeKeepLiteral => SelfType := self.

    message isPODType => BooleanBit := false.
    message hasNonTrivialInitialization => BooleanBit := false.
    message hasNonTrivialFinalization => BooleanBit := false.

    message hasNonTrivialGCInitialization => BooleanBit
        := self hasNonTrivialInitialization.
    message hasNonTrivialGCFinalization => BooleanBit
        := self hasNonTrivialFinalization.

    message defaultSSAValueWith: (builder: _CompilerObjectType) ::=> _CompilerObjectType := {
        self error: "Cannot generate default value of {1}" format: (self,self)
    }.

    message isReturnedThroughFirstArgument ::=> BooleanBit := false.

    message initializeSSAVariable: (variable: _CompilerObjectType) with: (builder: _CompilerObjectType) ::=> Void := {
        builder store: (self defaultSSAValueWith: builder) in: variable.
    }.

    message finalizeSSAVariable: (variable: _CompilerObjectType) with: (builder: _CompilerObjectType) ::=> Void
        := nil.
}.

AnyValue type uses: Type.

// Meta type
_MetaType uses: AnyValue type;
definition: {
    message buildSSAType => _CompilerObjectType := {
        Compiler compilationTarget ssaPointerTo: Compiler compilationTarget int8Type ssaType forAddressSpace: #generic
    }.

    message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := value ssaValue.
}.

// A literal type
trait LiteralType
    uses: AnyValue;
definition: {
    meta message isLiteralType => BooleanBit := true.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType := value.
}.

// Primitive literal type
trait PrimitiveLiteralType
    uses: LiteralType;
definition: {
    meta message isPrimitiveLiteralType => BooleanBit := true.
    meta message isPrimitiveOrPrimitiveLiteralType => BooleanBit := true.
}.

// A primitive type
trait PrimitiveType
    uses: AnyValue;
definition: {
    meta message isPrimitiveType => BooleanBit := true.
    meta message isPrimitiveOrPrimitiveLiteralType => BooleanBit := true.
    meta message isPODType => BooleanBit := true.

    meta message instanceAlignment => _LiteralInteger
        := self instanceSize.

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::=> _CompilerObjectType
        := module ssaConstantPrimitiveValue: value type: self.
}.

// An opaque type
trait OpaqueType
    uses: AnyValue;
definition: {
    meta message isOpaqueType => BooleanBit := true.
}.

// A numerical type
trait NumericalType uses: AnyValue;
definition: {
    meta message isNumericalType => BooleanBit := true.
}.

// An integer type
trait IntegerType uses: NumericalType;
definition: {
    meta message isIntegerType => BooleanBit := true.
    meta message isSigned => BooleanBit := false.
    meta message isUnsigned => BooleanBit := false.
}.

trait SignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned => BooleanBit := true.
    meta message isUnsigned => BooleanBit := false.
}.

trait UnsignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned => BooleanBit := false.
    meta message isUnsigned => BooleanBit := true.
}.

trait PrimitiveIntegerType uses: (PrimitiveType, IntegerType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := builder const: 0 type: self ssaType.

    meta message defaultValue => _CompilerObjectType := 0.
    meta message one => _CompilerObjectType := 1.
    meta message zero => _CompilerObjectType := 0.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := builder const: value unwrapSysmelValue type: self ssaType.
}.

trait PrimitiveUnsignedIntegerType uses: (PrimitiveIntegerType, UnsignedIntegerType).
trait PrimitiveSignedIntegerType uses: (PrimitiveIntegerType, SignedIntegerType).

// A boolean type
trait BooleanType uses: AnyValue;
definition: {
    meta message isBooleanType => BooleanBit := true.
}.

// A fraction type
trait FractionalType uses: NumericalType;
definition: {
    meta message isFractionalType => BooleanBit := true.
}.

// A floating point type
trait FloatingPointType uses: NumericalType;
definition: {
    meta message isFloatingPointType => BooleanBit := true.
}.

// Primitive floating point
trait PrimitiveFloatingPointType uses: (PrimitiveType, FloatingPointType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := builder const: 0.0 type: self ssaType.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := builder const: value unwrapSysmelValue type: self ssaType.

    meta message defaultValue => _CompilerObjectType := 0.0.
    meta message one => _CompilerObjectType := 1.0.
    meta message zero => _CompilerObjectType := 0.0.
}.

// Pointer type
trait PointerType
    uses: AnyValue;
definition: {
    meta message defaultValue => _CompilerObjectType := 0.
    meta message isPointerType => BooleanBit := true.
    meta message isPointerOrReferenceType => BooleanBit := true.
    meta message isPODType => BooleanBit := true.
    meta message cvariadicCoercionType => _CompilerObjectType := self.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := builder const: value type: self ssaType.
}.

// Reference type
trait ReferenceType
    uses: AnyValue;
definition: {
    meta message isReferenceType => BooleanBit := true.
    meta message isPointerOrReferenceType => BooleanBit := true.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := value generateSSAReferenceWith: builder.
}.

// Array type
trait ArrayType
    uses: AnyValue;
definition: {
    meta message isArrayType => BooleanBit := true.

    meta message initializeSSAVariable: (variable: _CompilerObjectType) with: (builder: _CompilerObjectType) ::=> Void := {
        Compiler initializeSSAArray: variable type: self with: builder
    }.

    meta message finalizeSSAVariable: (variable: _CompilerObjectType) with: (builder: _CompilerObjectType) ::=> Void := {
        Compiler finalizeSSAArray: variable type: self with: builder
    }.
}.

trait GCClassVariableDataArrayType
    uses: ArrayType;
definition: {
    meta message isGCClassVariableDataArrayType => BooleanBit := true.
}.

// AnyValue composition

// Pointer type
template PointerTypeTemplate(P: Type, AS: _LiteralSymbol)
    := type uses: PointerType;
definition: {
    alias PointedType := P.
    alias AddressSpaceName := AS.
    alias CleanPointedType := PointedType cleanType.

    meta message pointed => _CompilerObjectType := PointedType.
    meta message addressSpaceName => _LiteralSymbol := AddressSpaceName

    meta message instanceAlignment => _LiteralInteger
        := Compiler compilationTarget pointerAlignment
    meta message instanceSize => _LiteralInteger
        := Compiler compilationTarget pointerSize.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaPointerTo: P ssaType forAddressSpace: AddressSpaceName.

    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := builder const: 0 type: self ssaType.

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::=> _CompilerObjectType
        := module ssaConstantPointer: value type: self.

    meta message cleanType => _CompilerObjectType
        := P cleanType pointerFor: AddressSpaceName.

    meta message asPointerType =>_CompilerObjectType
        := self.

    meta message asReferenceType =>_CompilerObjectType
        := P refFor: AddressSpaceName.

    meta message createSysmelMangledValue => _CompilerObjectType
        := P sysmelMangledValue -- #p.

    meta message createPrintingName => _CompilerObjectType
        := P printingName -- " pointer".

    // Pointer comparison.
    message == (other: SelfType) => BooleanBit := {
        <compileTime>
        <staticBinding>
        <intrinsic: #"pointer.equals">
    }.

    message ~~ (other: SelfType) => BooleanBit := {
        <compileTime>
        <staticBinding>
        <intrinsic: #"pointer.notEquals">
    }.

    // Address space conversion.
    if: (#(function workgroup crossWorkgroup) includes: AddressSpaceName) then: {
        SelfType conversionTo: (P cleanType pointerFor: #generic) | (P pointerFor: #generic) doOn: {
            evaluation: $$Pharo {
                value: value targetType: targetType at: position
                    ^ value
            }.
            codeGeneration: $$Pharo {
                convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                    ^ sourceValue
            }.
        }.
    }.

    meta message lookReceiver: (receiver: _CompilerObjectType) symbol: (symbol: _CompilerObjectType) ifPresent: (ifPresentBlock: _CompilerObjectType)
        ::=> _CompilerObjectType := {
        return: (P lookReceiver: receiver symbol: symbol ifPresent: ifPresentBlock)
    }.
}.

Type extend: {
    message pointer => _CompilerObjectType
        := PointerTypeTemplate(self, #generic).

    message pointerFor: (addressSpace: _LiteralSymbol) ::=> _CompilerObjectType
        := PointerTypeTemplate(self, addressSpace).
}.

// Reference type
template ReferenceTypeTemplate(R: Type, AS: _LiteralSymbol)
    := type uses: ReferenceType;
definition: {
    alias ReferencedType := R.
    alias AddressSpaceName := AS.

    meta message referenced => _CompilerObjectType := ReferencedType.
    meta message addressSpaceName => _LiteralSymbol := AddressSpaceName.

    meta message instanceAlignment => _LiteralInteger :=
        Compiler compilationTarget pointerAlignment.

    meta message instanceSize => _LiteralInteger :=
        Compiler compilationTarget pointerSize.

    meta message buildSSAType => _CompilerObjectType :=
        Compiler compilationTarget ssaPointerTo: ReferencedType ssaType forAddressSpace: AddressSpaceName.

    meta message valueType => _CompilerObjectType := ReferencedType.
    meta message valueTypeKeepLiteral => _CompilerObjectType := ReferencedType.

    meta message cleanType => _CompilerObjectType :=
        ReferencedType cleanType refFor: AddressSpaceName.

    meta message cvariadicCoercionType => _CompilerObjectType :=
        ReferencedType cvariadicCoercionType.

    meta message lookReceiver: (receiver: _CompilerObjectType) symbol: (symbol: _CompilerObjectType) ifPresent: (ifPresentBlock: _CompilerObjectType)
        ::=> _CompilerObjectType
        := ReferencedType lookReceiver: receiver symbol: symbol ifPresent: ifPresentBlock.

    meta message asPointerType =>_CompilerObjectType :=
        ReferencedType pointerFor: AddressSpaceName.

    meta message asReferenceType => _CompilerObjectType := self.

    meta message createSysmelMangledValue => _CompilerObjectType
        := ReferencedType sysmelMangledValue -- #r.

    meta message createPrintingName => _CompilerObjectType
        := ReferencedType printingName -- " ref".

    // Reference evaluation
    let referenceEvaluationAction := `'{
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                "Reference evaluation"
                ^ value value sysmelEvaluateReference sysmelValueWithType: targetType inEnvironment: value environment
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                targetType isFunctionType ifTrue: [
                    ^ sourceValue
                ].

                ^ builder load: sourceValue
        }.
    }.

    SelfType allConversionTo: R cleanType doOn: referenceEvaluationAction.
    SelfType allConversionTo: R doOn: referenceEvaluationAction.

    // Address space conversion.
    if: (#(function workgroup crossWorkgroup) includes: AddressSpaceName) then: {
        SelfType allConversionTo: (R cleanType refFor: #generic) | (R refFor: #generic) doOn: {
            evaluation: $$Pharo {
                value: value targetType: targetType at: position
                    "Reference evaluation"
                    ^ value
            }.
            codeGeneration: $$Pharo {
                convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                    ^ sourceValue
            }.
        }.
    }.
}.

Type extend: {
    message ref => _CompilerObjectType
        := ReferenceTypeTemplate(self, #generic).

    message refFor: (addressSpaceName: _LiteralSymbol) ::=> _CompilerObjectType
        := ReferenceTypeTemplate(self, addressSpaceName).
}.

// Constant type type
template ConstantTypeTemplate(D: Type)
    := type uses: D;
definition: {
    alias DecoratedType := D.

    meta message isConstantType => BooleanBit := true.

    meta message undecoratedType => _CompilerObjectType := DecoratedType.

    meta message const => _CompilerObjectType := self.

    meta message buildSSAType => _CompilerObjectType
        := DecoratedType ssaType.

    meta message cleanType => _CompilerObjectType
        := DecoratedType cleanType.

    meta message cvariadicCoercionType => _CompilerObjectType
        := DecoratedType cvariadicCoercionType.

    meta message createSysmelMangledValue => _CompilerObjectType
        := DecoratedType sysmelMangledValue -- #c.

    meta message createPrintingName => _CompilerObjectType :=
        DecoratedType printingName -- " const".

    // Allow automatic conversion from const => non-const values.
    SelfType conversionTo: DecoratedType doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                ^ value sameValueButWithType: targetType
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                ^ sourceValue
        }.
    }.
}.

Type extend: {
    message const => _CompilerObjectType
        := ConstantTypeTemplate(self).
}.

// Volatile type type
template VolatileTypeTemplate(D: Type)
    := type uses: D;
definition: {
    alias DecoratedType := D.

    meta message isVolatileType => BooleanBit := true.
    meta message undecoratedType => _CompilerObjectType := return: DecoratedType.

    meta message const => _CompilerObjectType := DecoratedType volatile const.
    meta message volatile => _CompilerObjectType := self.

    meta message buildSSAType => _CompilerObjectType
        := DecoratedType ssaType.

    meta message cleanType => _CompilerObjectType
        := DecoratedType cleanType.

    meta message cvariadicCoercionType => _CompilerObjectType
        := DecoratedType cvariadicCoercionType.

    meta message createSysmelMangledValue => _CompilerObjectType
        := DecoratedType sysmelMangledValue -- #v.

    meta message createPrintingName => _CompilerObjectType
        := DecoratedType printingName -- " volatile".

    // Perform a bidirectional identity conversion for volatile types.
    let decorationIdentityAction := `'{
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                ^ value sameValueButWithType: targetType
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                ^ sourceValue
        }.
    }.

    DecoratedType conversionTo: SelfType doOn: decorationIdentityAction.
    SelfType conversionTo: DecoratedType doOn: decorationIdentityAction.
}.

Type extend: {
    message volatile => _CompilerObjectType
        := VolatileTypeTemplate(self).
}.

// GCClass variable data array type
template GCClassVariableDataArrayTypeTemplate(E: Type)
    := type uses: GCClassVariableDataArrayType;
definition: {
    alias ElementType := E.
    alias InstanceAlignment := ElementType instanceAlignment.
    alias InstanceSize := ElementType instanceSize * Size.

    meta message instanceSize => Int32 :=  0.
    meta message instanceAlignment => _LiteralInteger := ElementType instanceAlignment.

    meta message elementType => Type := ElementType.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaArrayOf: ElementType concreteSSAType size: 0.

    meta message valueType => _CompilerObjectType
        := GCClassVariableDataArrayTypeTemplate(ElementType valueType).

    meta message valueTypeKeepLiteral => _CompilerObjectType
        := GCClassVariableDataArrayTypeTemplate(ElementType valueTypeKeepLiteral).

    meta message cleanType => _CompilerObjectType
        := GCClassVariableDataArrayTypeTemplate(ElementType cleanType).

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::=> _CompilerObjectType
        := module ssaConstantVariableArrayValue: value type: self.

    meta message createSysmelMangledValue => _CompilerObjectType
        := ElementType sysmelMangledValue -- #d -- Size asString.

    meta message createPrintingName => _CompilerObjectType
        := ElementType printingName -- " gcClassVariableDataArray".
}.

// Array type
template ArrayTypeTemplate(E: Type, N: _LiteralInteger)
    := type uses: ArrayType;
definition: {
    alias ElementType := E.
    alias Size := N.
    alias InstanceAlignment := ElementType instanceAlignment.
    alias InstanceSize := ElementType instanceSize * Size.

    if: N = 0 then: {
        meta message isUndeterminedArrayType => BooleanBit
            := true.

        meta message asGCClassFieldType => Type
            := GCClassVariableDataArrayTypeTemplate(ElementType).
    }.

    meta message size => _LiteralInteger := Size.
    meta message elementType => Type := ElementType.
    meta message instanceSize => Int32 := InstanceSize.
    meta message instanceAlignment => _LiteralInteger := InstanceAlignment.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaArrayOf: ElementType concreteSSAType size: Size.

    meta message valueType => _CompilerObjectType
        := ElementType valueType array: Size.

    meta message valueTypeKeepLiteral => _CompilerObjectType
        := ElementType valueTypeKeepLiteral array: Size.

    meta message cleanType => _CompilerObjectType
        := ElementType cleanType array: Size.

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::=> _CompilerObjectType
        := module ssaConstantArrayValue: value type: self.

    meta message createSysmelMangledValue => _CompilerObjectType
        := ElementType sysmelMangledValue -- #A -- Size asString.

    meta message createPrintingName => _CompilerObjectType
        := (E printingName -- " array:" -- Size asString).

    meta message isPODType => BooleanBit
        := ElementType isPODType.

    meta message hasNonTrivialInitialization => BooleanBit
        := ElementType hasNonTrivialInitialization.
    meta message hasNonTrivialFinalization => BooleanBit
        := ElementType hasNonTrivialFinalization.
}.

Type extend: {
    message array => _CompilerObjectType
        := ArrayTypeTemplate(self, 0).

    message array: (N: _LiteralInteger) ::=> _CompilerObjectType
        := ArrayTypeTemplate(self, N).
}.

// Tuple type
TupleType uses: AnyValue;
definition: {
    meta message isTupleType => BooleanBit := true.
}.

// Function group type
_FunctionGroupType uses: AnyValue;
definition: {
    meta message isFunctionGroupType => BooleanBit := true.

    macro selector: #applyWithArguments: doOn: {
        semanticAnalysis: $$Pharo {
            node: node environment: environment at: aPosition
                | functionGroup |
                functionGroup := node receiver analyzeAndEvaluateInEnvironment: environment.
                ^ functionGroup value
                    semanticAnalyzeApplication: node inEnvironment: environment at: aPosition
        }
    }.

    macro selector: #address doOn: {
        semanticAnalysis: $$Pharo {
            node: node environment: environment at: aPosition
                | functionGroup |
                functionGroup := node receiver analyzeAndEvaluateInEnvironment: environment.
                ^ functionGroup value
                    semanticAnalyzeAddress: node inEnvironment: environment at: aPosition
        }
    }.
}.

// Function type
FunctionType uses: AnyValue;
definition: {
    meta message isFunctionType => BooleanBit := true.

    macro selector: #applyWithArguments: doOn: {
        semanticAnalysis: $$Pharo {
            node: node environment: environment at: aPosition
                | function argumentsTuple functionType argumentsType functionCoercionRule argument coercionType coercionTypes coercionRules |
                function := node receiver.
                argumentsTuple := node arguments first semanticAnalysisInEnvironment: environment.

                functionType := function evaluateCleanValueTypeInEnvironment: environment.
                argumentsType := argumentsTuple evaluateCleanValueTypeInEnvironment: environment.

                "Check the receiver type"
            	functionType isFunctionType ifFalse: [
            		self error: 'Expected a function type instead of {1}.' format: { functionType asString }
            	].

                functionCoercionRule := function type node: function coercedImplicitlyInto: functionType at: node.

            	"Check the arguments type"
            	argumentsType isTupleType ifFalse: [
            		self error: 'Expected a tuple for the function application arguments.'
            	].

            	argumentsType types size < functionType arguments size ifTrue: [
            		self error: 'Fewer arguments than the required ones for function application.'
            	].

            	(argumentsType types size > functionType arguments size and: [functionType variadic not]) ifTrue: [
            		self error: 'More arguments than the required ones for function application.'
            	].

                coercionRules := Array new: argumentsType types size.
                coercionTypes := Array new: argumentsType types size.
            	argumentsType types doWithIndex: [:argumentType :index |
                    argument := argumentsTuple elements at: index.

                    index > functionType arguments size ifTrue: [
                        coercionType := argumentType cvariadicCoercionType.
                    ] ifFalse: [
                        coercionType := functionType arguments at: index.
                    ].

                    coercionTypes at: index put: coercionType.
                    coercionRules at: index put: (argumentType node: argument coercedImplicitlyInto: coercionType at: argument).
            	].

                ^ node copy
                    metaMethod: self;
                    receiver: function;
                    arguments: {argumentsTuple};
                    coercionRule: {functionCoercionRule . coercionRules};
                    coercionType: {functionType . coercionTypes};
                    valueType: functionType returnType;
                    yourself
        }.

        codeGeneration: $$Pharo {
            node: messageNode builder: builder
            | function rawFunctionType functionType argumentsTuple expectedArgumentTypes functionType argumentValues argumentType coercionRules coercionTypes |

			"Get the function"
			rawFunctionType := messageNode receiver type.
			functionType := messageNode coercionType first.
            function := messageNode coercionRule first
                convertSSAValue: (messageNode receiver generateSSACodeWith: builder)
                to: functionType
                with: builder at: messageNode.

            "Convert the arguments"
            argumentsTuple := messageNode arguments first.
            expectedArgumentTypes := functionType arguments.

            coercionRules := messageNode coercionRule second.
            coercionTypes := messageNode coercionType second.
            argumentValues := argumentsTuple elements collectWithIndex: [:argumentNode :index |
                argumentType := argumentNode type.
                (coercionRules at: index) convertSSAValue: (argumentNode generateSSACodeWith: builder)
                    to: (coercionTypes at: index)
                    with: builder at: messageNode.

            ].

            "Call the function"
            ^ builder call: function arguments: argumentValues
        }
    }.
}.

// Structure type
StructureType uses: AnyValue;
definition: {
    meta message asReceiverType => _CompilerObjectType
        := self ref.
}.

UnionType uses: StructureType.
ClassType uses: StructureType.

// Definition of some types
_LiteralArray uses: LiteralType.
_LiteralSymbol uses: LiteralType.
_LiteralString uses: LiteralType.

_LiteralInteger uses: (PrimitiveLiteralType, IntegerType);
definition: {
    meta message cvariadicCoercionType => _CompilerObjectType := Int32.
    meta message valueType => _CompilerObjectType := Int32.
}.

_LiteralFraction uses: (PrimitiveLiteralType, FractionalType);
definition: {
    meta message cvariadicCoercionType => _CompilerObjectType := Float64.
    meta message valueType => _CompilerObjectType := Float64.
}.

_LiteralFloat uses: (PrimitiveLiteralType, FloatingPointType);
definition: {
    meta message cvariadicCoercionType => _CompilerObjectType := Float64.
    meta message valueType => _CompilerObjectType := Float64.
}.

_CompilerObjectType uses: AnyValue.
_APSGNodeType uses: AnyValue.

BooleanBit uses: (BooleanType, PrimitiveType);
definition: {
    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaBoolType.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := builder const: value unwrapSysmelValue type: self ssaType.

    SelfType sysmelMangledValue: #b.
}.

// Undefined type. For nil
UndefinedType uses: OpaqueType;
definition: {
    message isUndefinedType => BooleanBit := true.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := value.

    SelfType sysmelMangledValue: #u.
}.

Void uses: OpaqueType;
definition: {
    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaVoidType.

    meta message defaultValue => _CompilerObjectType := nil.
    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::=> _CompilerObjectType
        := nil.


    SelfType sysmelMangledValue: #v.
}.

// Int8
Int8 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 1.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaInt8.

    meta message cvariadicCoercionType => _CompilerObjectType := Int32.

    SelfType sysmelMangledValue: #s1.
}.

UInt8 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 1.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaUInt8.

    meta message cvariadicCoercionType => _CompilerObjectType := Int32.

    SelfType sysmelMangledValue: #u1.
}.

// Int16
Int16 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 2.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaInt16.

    meta message cvariadicCoercionType => _CompilerObjectType := Int32.

    SelfType sysmelMangledValue: #s2.
}.

UInt16 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 2.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaUInt16.

    meta message cvariadicCoercionType => _CompilerObjectType
        := Int32.

    SelfType sysmelMangledValue: #u2.
}.

// Int32
Int32 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 4.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaInt32.

    meta message cvariadicCoercionType => _CompilerObjectType := self.

    SelfType sysmelMangledValue: #s4.
}.

UInt32 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 4.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaUInt32.

    meta message cvariadicCoercionType => _CompilerObjectType := self.

    SelfType sysmelMangledValue: #u4.
}.

// Int64
Int64 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 8.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaInt64.

    meta message cvariadicCoercionType => _CompilerObjectType := self.

    SelfType sysmelMangledValue: #s8.
}.

UInt64 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize => _LiteralInteger := 8.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaUInt64.

    meta message cvariadicCoercionType => _CompilerObjectType := self.

    SelfType sysmelMangledValue: #u8.
}.

Float32 uses: PrimitiveFloatingPointType;
definition: {
    meta message instanceSize => _LiteralInteger := 4.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaFloat32.

    meta message cvariadicCoercionType => _CompilerObjectType := Float64.

    SelfType sysmelMangledValue: #f4.
}.

Float64 uses: PrimitiveFloatingPointType;
definition: {
    meta message instanceSize => _LiteralInteger := 8.

    meta message buildSSAType => _CompilerObjectType
        := Compiler compilationTarget ssaFloat64.

    meta message cvariadicCoercionType => _CompilerObjectType := Float64.

    SelfType sysmelMangledValue: #f8.
}.

alias Char := UInt8.

} // End of namespace SysmelKernel
