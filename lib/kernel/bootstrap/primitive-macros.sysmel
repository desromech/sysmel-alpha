namespace SysmelKernel definition: {
    ## ifTrue:ifFalse
    (_BooleanType | _CompilerObjectType) macro method ifTrue: trueAction :=
        ``(if: `,self then: `,trueAction).
    (_BooleanType | _CompilerObjectType) macro method ifFalse: falseAction :=
        ``(if: `,self not then: `,falseAction).

    (_BooleanType | _CompilerObjectType) macro method ifTrue: trueAction ifFalse: falseAction :=
        ``(if: `,self then: `,trueAction else: `,falseAction).
    (_BooleanType | _CompilerObjectType) macro method ifFalse: falseAction ifTrue: trueAction :=
        ``(if: `,self then: `,trueAction else: `,falseAction).

    ## isNil
    _PointerType macro method isNil := ``(`,self == nil).
    _PointerType macro method isNotNil := ``(`,self ~~ nil).

    ## ifNil:ifNotNil
    ## TODO: Add higienic symbols.
    _PointerType macro method ifNil: nilAction :=
        ``(if: `,self == nil then: `,nilAction).
    _PointerType macro method ifNotNil: notNilAction :=
        ``(if: `,self ~~ nil then: `,notNilAction).

    _PointerType macro method ifNotNil: notNilAction ifNil: nilAction :=
        ``(if: `,self ~~ nil then: `,notNilAction else: `,nilAction).
    _PointerType macro method ifNil: nilAction ifNotNil: notNilAction :=
        ``(if: `,self == nil then: `,nilAction else: `,notNilAction).


    ## floorAlignedTo:
    _PrimitiveIntegerType macro method floorAlignedTo: alignment := ``(
        `,self & (`,alignment negated castTo: `,SelfType)
    ).

    ## alignedTo:
    _PrimitiveIntegerType macro method alignedTo: alignment := ``(
        (`,self + `,alignment - 1) & (`,alignment negated castTo: `,SelfType)
    ).

    ## isAlignedTo:
    _PrimitiveIntegerType macro method isAlignedTo: alignment :=
        ``(( (`,self castTo: `,SelfType) & (`,alignment - 1 castTo: `,SelfType)) == 0).

    _PointerType macro method isAlignedTo: alignment :=
        ``( (`,self reinterpretCastTo: UIntPointer) isAlignedTo: `,alignment).

    ## Bitwise logarithm base 2
    _PrimitiveIntegerType macro method log2Floor :=
        ``(`,self highBit - 1).

    #**
     * According to https:##en.wikipedia.org/wiki/Binary_logarithm:
     * floor(log2(n)) = ceil(log2(n + 1)) - 1
     * => ceil(log2(n + 1)) = floor(log2(n)) + 1
     * => ceil(log2(n)) = floor(log2(n - 1)) + 1
     *#
    _PrimitiveIntegerType macro method log2Ceil :=
        ``((`,self - 1) log2Floor + 1).

    _PrimitiveIntegerType macro method asSmallerPowerOfTwo :=
        ``(1 << `,self log2Floor).

    _PrimitiveIntegerType macro method asLargerPowerOfTwo :=
        ``(1 << `,self log2Ceil).

    ## Bitwise manipulation.
    _PrimitiveIntegerType macro method bitClear: bits :=
        ``(`,self & (`,bits bitInvert)).

    _PrimitiveIntegerType macro method allMask: mask :=
        ``((`,self & `,mask) == `,mask).

    _PrimitiveIntegerType macro method anyMask: mask :=
        ``((`,self & `,mask) ~~ 0).

    _PrimitiveIntegerType macro method noMask: mask :=
        ``((`,self & `,mask) == 0).

    ## Some numerical testing methods.
    _PrimitiveIntegerType macro method isEven :=
        ``((`,self & 1) == 0).
    _PrimitiveIntegerType macro method isOdd :=
        ``((`,self & 1) == 1).

    ## Range loop macro
    _NumberType macro method to: stop by: increment do: aBlock := {
        let index := __astBuilder gensym: #index.
        let stopValue := __astBuilder gensym: #stopValue.
        let incrementValue := __astBuilder gensym: #incrementValue.
        let stopAnalyzedNode := (__analyzer analyzeNodeIfNeeded: stop) castTo: _ASTNodeType.
        let indexType mutable type: _ASTNodeType.

		aBlock isBlockClosureNode && aBlock arguments size = 1
			&& aBlock arguments first valueType isNotNil ifTrue: {
            indexType := aBlock arguments first valueType castTo: _ASTNodeType
        } ifFalse: {
            indexType := (__analyzer computeArithmethicCoercionTypeNodeFor: self with: stopAnalyzedNode fallbackTo: Int32 at: self)
                castTo: _ASTNodeType
        }.

        ``{
            let `,index mutable type: `,indexType := `,self.
            let `,stopValue type: `,indexType := `,stopAnalyzedNode.
            let `,incrementValue type: `,indexType := `,increment.

            while: (`,index <= `,stopValue) do: {
                `,aBlock  __macroInlineBlock: `,index
            } continueWith: (`,index := `,index + `,incrementValue)
        }
    }.

    _NumberType macro method to: stop do: aBlock := ``(`,self to: `,stop by: 1 do: `,aBlock).

    _NumberType macro method until: stop by: increment do: aBlock := {
        let index := __astBuilder gensym: #index.
        let stopValue := __astBuilder gensym: #stopValue.
        let incrementValue := __astBuilder gensym: #incrementValue.
        let stopAnalyzedNode := (__analyzer analyzeNodeIfNeeded: stop) castTo: _ASTNodeType.
        let indexType mutable type: _ASTNodeType.

		aBlock isBlockClosureNode && aBlock arguments size = 1
			&& aBlock arguments first valueType isNotNil ifTrue: {
            indexType := aBlock arguments first valueType castTo: _ASTNodeType
        } ifFalse: {
            indexType := (__analyzer computeArithmethicCoercionTypeNodeFor: self with: stopAnalyzedNode fallbackTo: Int32 at: self)
                castTo: _ASTNodeType
        }.

        ``{
            let `,index mutable type: `,indexType := `,self.
            let `,stopValue type: `,indexType := `,stopAnalyzedNode.
            let `,incrementValue type: `,indexType := `,increment.

            while: (`,index < `,stopValue) do: {
                `,aBlock  __macroInlineBlock: `,index
            } continueWith: (`,index := `,index + `,incrementValue)
        }
    }.

    _NumberType macro method until: stop do: aBlock := ``(`,self until: `,stop by: 1 do: `,aBlock).
}.
