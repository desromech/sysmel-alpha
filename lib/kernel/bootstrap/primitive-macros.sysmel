namespace SysmelKernel definition: {
    ## ifTrue:ifFalse
    (_BooleanType | _CompilerObjectType) macro expansionRule ifTrue: trueAction :=
        ``(if: `,self then: `,trueAction).
    (_BooleanType | _CompilerObjectType) macro expansionRule ifFalse: falseAction :=
        ``(if: `,self not then: `,falseAction).

    (_BooleanType | _CompilerObjectType) macro expansionRule ifTrue: trueAction ifFalse: falseAction :=
        ``(if: `,self then: `,trueAction else: `,falseAction).
    (_BooleanType | _CompilerObjectType) macro expansionRule ifFalse: falseAction ifTrue: trueAction :=
        ``(if: `,self then: `,trueAction else: `,falseAction).
		
    ## isNil
    _PointerType macro expansionRule isNil := ``(`,self == nil).
    _PointerType macro expansionRule isNotNil := ``(`,self ~~ nil).

    ## ifNil:ifNotNil
    ## TODO: Add higienic symbols.
    _PointerType macro expansionRule ifNil: nilAction :=
        ``(if: `,self == nil then: `,nilAction).
    _PointerType macro expansionRule ifNotNil: notNilAction :=
        ``(if: `,self ~~ nil then: `,notNilAction).

    _PointerType macro expansionRule ifNotNil: notNilAction ifNil: nilAction :=
        ``(if: `,self ~~ nil then: `,notNilAction else: `,nilAction).
    _PointerType macro expansionRule ifNil: nilAction ifNotNil: notNilAction :=
        ``(if: `,self == nil then: `,nilAction else: `,notNilAction).


    ## floorAlignedTo:
    _PrimitiveIntegerType macro expansionRule floorAlignedTo: alignment := ``(
        `,self & (`,alignment negated castTo: `,SelfType)
    ).

    ## alignedTo:
    _PrimitiveIntegerType macro expansionRule alignedTo: alignment := ``(
        (`,self + `,alignment - 1) & (`,alignment negated castTo: `,SelfType)
    ).

    ## isAlignedTo:
    _PrimitiveIntegerType macro expansionRule isAlignedTo: alignment :=
        ``(( (`,self castTo: `,SelfType) & (`,alignment - 1 castTo: `,SelfType)) == 0).

    _PointerType macro expansionRule isAlignedTo: alignment :=
        ``( (`,self reinterpretCastTo: UIntPointer) isAlignedTo: `,alignment).

    ## Bitwise logarithm base 2
    _PrimitiveIntegerType macro expansionRule log2Floor :=
        ``(`,self highBit - 1).

    #**
     * According to https:##en.wikipedia.org/wiki/Binary_logarithm:
     * floor(log2(n)) = ceil(log2(n + 1)) - 1
     * => ceil(log2(n + 1)) = floor(log2(n)) + 1
     * => ceil(log2(n)) = floor(log2(n - 1)) + 1
     *#
    _PrimitiveIntegerType macro expansionRule log2Ceil :=
        ``((`,self - 1) log2Floor + 1).

    ## Bitwise manipulation.
    _PrimitiveIntegerType macro expansionRule bitClear: bits :=
        ``(`,self & (`,bits bitInvert)).

    _PrimitiveIntegerType macro expansionRule allMask: mask :=
        ``((`,self & `,mask) == `,mask).

    _PrimitiveIntegerType macro expansionRule anyMask: mask :=
        ``((`,self & `,mask) ~~ 0).

    _PrimitiveIntegerType macro expansionRule noMask: mask :=
        ``((`,self & `,mask) == 0).

    ## Some numerical testing methods.
    _PrimitiveIntegerType macro expansionRule isEven :=
        ``((`,self & 1) == 0).
    _PrimitiveIntegerType macro expansionRule isOdd :=
        ``((`,self & 1) == 1).

    ## Compile time if.
    macro expansionRule compileTimeIf: (condition: BooleanBit) then: thenNode
        := condition ifTrue: thenNode ifFalse: ``nil.

    macro expansionRule compileTimeIf: (condition: BooleanBit) then: thenNode else: elseNode
        := condition ifTrue: thenNode ifFalse: elseNode.

    ## Range loop macro
    _NumberType macro expansionRule to: stop by: increment do: aBlock := {
        let index := __astBuilder gensym: #index.
        let stopValue := __astBuilder gensym: #stopValue.
        let incrementValue := __astBuilder gensym: #incrementValue.

		aBlock isBlockClosureNode && aBlock arguments size = 1
			&& aBlock arguments first valueType isNotNil ifTrue: {
            let indexType := aBlock arguments first valueType castTo: _ASTNodeType.

            ``{
                let `,index mutable type: `,indexType := `,self.
                let `,stopValue type: `,indexType := `,stop.
                let `,incrementValue type: `,indexType := `,increment.

                while: (`,index <= `,stopValue) do: {
                    `,aBlock  __macroInlineBlock: `,index
                } continueWith: (`,index := `,index + `,incrementValue)
            }
        } ifFalse: {
            ``{
                let `,index mutable := `,self.
                let `,stopValue := `,stop.
                let `,incrementValue := `,increment.

                while: (`,index <= `,stopValue) do: {
                    `,aBlock __macroInlineBlock: `,index
                } continueWith: (`,index := `,index + `,incrementValue)
            }
        }
    }.

    _NumberType macro expansionRule to: stop do: aBlock := ``(`,self to: `,stop by: 1 do: `,aBlock).

    _NumberType macro expansionRule until: stop by: increment do: aBlock := {
        let index := __astBuilder gensym: #index.
        let stopValue := __astBuilder gensym: #stopValue.
        let incrementValue := __astBuilder gensym: #incrementValue.

        aBlock isBlockClosureNode && aBlock arguments size = 1
			&& aBlock arguments first valueType isNotNil ifTrue: {
            let indexType := aBlock arguments first valueType castTo: _ASTNodeType.

            ``{
                let `,index mutable type: `,indexType := `,self.
                let `,stopValue type: `,indexType := `,stop.
                let `,incrementValue type: `,indexType := `,increment.

                while: (`,index < `,stopValue) do: {
                    `,aBlock  __macroInlineBlock: `,index
                } continueWith: (`,index := `,index + `,incrementValue)
            }
        } ifFalse: {
            ``{
                let `,index mutable := `,self.
                let `,stopValue := `,stop.
                let `,incrementValue := `,increment.

                while: (`,index < `,stopValue) do: {
                    `,aBlock __macroInlineBlock: `,index
                } continueWith: (`,index := `,index + `,incrementValue)
            }
        }
    }.

    _NumberType macro expansionRule until: stop do: aBlock := ``(`,self until: `,stop by: 1 do: `,aBlock).
}.
