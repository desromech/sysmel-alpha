namespace Sysmel definition: {

Compiler compilationTarget
    managedClassTypeTrait: trait ManagedClassTrait;
    dynamicObjectType: type Dynobject.

Type extend: {
    message gcpointer -> _CompilerObjectType := {
        return: (self pointerFor: #gc)
    }.
}.

ManagedClassTrait uses: AnyValue;
definition: {
}.

UndefinedType conversionTo: ManagedClassTrait doOn: {
    evaluation: $$Pharo {
        value: value targetType: targetType at: position
            ^ value sameValueButWithType: targetType
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ targetType defaultSSAValueWith: builder
    }.
}.

// Variable data trait
GCClassVariableDataArrayType macro selectors: #(size) doOn: {

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
            | variableData receiverType sizeType |
            "Analyze message "
            variableData := node receiver semanticAnalysisInEnvironment: environment.
            receiverType := variableData evaluateReceiverTypeInEnvironment: environment.
            self assert: variableData type isReferenceType.

            sizeType := receiverType variableDataSizeField type.

            "Create the analyzed message"
            ^ node copy
                metaMethod: self;
                receiver: variableData;
                coercionType: receiverType;
                valueType: sizeType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | receiverType actualReceiver sizeField |
            receiverType := messageNode coercionType.
            actualReceiver := messageNode receiver generateReceiverSSACodeWith: builder.

            "size"
            sizeField := receiverType variableDataSizeField.
            ^ sizeField ssaGetValue: actualReceiver builder: builder
    }.
}.

GCClassVariableDataArrayType macro selectors: #(at: subscriptAt:) doOn: {

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
            | variableData receiverType arrayType resultType index indexType coercionType coercionRule |

            "Check and coerce the receiver"
            variableData := node receiver semanticAnalysisInEnvironment: environment.
            receiverType := variableData evaluateReceiverTypeInEnvironment: environment.

            self assert: variableData type isReferenceType.
            arrayType := variableData type referenced.
            resultType := arrayType elementType ref.

            "Check the index type."
            index := node arguments first semanticAnalysisInEnvironment: environment.
            indexType := index evaluateTypeInEnvironment: environment.
            coercionType := indexType cleanValueType.

            coercionType isIntegerType ifFalse: [
                self error: 'Expected an integer for pointer element accessing.' at: aSourcePosition.
            ].
            coercionRule := indexType node: index coercedImplicitlyInto: coercionType at: node.

            "Create the analyzed message"
            ^ node copy
                metaMethod: self;
                receiver: variableData;
                arguments: {index};
                coercionType: {receiverType . coercionType};
                coercionRule: {nil . coercionRule };
                valueType: resultType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | arrayReference index |
            "Get the reference to the variable."
            arrayReference := messageNode receiver generateSSACodeWith: builder.

            "Convert the index"
            index := messageNode coercionRule second convertSSAValue: (messageNode arguments first generateSSACodeWith: builder)
                to: messageNode coercionType second
                with: builder at: messageNode.

            "One based indices into zero based"
            messageNode selector == #at: ifTrue: [
                index := builder sub: index with: (builder const: 1 type: index type)
            ].

            ^ builder getReference: arrayReference element: index
    }.
}.

}. // End of namespace Sysmel

namespace Smalltalk definition: {

// Meta circular hierarchy
gcclass ProtoObject.
gcclass Metaclass.

ProtoObject metaClassClass: Metaclass.

gcclass Object superclass: ProtoObject.
    gcclass Behavior superclass: Object.
        gcclass ClassDescription superclass: Behavior.
            gcclass Class superclass: ClassDescription.
            gcclass Metaclass superclass: ClassDescription.

    // BooleanBit
    gcclass Boolean superclass: Object.
        gcclass True superclass: Boolean.
        gcclass False superclass: Boolean.

    // Undefind object
    gcclass UndefinedObject superclass: Object.

    // Numbers
    gcclass Magnitude superclass: Object.
        gcclass Number superclass: Magnitude.
            gcclass Float superclass: Number.
                gcclass BoxedFloat64 superclass: Float.
                gcclass SmallFloat64 superclass: Float.
            gcclass Integer superclass: Number.
                gcclass LargeInteger superclass: Integer.
                    gcclass LargeNegativeInteger superclass: LargeInteger.
                    gcclass LargePositiveInteger superclass: LargeInteger.
                gcclass SmallInteger superclass: Integer.


    gcclass GCLayout superclass: Object.

// Essential collections
gcclass Collection superclass: Object.
    gcclass HashedCollection superclass: Collection.
        gcclass Dictionary superclass: HashedCollection.
        gcclass MethodDictionary superclass: Dictionary.
    gcclass SequenceableCollection superclass: Collection.
        gcclass ArrayedCollection superclass: SequenceableCollection.
            gcclass Array superclass: ArrayedCollection.
            gcclass ByteArray superclass: ArrayedCollection.
            gcclass FloatArray superclass: ArrayedCollection.
            gcclass IntegerArray superclass: ArrayedCollection.
            gcclass WordArray superclass: ArrayedCollection.

            gcclass String superclass: ArrayedCollection.
                gcclass Symbol superclass: String.

// Methods
gcclass CompiledMethod superclass: Object.

// ProtoObject
ProtoObject type superclass: Class.

ProtoObject definition: {
    // We use a fixed 16-byte object header, to be able to use SSE instructions.

    field __class private type: Behavior. // TODO: Point into the vtable, instead of the class.

    if: UIntPointer instanceSize == 4 then: {
        // TODO: Support big-endian.
        field __padding private type: Behavior.
    }.

    // 32 bits: gc color, isPinned, isImmutable.
    field _ private bits: 5; type: UInt32.

    field __gcBits private type: UInt32; bits: 3.
    field __isPinned private type: UInt32; bits: 1.
    field __isImmutable private type: UInt32; bits: 1.
    field __identityHash private type: UInt32; bits: 22.

    // Variable data size
    field __variableDataSize private type: UInt32.
}.

Behavior uses: Type; definition: {
    field superclass public type: Behavior.
    field methodDict public type: MethodDictionary.
    field gclayout public type: GCLayout.
    field slots public type: Array.

    field instanceDataSize public type: UIntPointer.
    field instanceDataAlignment public type: UIntPointer.

    field variableInstanceElementSize public type: UIntPointer.
    field variableInstanceElementAlignment public type: UIntPointer.

    // TODO: Suport InstanceType as the return type.
    message basicNew -> ProtoObject := {
        LibC printf ("basicNew called").
        return: nil
    }.

    message asReceiverType -> SelfType := {
        [[compileTime]]
        return: self
    }.

    message cvariadicCoercionType -> SelfType := {
        [[compileTime]]
        return: self
    }.

    message lookupSelector: (selector: ProtoObject) ::-> ProtoObject := {
        [[staticBinding]]
        [[nogc]]
        LibC printf("Behavior %p >> lookupSelector: %p\n", self, selector).

        if: methodDict ~~ nil then: {
            let method := methodDict atOrNil: selector.
            if: method  ~~ nil then: {
                return: method
            }.
        }.

        if: superclass == nil then: {
            return: nil.
        }.

        return: (superclass lookupSelector: selector)
    }.
}.

Class definition: {
    field name protected type: Symbol.

    message name -> Symbol := {
        return: name
    }.
}.

Metaclass definition: {
    field thisClass protected type: Behavior.

    message isMetaType -> BooleanBit := {
        return: true
    }.
}.

// GCLayoutRecord
struct GCLayoutRecord definition: {
    field type public type: UIntPointer.
    field offset public type: UIntPointer.
    field size public type: UIntPointer.
}.

// GCLayout
GCLayout definition: {
    field records public type: GCLayoutRecord array.
}.

// String
String definition: {
    field __data protected type: UInt8 array.
}.

//-----------------------------------------------------------------------------
ProtoObject definition: {
    message class -> Behavior := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __class
    }.

    message identityHash -> UInt32 := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __identityHash
    }.

    message == (other: ProtoObject) -> BooleanBit := {
        [[compileTime]]
        [[staticBinding]]
        [[intrinsic: #"dynobject.identityEquals"]]

    }.

    message ~~ (other: ProtoObject) -> BooleanBit := {
        [[compileTime]]
        [[staticBinding]]
        [[intrinsic: #"dynobject.identityNotEquals"]]
    }.
}.

//-----------------------------------------------------------------------------
// Important collections
Array definition: {
    field __data protected type: ProtoObject array.

    message basicSize -> UInt32 := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __data size
    }.

    message basicAt: (index: UInt32) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: (__data at: index)
    }.

    message basicAt: (index: UInt32) put: (value: ProtoObject) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        (__data at: index) := value.
        return: value
    }.

}.

HashedCollection definition: {
    field tally protected type: UIntPointer.
    field array protected type: Array.
}.

MethodDictionary definition: {
    field values protected type: Array.

    message atOrNil: (key: ProtoObject) ::-> ProtoObject := {
        [[staticBinding]]
        [[nogc]]
        LibC printf("atOrNil: %p\n", key).
        
        return: nil
    }.
}.

//-----------------------------------------------------------------------------
// Literals
let literalConversionRule := {

    evaluation: $$Pharo {
        value: value into: targetType at: coercionPosition
            "Literal -> Object eval"
            self halt.
            ^ value sameValueButWithType: targetType
    }.

    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ builder addDynamicLiteral: sourceValue
    }.
}.

_LiteralSymbol conversionTo: Symbol doOn: literalConversionRule.
_LiteralString conversionTo: String doOn: literalConversionRule.
_LiteralInteger conversionTo: Integer doOn: literalConversionRule.
_LiteralFloat conversionTo: Float doOn: literalConversionRule.

//-----------------------------------------------------------------------------
// Normal message lookup
namespace Runtime definition: {
function messageLookupFromBehavior(behavior: Behavior, object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) -> Void pointer := {
    [[nogc]]
    LibC printf("messageLookupFromBehavior behavior %p object %p selector %p\n", behavior, object, selector).
    let method := behavior lookupSelector: selector.

    if: method == nil then: {
        if: selector == #doesNotUnderstand: then: {
            LibC printf("Fatal error: Failed to lookup doesNotUnderstand:\n").
            LibC abort().
        }.

        return: fallbackTrampoline
    }.

    LibC printf("Found method: %p\n", method).
    LibC abort().
    return: nil
}.

function normalMessageLookup(object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) -> Void pointer := {
    [[nogc]]
    LibC printf("normalMessageLookup object %p selector %p fallbackTrampoline %p\n", object, selector, fallbackTrampoline).
    return: messageLookupFromBehavior(object class, object, selector, fallbackTrampoline).
}.

Compiler compilationTarget objectModel
    sysmelMessageLookupFunction: normalMessageLookup;
    symbolClass: Symbol;
    stringClass: String;
    yourself
}.

}.
