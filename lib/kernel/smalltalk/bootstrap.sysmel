namespace SysmelKernel definition: {

Compiler compilationTarget
    //dynamicObjectType: type Dynobject
    managedClassTypeTrait: trait ManagedClassTrait.



Type extend: {
    message gcpointer -> _CompilerObjectType := {
        return: (self pointerFor: #gc)
    }.
}.

ManagedClassTrait uses: AnyValue;
definition: {
}.

UndefinedType conversionTo: ManagedClassTrait doOn: {
    evaluation: $$Pharo {
        value: value targetType: targetType at: position
            ^ value sameValueButWithType: targetType
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ targetType defaultSSAValueWith: builder
    }.
}.

// Variable data trait
GCClassVariableDataArrayType macro selectors: #(size) doOn: {

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
            | variableData receiverType sizeType |
            "Analyze message "
            variableData := node receiver semanticAnalysisInEnvironment: environment.
            receiverType := variableData evaluateReceiverTypeInEnvironment: environment.
            self assert: variableData type isReferenceType.

            sizeType := receiverType variableDataSizeField type.

            "Create the analyzed message"
            ^ node copy
                metaMethod: self;
                receiver: variableData;
                coercionType: receiverType;
                valueType: sizeType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | receiverType actualReceiver sizeField |
            receiverType := messageNode coercionType.
            actualReceiver := messageNode receiver generateReceiverSSACodeWith: builder.

            "size"
            sizeField := receiverType variableDataSizeField.
            ^ sizeField ssaGetValue: actualReceiver builder: builder
    }.
}.

GCClassVariableDataArrayType macro selectors: #(at: subscriptAt:) doOn: {

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
            | variableData receiverType arrayType resultType index indexType coercionType coercionRule |

            "Check and coerce the receiver"
            variableData := node receiver semanticAnalysisInEnvironment: environment.
            receiverType := variableData evaluateReceiverTypeInEnvironment: environment.

            self assert: variableData type isReferenceType.
            arrayType := variableData type referenced.
            resultType := arrayType elementType ref.

            "Check the index type."
            index := node arguments first semanticAnalysisInEnvironment: environment.
            indexType := index evaluateTypeInEnvironment: environment.
            coercionType := indexType cleanValueType.

            coercionType isIntegerType ifFalse: [
                self error: 'Expected an integer for pointer element accessing.' at: aSourcePosition.
            ].
            coercionRule := indexType node: index coercedImplicitlyInto: coercionType at: node.

            "Create the analyzed message"
            ^ node copy
                metaMethod: self;
                receiver: variableData;
                arguments: {index};
                coercionType: {receiverType . coercionType};
                coercionRule: {nil . coercionRule };
                valueType: resultType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | arrayReference index |
            "Get the reference to the variable."
            arrayReference := messageNode receiver generateSSACodeWith: builder.

            "Convert the index"
            index := messageNode coercionRule second convertSSAValue: (messageNode arguments first generateSSACodeWith: builder)
                to: messageNode coercionType second
                with: builder at: messageNode.

            "One based indices into zero based"
            messageNode selector == #at: ifTrue: [
                index := builder sub: index with: (builder const: 1 type: index type)
            ].

            ^ builder getReference: arrayReference element: index
    }.
}.

}. // End of namespace Sysmel

namespace Smalltalk definition: {

// Meta circular hierarchy
gcclass ProtoObject.
gcclass Metaclass.

ProtoObject metaClassClass: Metaclass.

Compiler compilationTarget dynamicObjectType: ProtoObject.
alias Dynobject := ProtoObject.

gcclass Object superclass: ProtoObject.
    gcclass Behavior superclass: Object.
        gcclass ClassDescription superclass: Behavior.
            gcclass Class superclass: ClassDescription.
            gcclass Metaclass superclass: ClassDescription.

    // BooleanBit
    gcclass Boolean superclass: Object.
        gcclass True superclass: Boolean.
        gcclass False superclass: Boolean.

    // Undefind object
    gcclass UndefinedObject superclass: Object.

    // Numbers
    gcclass Magnitude superclass: Object.
        gcclass Number superclass: Magnitude.
            gcclass Float superclass: Number.
                gcclass BoxedFloat64 superclass: Float.
                gcclass SmallFloat64 superclass: Float.
            gcclass Integer superclass: Number.
                gcclass LargeInteger superclass: Integer.
                    gcclass LargeNegativeInteger superclass: LargeInteger.
                    gcclass LargePositiveInteger superclass: LargeInteger.
                gcclass SmallInteger superclass: Integer.


    gcclass GCLayout superclass: Object.

// Essential collections
gcclass Collection superclass: Object.
    gcclass HashedCollection superclass: Collection.
        gcclass Dictionary superclass: HashedCollection.
            gcclass MethodDictionary superclass: Dictionary.
    gcclass SequenceableCollection superclass: Collection.
        gcclass ArrayedCollection superclass: SequenceableCollection.
            gcclass Array superclass: ArrayedCollection.
            gcclass ByteArray superclass: ArrayedCollection.
            gcclass FloatArray superclass: ArrayedCollection.
            gcclass IntegerArray superclass: ArrayedCollection.
            gcclass WordArray superclass: ArrayedCollection.

            gcclass String superclass: ArrayedCollection.
                gcclass Symbol superclass: String.

// Methods
gcclass CompiledMethod superclass: Object.

// ProtoObject
ProtoObject type superclass: Class.

ProtoObject definition: {
    // We use a fixed 16-byte object header, to be able to use SSE instructions.

    field __class private type: Behavior. // TODO: Point into the vtable, instead of the class.

    if: UIntPointer instanceSize == 4 then: {
        // TODO: Support big-endian.
        field __padding private type: Behavior.
    }.

    // 32 bits: gc color, isPinned, isImmutable.
    field _ private bits: 5; type: UInt32.

    field __gcBits private type: UInt32; bits: 3.
    field __isPinned private type: UInt32; bits: 1.
    field __isImmutable private type: UInt32; bits: 1.
    field __identityHash private type: UInt32; bits: 22.

    // Variable data size
    field __variableDataSize private type: UInt32.
}.

Behavior uses: Type; definition: {
    field superclass public type: Behavior.
    field methodDict public type: MethodDictionary.
    field gclayout public type: GCLayout.
    field slots public type: Array.

    field instanceDataSize public type: UIntPointer.
    field instanceDataAlignment public type: UIntPointer.

    field variableInstanceElementSize public type: UIntPointer.
    field variableInstanceElementAlignment public type: UIntPointer.

    // Notify about dynamic object type.
    message isDynamicObjectType -> BooleanBit := {
        return: true
    }.

    message isAnyDynamicObjectType -> BooleanBit := {
        return: self == Dynobject
    }.

    // The type of the instance is actually a dependent type because of the meta-circular hierarchy.
    type InstanceType uses: AnyValue;
        definition: {
        meta message asConcreteTypeForFunctionAnalysis -> Type := {
            return: Dynobject
        }.

        meta message asReturnTypeForReceiverType: (receiverType: _CompilerObjectType) argumentTypes: (argumentTypes: _CompilerObjectType) ::-> _CompilerObjectType := {
            return: receiverType instanceType
        }.
    }.

    (message basicNew -> InstanceType := {
        [[notInCompileTime]]
        LibC printf ("basicNew called").
        return: nil
    }) evaluator: $$Pharo {
        evaluateMessageWithReceiver: receiver arguments: arguments environment: environment at: position
            ^ receiver makeInstance asSysmelValueInEnvironment: environment
    }.

    (message basicNew: (initialSize: UIntPointer) ::-> InstanceType := {
        LibC printf ("basicNew: called").
        return: nil
    }) evaluator: $$Pharo {
        evaluateMessageWithReceiver: receiver arguments: arguments environment: environment at: position
            ^ (receiver makeInstance: arguments first unwrapSysmelValue) asSysmelValueInEnvironment: environment
    }.

    message asReceiverType -> SelfType := {
        [[compileTime]]
        return: self
    }.

    message cvariadicCoercionType -> SelfType := {
        [[compileTime]]
        return: self
    }.

    message lookupSelector: (selector: ProtoObject) ::-> ProtoObject := {
        [[staticBinding]]
        [[nogc]]
        LibC printf("Behavior %p >> lookupSelector: %p\n", self, selector).

        if: methodDict ~~ nil then: {
            let method := methodDict atOrNil: selector.
            if: method  ~~ nil then: {
                return: method
            }.
        }.

        if: superclass == nil then: {
            return: nil.
        }.

        return: (superclass lookupSelector: selector)
    }.
}.

Class definition: {
    field name protected type: Symbol.

    message name -> Symbol := {
        return: name
    }.
}.

Metaclass definition: {
    field thisClass protected type: Behavior.

    message isMetaType -> BooleanBit := {
        return: true
    }.
}.

// GCLayoutRecord
struct GCLayoutRecord definition: {
    field type public type: UIntPointer.
    field offset public type: UIntPointer.
    field size public type: UIntPointer.
}.

// GCLayout
GCLayout definition: {
    field records public type: GCLayoutRecord array.
}.

// String
String definition: {
    field __data protected type: UInt8 array.
}.

//-----------------------------------------------------------------------------
ProtoObject definition: {
    message class -> Behavior := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __class
    }.

    message identityHash -> UInt32 := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __identityHash
    }.

    message == (other: ProtoObject) -> BooleanBit := {
        [[compileTime]]
        [[staticBinding]]
        [[intrinsic: #"dynobject.identityEquals"]]

    }.

    message ~~ (other: ProtoObject) -> BooleanBit := {
        [[compileTime]]
        [[staticBinding]]
        [[intrinsic: #"dynobject.identityNotEquals"]]
    }.
}.

//-----------------------------------------------------------------------------
// Important collections
Array definition: {
    field __data protected type: ProtoObject array.

    message basicSize -> UInt32 := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __data size
    }.

    message basicAt: (index: UInt32) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: (__data at: index)
    }.

    message basicAt: (index: UInt32) put: (value: ProtoObject) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        (__data at: index) := value.
        return: value
    }.

    // TODO: Use UInt32 here.
    message subscriptAt: (index: Int32) ::-> ProtoObject ref := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __data[index]
    }.

}.

HashedCollection definition: {
    field tally protected type: UIntPointer.
    field array protected type: Array.
}.

MethodDictionary definition: {
    field values protected type: Array.

    message initializeForCapacity: (initialCapacity: UIntPointer) ::-> SelfType := {
        tally := 0.
        array := Array basicNew: initialCapacity.
        values := Array basicNew: initialCapacity.
        return: self
    }.

    message scanFor: (key: ProtoObject) ::-> Int32 := {
        [[staticBinding]]
        [[nogc]]

        // Make sure we at least have a size.
        let keyCount := array basicSize castTo: Int32. // TODO: Fix these casts.
        if: keyCount = 0 then: {
            return: -1
        }.

        // Find the natural key slot.
        let keySlot := (key identityHash % array basicSize) castTo: Int32.

        // Perform linear probing.
        let i := keySlot.
        while: i < keyCount do: {
            let slotKey := array[i].
            if: slotKey == key || slotKey == nil then: {
                return: i
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let slotKey := array[i].
            if: slotKey == key || slotKey == nil then: {
                return: i
            }.
        } continueWith: { i := i + 1 }.

        return: -1
    }.

    message at: (key: ProtoObject) putNoSpaceCheck: (value: ProtoObject) ::-> SelfType := {
        [[staticBinding]]
        let slot := self scanFor: key.
        if: slot < 0 then: {
            return: self
        }.

        array[slot] := key.
        values[slot] := value.

        return: self
    }.

    message atOrNil: (key: ProtoObject) ::-> ProtoObject := {
        [[staticBinding]]
        [[nogc]]
        LibC printf("atOrNil: %p | tally %zu array [%d]%p values [%d]%p\n", key, tally, array basicSize, array, values basicSize, values).
        let slot := self scanFor: key.
        LibC printf("slot %d\n", slot).

        return: nil
    }.
}.

//-----------------------------------------------------------------------------
// Literals
let literalConversionRule := `'{

    evaluation: $$Pharo {
        value: value into: targetType at: coercionPosition
            "Literal -> Object eval"
            self halt.
            ^ value sameValueButWithType: targetType
    }.

    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ builder addDynamicLiteral: sourceValue
    }.
}.

_LiteralSymbol conversionTo: Symbol doOn: literalConversionRule.
_LiteralString conversionTo: String doOn: literalConversionRule.
_LiteralInteger conversionTo: Integer doOn: literalConversionRule.
_LiteralFloat conversionTo: Float doOn: literalConversionRule.

//-----------------------------------------------------------------------------
// Normal message lookup
namespace Runtime definition: {
function messageLookupFromBehavior(behavior: Behavior, object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) -> Void pointer := {
    [[nogc]]
    LibC printf("messageLookupFromBehavior behavior %p object %p selector %p\n", behavior, object, selector).
    let method := behavior lookupSelector: selector.

    if: method == nil then: {
        if: selector == #doesNotUnderstand: then: {
            LibC printf("Fatal error: Failed to lookup doesNotUnderstand:\n").
            LibC abort().
        }.

        return: fallbackTrampoline
    }.

    LibC printf("Found method: %p\n", method).
    LibC abort().
    return: nil
}.

function normalMessageLookup(object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) -> Void pointer := {
    [[nogc]]
    LibC printf("normalMessageLookup object %p selector %p fallbackTrampoline %p\n", object, selector, fallbackTrampoline).
    return: messageLookupFromBehavior(object class, object, selector, fallbackTrampoline).
}.

Compiler compilationTarget objectModel
    sysmelMessageLookupFunction: normalMessageLookup;
    arrayClass: Array;
    byteArrayClass: ByteArray;
    dictionaryClass: Dictionary;
    methodDictionaryClass: MethodDictionary;
    symbolClass: Symbol;
    stringClass: String;
    yourself
}.

}.
