namespace SysmelKernel definition: {

Compiler compilationTarget
    managedClassTypeTrait: trait ManagedClassTrait.



Type extend: {
    message gcpointer -> _CompilerObjectType := {
        return: (self pointerFor: #gc)
    }.
}.

ManagedClassTrait uses: AnyValue;
definition: {
}.

UndefinedType conversionTo: ManagedClassTrait doOn: {
    evaluation: $$Pharo {
        value: value targetType: targetType at: position
            ^ value sameValueButWithType: targetType
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ targetType defaultSSAValueWith: builder
    }.
}.

let pointerReinterpretCast := `'{
    evaluation: $$Pharo {
        value: value targetType: targetType at: position
            ^ value sameValueButWithType: targetType
    }.
    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ builder bitCast: sourceValue target: targetType ssaType
    }.
}.

ManagedClassTrait reinterpretConversionTo: PointerType doOn: pointerReinterpretCast.
PointerType reinterpretConversionTo: ManagedClassTrait doOn: pointerReinterpretCast.

// Variable data trait
GCClassVariableDataArrayType macro selectors: #(size) doOn: {
    // Evaluation
    evaluation: $$Pharo {
        evaluateMessage: message inEnvironment: anEnvironment
            | variableData receiverType sizeSlotIndex |
            variableData := message receiver evaluateInEnvironment: anEnvironment.

            receiverType := message coercionType.
            sizeSlotIndex := receiverType variableDataSizeField slotIndex.

            "Create the analyzed message"
            ^ (variableData value container slots at: sizeSlotIndex + 1)
                sysmelValueWithType: message valueType inEnvironment: anEnvironment
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
            | variableData receiverType sizeType |
            "Analyze message "
            variableData := node receiver semanticAnalysisInEnvironment: environment.
            receiverType := variableData evaluateReceiverTypeInEnvironment: environment.
            self assert: variableData type isReferenceType.

            sizeType := receiverType variableDataSizeField type.

            "Create the analyzed message"
            ^ node copy
                metaMethod: self;
                receiver: variableData;
                coercionType: receiverType;
                valueType: sizeType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | receiverType actualReceiver sizeField |
            receiverType := messageNode coercionType.
            actualReceiver := messageNode receiver generateReceiverSSACodeWith: builder.

            "size"
            sizeField := receiverType variableDataSizeField.
            ^ sizeField ssaGetValue: actualReceiver builder: builder
    }.
}.

GCClassVariableDataArrayType macro selectors: #(at: subscriptAt:) doOn: {
    // Evaluation
    evaluation: $$Pharo {
        evaluateMessage: message inEnvironment: anEnvironment
            | variableData indexCoercionRule indexCoercionType index |
            variableData := message receiver evaluateInEnvironment: anEnvironment.

            indexCoercionRule := message coercionRule second.
            indexCoercionType := message coercionType second.
            index := (indexCoercionRule convertValue: (message arguments first evaluateInEnvironment: anEnvironment)
                    into: indexCoercionType
                    at: message position) unwrapSysmelValue.

            "Zero-based into one based"
            message selector == #subscriptAt: ifTrue: [
                index := index + 1
            ].

            ^ (SYMLArraySlotReference new
                container: variableData value value value;
                type: message valueType valueType;
                slotIndex: index;
                yourself) asSysmelValueInEnvironment: anEnvironment
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: node environment: environment position: aSourcePosition
            | variableData receiverType arrayType resultType index indexType coercionType coercionRule |

            "Check and coerce the receiver"
            variableData := node receiver semanticAnalysisInEnvironment: environment.
            receiverType := variableData evaluateReceiverTypeInEnvironment: environment.

            self assert: variableData type isReferenceType.
            arrayType := variableData type referenced.
            resultType := arrayType elementType ref.

            "Check the index type."
            index := node arguments first semanticAnalysisInEnvironment: environment.
            indexType := index evaluateTypeInEnvironment: environment.
            coercionType := indexType cleanValueType.

            coercionType isIntegerType ifFalse: [
                self error: 'Expected an integer for pointer element accessing.' at: aSourcePosition.
            ].
            coercionRule := indexType node: index coercedImplicitlyInto: coercionType at: node.

            "Create the analyzed message"
            ^ node copy
                metaMethod: self;
                receiver: variableData;
                arguments: {index};
                coercionType: {receiverType . coercionType};
                coercionRule: {nil . coercionRule };
                valueType: resultType;
                yourself
    }.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | arrayReference index |
            "Get the reference to the variable."
            arrayReference := messageNode receiver generateSSACodeWith: builder.

            "Convert the index"
            index := messageNode coercionRule second convertSSAValue: (messageNode arguments first generateSSACodeWith: builder)
                to: messageNode coercionType second
                with: builder at: messageNode.

            "One based indices into zero based"
            messageNode selector == #at: ifTrue: [
                index := builder sub: index with: (builder const: 1 type: index type)
            ].

            ^ builder getReference: arrayReference element: index
    }.
}.

}. // End of namespace Sysmel

namespace Smalltalk definition: {

// Meta circular hierarchy
gcclass ProtoObject.
gcclass Metaclass.

ProtoObject metaClassClass: Metaclass.

Compiler compilationTarget dynamicObjectType: ProtoObject.
alias Dynobject := ProtoObject.

gcclass Object superclass: ProtoObject.
    gcclass Behavior superclass: Object.
        gcclass ClassDescription superclass: Behavior.
            gcclass Class superclass: ClassDescription.
            gcclass Metaclass superclass: ClassDescription.

    // BooleanBit
    gcclass Boolean superclass: Object.
        gcclass True superclass: Boolean.
        gcclass False superclass: Boolean.

    // Undefind object
    gcclass UndefinedObject superclass: Object.

    // Numbers
    gcclass Magnitude superclass: Object.
        gcclass Number superclass: Magnitude.
            gcclass Float superclass: Number.
                gcclass BoxedFloat64 superclass: Float.
                gcclass SmallFloat64 superclass: Float.
            gcclass Integer superclass: Number.
                gcclass LargeInteger superclass: Integer.
                    gcclass LargeNegativeInteger superclass: LargeInteger.
                    gcclass LargePositiveInteger superclass: LargeInteger.
                gcclass SmallInteger superclass: Integer.


    gcclass GCLayout superclass: Object.

// Essential collections
gcclass Collection superclass: Object.
    gcclass HashedCollection superclass: Collection.
        gcclass Dictionary superclass: HashedCollection.
            gcclass MethodDictionary superclass: Dictionary.
    gcclass SequenceableCollection superclass: Collection.
        gcclass ArrayedCollection superclass: SequenceableCollection.
            gcclass Array superclass: ArrayedCollection.
            gcclass ByteArray superclass: ArrayedCollection.
            gcclass FloatArray superclass: ArrayedCollection.
            gcclass IntegerArray superclass: ArrayedCollection.
            gcclass WordArray superclass: ArrayedCollection.

            gcclass String superclass: ArrayedCollection.
                gcclass Symbol superclass: String.

// Methods
gcclass CompiledMethod superclass: Object.

// ProtoObject
ProtoObject type superclass: Class.

struct _ObjectHeader definition: {
    field __class public type: Void pointer. // TODO: Point into the vtable, instead of the class.

    if: UIntPointer instanceSize == 4 then: {
        // TODO: Support big-endian.
        field __padding public type: Behavior.
    }.

    // 32 bits: gc color, isPinned, isImmutable.
    field _ public bits: 5; type: UInt32.

    field __gcBits public type: UInt32; bits: 3.
    field __isPinned public type: UInt32; bits: 1.
    field __isImmutable public type: UInt32; bits: 1.
    field __identityHash public type: UInt32; bits: 22.

    // Variable data size
    field __variableDataSize public type: UInt32.
}.

ProtoObject definition: {
    // We use a fixed 16-byte object header, to be able to use SSE instructions.

    field __class private type: Behavior. // TODO: Point into the vtable, instead of the class.

    if: UIntPointer instanceSize == 4 then: {
        // TODO: Support big-endian.
        field __padding private type: Behavior.
    }.

    // 32 bits: gc color, isPinned, isImmutable.
    field _ private bits: 5; type: UInt32.

    field __gcBits private type: UInt32; bits: 3.
    field __isPinned private type: UInt32; bits: 1.
    field __isImmutable private type: UInt32; bits: 1.
    field __identityHash private type: UInt32; bits: 22.

    // Variable data size
    field __variableDataSize private type: UInt32.
}.

Behavior uses: Type; definition: {
    field superclass public type: Behavior.
    field methodDict public type: MethodDictionary.
    field gclayout public type: GCLayout.
    field slots public type: Array.

    field instanceDataSize public type: UInt32.
    field instanceDataAlignment public type: UInt32.

    field variableInstanceElementSize public type: UInt32.
    field variableInstanceElementAlignment public type: UInt32.

    // Notify about dynamic object type.
    message isDynamicObjectType -> BooleanBit := {
        return: true
    }.

    message isAnyDynamicObjectType -> BooleanBit := {
        return: self == Dynobject
    }.

    // The type of the instance is actually a dependent type because of the meta-circular hierarchy.
    type InstanceType uses: AnyValue;
        definition: {
        meta message asConcreteTypeForFunctionAnalysis -> Type := {
            return: Dynobject
        }.

        meta message asReturnTypeForReceiverType: (receiverType: _CompilerObjectType) argumentTypes: (argumentTypes: _CompilerObjectType) ::-> _CompilerObjectType := {
            return: receiverType instanceType
        }.
    }.

    (message basicNew -> InstanceType := {
        [[notInCompileTime]]
        return: (self basicNew: 0)
    }) evaluator: $$Pharo {
        evaluateMessageWithReceiver: receiver arguments: arguments environment: environment at: position
            ^ receiver makeInstance asSysmelValueInEnvironment: environment
    }.

    (message basicNew: (initialSize: UInt32) ::-> InstanceType := {
        [[notInCompileTime]]
        // Compute the object size.
        let objectSize := instanceDataSize + initialSize*variableInstanceElementSize.

        // Allocate the object memory.
        let allocatedObject := LibC malloc(objectSize) reinterpretCastTo: _ObjectHeader pointer.
        LibC memset(allocatedObject, 0, objectSize).

        // Set the allocated object class.
        allocatedObject value
            __class: (self reinterpretCastTo: Void pointer);
            __variableDataSize: (if: variableInstanceElementSize > 0 then: initialSize else: (0 castTo: UInt32)).

        // Convert the allocated object.
        return: (allocatedObject reinterpretCastTo: ProtoObject)
    }) evaluator: $$Pharo {
        evaluateMessageWithReceiver: receiver arguments: arguments environment: environment at: position
            ^ (receiver makeInstance: arguments first unwrapSysmelValue) asSysmelValueInEnvironment: environment
    }.

    message asReceiverType -> SelfType := {
        [[compileTime]]
        return: self
    }.

    message cvariadicCoercionType -> SelfType := {
        [[compileTime]]
        return: self
    }.

    message lookupSelector: (selector: ProtoObject) ::-> ProtoObject := {
        [[staticBinding]]
        [[nogc]]
        //LibC printf("Behavior %p >> lookupSelector: %p\n", self, selector).

        if: methodDict ~~ nil then: {
            let method := methodDict atOrNil: selector.
            if: method  ~~ nil then: {
                return: method
            }.
        }.

        if: superclass == nil then: {
            return: nil.
        }.

        return: (superclass lookupSelector: selector)
    }.
}.

Class definition: {
    field name protected type: Symbol.

    message name -> Symbol := {
        return: name
    }.
}.

Metaclass definition: {
    field thisClass protected type: Behavior.

    message isMetaType -> BooleanBit := {
        return: true
    }.
}.

// GCLayoutRecord
struct GCLayoutRecord definition: {
    field type public type: UIntPointer.
    field offset public type: UIntPointer.
    field size public type: UIntPointer.
}.

// GCLayout
GCLayout definition: {
    field records public type: GCLayoutRecord array.
}.

// String
String definition: {
    field __data protected type: UInt8 array.
}.

//-----------------------------------------------------------------------------
ProtoObject definition: {
    message class -> Behavior := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __class
    }.

    message identityHash -> UInt32 := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __identityHash
    }.

    (message == (other: ProtoObject) -> BooleanBit := {
        [[compileTime]]
        [[staticBinding]]
        [[intrinsic: #"dynobject.identityEquals"]]
    }) evaluator: $$Pharo {
        evaluateMessageWithReceiver: receiver arguments: arguments environment: environment at: position
            ^ (receiver unwrapSysmelValue == arguments first unwrapSysmelValue) asSysmelValueInEnvironment: environment
    }.

    message ~~ (other: ProtoObject) -> BooleanBit := {
        [[compileTime]]
        [[staticBinding]]
        [[intrinsic: #"dynobject.identityNotEquals"]]
    }.
}.

//-----------------------------------------------------------------------------
// Compiled method

CompiledMethod definition: {
    field entryPoint type: Void pointer.
    field __literals protected type: ProtoObject array.

    message entryPoint -> Void pointer := {
        [[staticBinding]]
        [[nogc]]
        return: entryPoint
    }.

    message entryPoint:(newEntryPoint: Void pointer)  ::-> Void pointer := {
        [[staticBinding]]
        [[nogc]]
        return: entryPoint
    }.
}.

//-----------------------------------------------------------------------------
// Important collections
Array definition: {
    field __data protected type: ProtoObject array.

    message basicSize -> UInt32 := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __data size
    }.

    message basicAt: (index: UInt32) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: (__data at: index)
    }.

    message basicAt: (index: Int32) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: (__data at: index)
    }.

    message basicAt: (index: UInt32) put: (value: ProtoObject) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        (__data at: index) := value.
        return: value
    }.

    message basicAt: (index: Int32) put: (value: ProtoObject) ::-> ProtoObject := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        (__data at: index) := value.
        return: value
    }.

    message subscriptAt: (index: Int32) ::-> ProtoObject ref := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __data[index]
    }.

    message subscriptAt: (index: UInt32) ::-> ProtoObject ref := {
        [[compileTime]]
        [[staticBinding]]
        [[nogc]]
        return: __data[index]
    }.
}.

HashedCollection definition: {
    field tally protected type: UIntPointer.
    field array protected type: Array.
}.

MethodDictionary definition: {
    field values protected type: Array.

    message initializeForCapacity: (initialCapacity: UInt32) ::-> SelfType := {
        tally := 0.
        array := Array basicNew: initialCapacity.
        values := Array basicNew: initialCapacity.
        return: self
    }.

    message scanFor: (key: ProtoObject) ::-> Int32 := {
        [[staticBinding]]
        [[nogc]]

        // Make sure we at least have a size.
        let keyCount := array basicSize. // TODO: Fix these casts.
        if: keyCount = 0 then: {
            return: -1
        }.

        // Find the natural key slot.
        let keySlot := key identityHash % array basicSize.

        // Perform linear probing.
        let i := keySlot.
        while: i < keyCount do: {
            let slotKey := array[i].
            if: slotKey == key || slotKey == nil then: {
                return: (i castTo: Int32)
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let slotKey := array[i].
            if: slotKey == key || slotKey == nil then: {
                return: (i castTo: Int32)
            }.
        } continueWith: { i := i + 1 }.

        return: -1
    }.

    message at: (key: ProtoObject) putNoSpaceCheck: (value: ProtoObject) ::-> SelfType := {
        [[staticBinding]]
        let slot := self scanFor: key.
        if: slot < 0 then: {
            return: self
        }.

        array[slot] := key.
        values[slot] := value.
        tally := tally + 1.
        return: self
    }.

    message atOrNil: (key: ProtoObject) ::-> ProtoObject := {
        [[staticBinding]]
        [[nogc]]
        // LibC printf("atOrNil: %p | tally %zu array [%d]%p values [%d]%p\n", key, tally, array basicSize, array, values basicSize, values).
        let slot := self scanFor: key.
        if: slot < 0 then: {
            return: nil
        }.

        //LibC printf("Found key %p in slot %d\n", array[slot], slot).
        return: values[slot]
    }.
}.

//-----------------------------------------------------------------------------
// Literals
let literalConversionRule := `'{

    evaluation: $$Pharo {
        value: value into: targetType at: coercionPosition
            "Literal -> Object eval"
            ^ (value value asLiteralObjectProxyWithType: targetType) sysmelValueWithType: targetType inEnvironment: value environment
    }.

    codeGeneration: $$Pharo {
        convertSSAValue: sourceValue to: targetType with: builder at: messageNode
            ^ builder addDynamicLiteral: sourceValue
    }.
}.

_LiteralSymbol conversionTo: Symbol doOn: literalConversionRule.
_LiteralString conversionTo: String doOn: literalConversionRule.
_LiteralInteger conversionTo: Integer doOn: literalConversionRule.
_LiteralFloat conversionTo: Float doOn: literalConversionRule.

//-----------------------------------------------------------------------------
// Normal message lookup
namespace Runtime definition: {
function messageLookupFromBehavior(behavior: Behavior, object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) -> Void pointer := {
    [[nogc]]
    //LibC printf("messageLookupFromBehavior behavior %p object %p selector %p\n", behavior, object, selector).
    let method := behavior lookupSelector: selector.

    if: method == nil then: {
        if: selector == #doesNotUnderstand: then: {
            LibC printf("Fatal error: Failed to lookup doesNotUnderstand:\n").
            LibC abort().
        }.

        return: fallbackTrampoline
    }.

    let compiledMethod := method castTo: CompiledMethod.
    //LibC printf("Found method: %p entryPoint: %p\n", compiledMethod, compiledMethod entryPoint).
    return: compiledMethod entryPoint
}.

function normalMessageLookup(object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) -> Void pointer := {
    [[nogc]]
    //LibC printf("normalMessageLookup object %p selector %p fallbackTrampoline %p\n", object, selector, fallbackTrampoline).
    return: messageLookupFromBehavior(object class, object, selector, fallbackTrampoline).
}.

Compiler compilationTarget objectModel
    sysmelMessageLookupFunction: normalMessageLookup;
    arrayClass: Array;
    byteArrayClass: ByteArray;
    compiledMethodClass: CompiledMethod;
    dictionaryClass: Dictionary;
    methodDictionaryClass: MethodDictionary;
    symbolClass: Symbol;
    stringClass: String;
    yourself
}.

}.
