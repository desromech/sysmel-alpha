namespace Smalltalk definition: {

LiteralVariable definition: {
    method setupProgramEntityParent: (theParent: ProgramEntity) fromModule: (theModule: ModuleInformation) ::=> Void := {
    }.
}.

CompiledMethod definition: {
    method setupProgramEntityParent: (theParent: ProgramEntity) fromModule: (theModule: ModuleInformation) ::=> Void := {
    }.
}.

ProgramEntity definition: {
    method setupProgramEntityParent: (theParent: ProgramEntity) fromModule: (theModule: ModuleInformation) ::=> Void := {
        parent := theParent.
    }.
}.

ModuleDefinedProgramEntity definition: {
    method setupProgramEntityParent: (theParent: ProgramEntity) fromModule: (theModule: ModuleInformation) ::=> Void := {
        parent := theParent.
        module := theModule.
    }.
}.

ModuleInformation definition: {

    method allExtensionsDo: aBlock ::=> Void := {
        extensionMacros ifNotNil: {
            extensionMacros do: aBlock
        }.

        extensionOverloadedMethods ifNotNil: {
            extensionOverloadedMethods do: aBlock
        }.

        extensionMethods ifNotNil: {
            extensionMethods do: aBlock
        }.
    }.

    method startUp => Void := {
        ##Stdn stdout << "Module startup: " << name; nl.
        ## Fix the parent relationships.
        Smalltalk Runtime withReflectionLockedWrite: {
            parent := nil.
            globalNamespace ifNotNil: {
                globalNamespace setupProgramEntityParent: self fromModule: self.
            }.

            ## Apply all of the extensions.
            self allExtensionsDo: {:each :: Void | each apply }
        }.
    }.

    method shutDown => Void  := {
        ##Stdn stdout << "Module " << name << " shutDown called."; nl
    }.
}.

ModuleNamespaceInformation definition: {
    method setupProgramEntityParent: (theParent: ProgramEntity) fromModule: (theModule: ModuleInformation) ::=> Void := {
        name ifNotNil: {
            theParent == theModule ifTrue: {
                sharedNamespace := NamespaceInformation globalNamespace.
            } ifFalse: {
                sharedNamespace := (theParent sharedNamespace reinterpretCastTo: NamespaceInformation)
                    getOrCreateSharedNamespaceNamed: name
            }.

            sharedNamespace addModuleNamespaceInformation: self.
            children do: {:each :: Void |
                ## Stdn stdout << "Namespace child " << each; nl.
                each setupProgramEntityParent: self fromModule: theModule.
            }
        }.

        super setupProgramEntityParent: theParent fromModule: theModule.

    }.

}.

NamespaceInformation definition: {
    meta definition: {
        let GlobalNamespaceSingleton mutable type: NamespaceInformation.

        method globalNamespace => NamespaceInformation := {
            ## TODO: Use an once flag here.
            GlobalNamespaceSingleton ifNil: {
                GlobalNamespaceSingleton := NamespaceInformation new.
                GlobalNamespaceSingleton name: #__global.
            }.

            GlobalNamespaceSingleton
        }.
    }.

    method initialize := {
        moduleNamespaces := OrderedCollection new.
        children := OrderedCollection new.
        childrenTable := Dictionary new.
        self
    }.

    method addModuleNamespaceInformation: (moduleNamespace: ModuleNamespaceInformation) ::=> Void := {
        moduleNamespaces add: moduleNamespace
    }.

    method removeModuleNamespaceInformation: (moduleNamespace: ModuleNamespaceInformation) ::=> Void := {
        moduleNamespaces remove: moduleNamespace
    }.

    method getOrCreateSharedNamespaceNamed: (childName: Symbol) ::=> NamespaceInformation := {
        (childrenTable at: childName ifAbsentPut: { :: ProtoObject |
            let newChild := NamespaceInformation new name: childName; yourself.
            children add: newChild.
            newChild
        }) reinterpretCastTo: NamespaceInformation.
    }.

    method associationAt: key
        := self associationAt: key ifAbsent: {:: Void | self errorKeyNotFound: key}.

    method associationAt: key ifAbsent: aBlock := {
        Smalltalk Runtime withReflectionLockedRead: {
            moduleNamespaces do: {:eachModuleNamespace :: Void |
                eachModuleNamespace localSymbolTable associationAt: key ifPresent: {:found :: Void |
                    return: found
                }
            }.
        }.

        return: aBlock value
    }.
}.

ProgramEntityExtensionElement definition: {
    method printOn: aStream := {
        super printOn: aStream.
        aStream nextPutAll: " extendedParent: "; print: extendedParent;
        	  nextPutAll: " name: "; print: name;
              nextPutAll: " extension: "; print: extension.
    }.
}.

ExtensionMacroMessage definition: {
    method apply := {
        ##Stdn stdout << "TODO: Apply " << self; nl.
        self
    }.
}.

ExtensionOverloadedMethod definition: {
    method apply := {
        ##Stdn stdout << "TODO: Apply " << self; nl.
        self
    }.
}.

ExtensionMethod definition: {
    method apply := {
        ##Stdn stdout << "Apply " << self; nl.
        extendedParent methodDict at: name put: extension.
        self
    }.
}.

namespace Runtime definition: {

function callModuleStartUp(module: ModuleInformation) => Void := {
    module startUp
}.

function callModuleShutdown(module: ModuleInformation) => Void := {
    module shutDown
}.

Compiler compilationTarget managedObjectModel
    moduleStartUpFunction: callModuleStartUp;
    moduleShutDownFunction: callModuleShutdown.
}. ## End of namespace Runtime

}. ## End of namespace Smalltalk
