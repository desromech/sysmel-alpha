namespace Smalltalk definition: {

LargeInteger definition: {
	public field __data type: ProtoObject gcclassVariableDataArray.
}.

BoxedFloat64 definition: {
	public field __float64Value type: Float64.
}.

namespace ObjectModel definition: {
compileTimeIf: UIntPointer instanceSize = 4 then: {
	compileTimeConstant SmallIntegerMinValue := #*(1<<31) negated*# -1073741824.
	compileTimeConstant SmallIntegerMaxValue := #*(1<<31)-1*# 1073741823.

	function encodeSmallInteger(v: IntPointer) => SmallInteger
		:= (v << 1) | 1 reinterpretCastTo: SmallInteger.

	function uint32ToCharacter(v: UInt32) => Character
		:= (v << 2) | 2 reinterpretCastTo: Character.

	function int32ToInteger(v: Int32) => Integer := {
		SmallIntegerMinValue <= v && v <= SmallIntegerMaxValue ifTrue: {
			return: encodeSmallInteger(v castTo: IntPointer)
		}.

		v < 0 ifTrue: {
			let largeNegativeInteger := LargeNegativeInteger basicNew: 4.
			let spilledValue mutable := v negated.
			StdNative memcpy(largeNegativeInteger __data[0] address, spilledValue address, 4).
			return: largeNegativeInteger
		} ifFalse: {
			let largePositiveInteger := LargePositiveInteger basicNew: 4.
			let spilledValue mutable := v.
			StdNative memcpy(largePositiveInteger __data[0] address, spilledValue address, 8).
			return: largePositiveInteger
		}.
	}.

	function uint32ToInteger(v: UInt32) => Integer := {
		v <= SmallIntegerMaxValue ifTrue: {
			return: encodeSmallInteger(v castTo: IntPointer)
		}.

		return: nil
	}.

	function float64ToFloat(v: Float64) => Float
		:= BoxedFloat64 basicNew
			__float64Value: v;
			yourself
} else: {
	compileTimeConstant SmallIntegerMinValue := #*(1<<60) negated*# -1152921504606846976.
	compileTimeConstant SmallIntegerMaxValue := #*(1<<60)-1*# 1152921504606846975.

	function encodeSmallInteger(v: IntPointer) => SmallInteger
		:= (v << 3) | 1 reinterpretCastTo: SmallInteger.

	function uint32ToCharacter(v: UInt32) => Character
		:= ((v castTo: UIntPointer) << 3) | 2 reinterpretCastTo: Character.

	function int32ToInteger(v: Int32) => Integer
		:= encodeSmallInteger(v).

	function uint32ToInteger(v: UInt32) => Integer
		:= encodeSmallInteger(v).

	function float64ToFloat(v: Float64) => Float := {
		BoxedFloat64 basicNew
			__float64Value: v;
			yourself
	}.
}.

function int64ToInteger(v: Int64) => Integer := {
	SmallIntegerMinValue <= v && v <= SmallIntegerMaxValue ifTrue: {
		return: encodeSmallInteger(v castTo: IntPointer)
	}.

	v < 0 ifTrue: {
		let largeNegativeInteger := LargeNegativeInteger basicNew: 8.
		let spilledValue mutable := v negated.
		StdNative memcpy(largeNegativeInteger __data[0] address, spilledValue address, 8).
		return: largeNegativeInteger
	} ifFalse: {
		let largePositiveInteger := LargePositiveInteger basicNew: 8.
		let spilledValue mutable := v.
		StdNative memcpy(largePositiveInteger __data[0] address, spilledValue address, 8).
		return: largePositiveInteger
	}.
}.

function uint64ToInteger(v: UInt64) => Integer := {
	v <= SmallIntegerMaxValue ifTrue: {
		return: encodeSmallInteger(v castTo: IntPointer)
	}.

	let largePositiveInteger := LargePositiveInteger basicNew: 8.
	let spilledValue mutable := v.
	StdNative memcpy(largePositiveInteger __data[0] address, spilledValue address, 8).
	return: largePositiveInteger
}.

function objectToUInt32(object: ProtoObject) => UInt32
	:= object asUInt32.

function objectToInt32(object: ProtoObject) => Int32
	:= object asInt32.

function objectToUInt64(object: ProtoObject) => UInt64
	:= object asUInt64.

function objectToInt64(object: ProtoObject) => Int64
	:= object asInt64.

function objectToChar32(object: ProtoObject) => Char32
	:= object asChar32.

function objectToFloat64(object: ProtoObject) => Float64
	:= object asFloat64.

Compiler compilationTarget managedObjectModel
    ## Primitive integer <-> Integer object.
	int32ToIntegerFunction: int32ToInteger;
	uint32ToIntegerFunction: uint32ToInteger;
	int64ToIntegerFunction: int64ToInteger;
	uint64ToIntegerFunction: uint64ToInteger;

	objectToUInt32Function: objectToUInt32;
	objectToInt32Function: objectToInt32;
	objectToUInt64Function: objectToUInt64;
	objectToInt64Function: objectToInt64;

    ## Primitive character <-> Integer object.
	uint32ToCharacterFunction: uint32ToCharacter;
	objectToChar32Function: objectToChar32;

    ## Primitive float <-> Float object.
	float64ToFloatFunction: float64ToFloat;
	objectToFloat64Function: objectToFloat64;
	yourself.
}.


ProtoObject extend: {
	method asInt32 => Int32 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asUInt32 => UInt32 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asInt64 => Int64 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asUInt64 => UInt64 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asFloat64 => Float64 := {
		CannotPerformCastError new signal.
		return: 0
	}.

	method asChar32 => Char32 := {
		CannotPerformCastError new signal.
		return: 0
	}.

}.

Object extend: {
    method isNumber := false.
    method isInteger := false.
    method isFraction := false.
    method isFloat := false.
}.

Number extend: {
    method isNumber := true.

    method + aNumber := {
        StdNative fatalError: "Unimplemented Number >> #+".
		self
    }.
}.

Integer extend: {
    method isInteger := true.

    method + aNumber := {
        super + aNumber
    }.
}.

Fraction extend: {
    method isFraction := true.

    method + aNumber := {
        super + aNumber
    }.
}.

SmallInteger extend: {
	method asInt32 => Int32
		:= self __decodeSmallInteger castTo: Int32.

	method asUInt32 => UInt32
		:= self __decodeSmallInteger castTo: UInt32.

	method asInt64 => Int64
		:= self __decodeSmallInteger castTo: Int64.

	method asUInt64 => UInt64
		:= self __decodeSmallInteger castTo: UInt64.

	method asFloat64 => Float64
		:= self __decodeSmallInteger castTo: Float64.

	method asChar32 => Char32
		:= self __decodeSmallInteger castTo: Char32.

    method + aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a + b
		}.

		aNumber __isCharacter ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeCharacter.
			return: (a + b castTo: Char32)
		}.

        super + aNumber
    }.

    method - aNumber := {
		aNumber __isSmallInteger ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeSmallInteger.
			return: a - b
		}.

		aNumber __isCharacter ifTrue: {
			let a := self __decodeSmallInteger.
			let b := aNumber __decodeCharacter.
			return: (a - b castTo: Char32)
		}.

        super - aNumber
    }.

}.

Float extend: {
    method isFloat := true.

    method + aNumber := {
        super + aNumber
    }.
}.
}. ## End of namespace Smalltalk
