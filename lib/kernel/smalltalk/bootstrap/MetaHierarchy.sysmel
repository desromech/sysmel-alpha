## The most essential declarations.
namespace Smalltalk definition: {

gcclass ProtoObject.
gcclass Metaclass.

ProtoObject metaClassClass: Metaclass.
Metaclass metaClassClass: Metaclass.

Compiler compilationTarget dynamicObjectType: ProtoObject.
}.

namespace SysmelKernel definition: {
	compileTimeConstant Dynobject := Smalltalk ProtoObject.
}.

namespace Smalltalk definition: {

gcclass Object superclass: ProtoObject.
    gcclass Behavior superclass: Object.
        gcclass ClassDescription superclass: Behavior.
            gcclass Class superclass: ClassDescription.
            gcclass Metaclass superclass: ClassDescription.

    ## Boolean8
    gcclass Boolean superclass: Object.
        gcclass True superclass: Boolean.
        gcclass False superclass: Boolean.

    ## Undefined object
    gcclass UndefinedObject superclass: Object.

    ## Numbers
    gcclass Magnitude superclass: Object.
        gcclass Number superclass: Magnitude.
            gcclass Float superclass: Number.
                gcclass BoxedFloat64 superclass: Float.
                gcclass SmallFloat64 superclass: Float.
			gcclass Fraction superclass: Number.
            gcclass Integer superclass: Number.
                gcclass LargeInteger superclass: Integer.
                    gcclass LargeNegativeInteger superclass: LargeInteger.
                    gcclass LargePositiveInteger superclass: LargeInteger.
                gcclass SmallInteger superclass: Integer.
		gcclass Character superclass: Magnitude.


    gcclass GCLayout superclass: Object.

## Essential collections
gcclass Collection superclass: Object.
    gcclass HashedCollection superclass: Collection.
        gcclass Dictionary superclass: HashedCollection.
            gcclass MethodDictionary superclass: Dictionary.
    gcclass SequenceableCollection superclass: Collection.
        gcclass ArrayedCollection superclass: SequenceableCollection.
            gcclass Array superclass: ArrayedCollection.
            gcclass ByteArray superclass: ArrayedCollection.
            gcclass FloatArray superclass: ArrayedCollection.
            gcclass IntegerArray superclass: ArrayedCollection.
            gcclass WordArray superclass: ArrayedCollection.

            gcclass String superclass: ArrayedCollection.
                gcclass Symbol superclass: String.

## Methods
gcclass CompiledMethod superclass: Object.

## ProtoObject
ProtoObject type supertype: Class.

ProtoObject definition: {
    ## We use a fixed 16-byte object header, to be able to use SSE instructions.
    (SelfType addMainVTableFieldNamed: #__vtable) private.

    if: UIntPointer instanceSize == 4 then: {
        ## TODO: Support big-endian.
        field __padding private type: UInt32.
    }.

    ## 32 bits: gc color, isPinned, isImmutable.
    field _ private bits: 5; type: UInt32.

    field __gcBits private type: UInt32; bits: 3.
    field __isPinned private type: UInt32; bits: 1.
    field __isImmutable private type: UInt32; bits: 1.
    field __identityHash private type: UInt32; bits: 22.

    ## Variable data size
    field __variableDataSize private type: UInt32.
}.

Behavior definition: {
    field superclass public type: Behavior.
    field methodDict public type: MethodDictionary.
    field gclayout public type: GCLayout.
    field basicInitializeFunctionPointer public type: _BasicInitializeFunctionPointerType.
    field slots public type: Array.

    field instanceDataSize public type: UInt32.
    field instanceDataAlignment public type: UInt32.

    field variableInstanceElementSize public type: UInt32.
    field variableInstanceElementAlignment public type: UInt32.

    ## The type of the instance is actually a dependent type because of the meta-circular hierarchy.
    message basicNew => _DependentInstanceType := {
		<intrinsic: #"gc.object.basicNew">
        return: (self basicNew: 0)
    }.

    message basicNew: (initialSize: UInt32) ::=> _DependentInstanceType := {
		<intrinsic: #"gc.object.basicNew.variable">
        ## Compute the object size.
        let objectSize := instanceDataSize + initialSize*variableInstanceElementSize.

        ## Allocate the object memory.
        let allocatedObject := globalSysmelGC
            allocate: objectSize
            variableDataSize: (if: variableInstanceElementSize > 0 then: initialSize else: 0)
            initializingWith: basicInitializeFunctionPointer.

        ## Convert the allocated object.
        return: (allocatedObject reinterpretCastTo: ProtoObject)
    }.

    message lookupSelector: (selector: ProtoObject) ::=> ProtoObject := {
        <staticBinding>
        <nogc>
        ##LibC printf("Behavior %p >> lookupSelector: %p\n", self, selector).

        if: methodDict ~~ nil then: {
            let method := methodDict atOrNil: selector.
            if: method  ~~ nil then: {
                return: method
            }.
        }.

        if: superclass == nil then: {
            return: nil.
        }.

        return: (superclass lookupSelector: selector)
    }.
}.

Class definition: {
    field name protected type: Symbol.

    message name => Symbol := {
        return: name
    }.
}.

Metaclass definition: {
    field thisClass protected type: Behavior.

    message isMetaType => Boolean8 := {
        return: true
    }.
}.

## GCLayoutRecord
struct GCLayoutRecord definition: {
    field type public type: UIntPointer.
    field offset public type: UIntPointer.
    field size public type: UIntPointer.
}.

## GCLayout
GCLayout definition: {
    field records public type: GCLayoutRecord array.
}.

## String
String definition: {
    field __data protected type: UInt8 array.
}.

## Table with the immediate clases.
if: UIntPointer instanceSize == 4 then: {
	global immediateClassTable type: (Behavior array: 4) := (
		UndefinedObject, ## 2r00
		SmallInteger,	 ## 2r01
		Character,	 	 ## 2r10
		SmallInteger,	 ## 2r11
	).
} else: {
	global immediateClassTable type: (Behavior array: 8) := (
		UndefinedObject, ## 2r000
		SmallInteger,	 ## 2r001
		Character,	 	 ## 2r010
		UndefinedObject, ## 2r011 (Reserved)

		SmallFloat64, 	 ## 2r100
		UndefinedObject, ## 2r101 (Reserved)
		UndefinedObject, ## 2r110 (Reserved)
		UndefinedObject, ## 2r111 (Reserved)
	).
}.

##-----------------------------------------------------------------------------
ProtoObject definition: {

    if: UIntPointer instanceSize = 4 then: {
        message __isImmediateValue => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self == nil || (((self reinterpretCastTo: UIntPointer) & 3) ~= 0)
        }.

        message __immediateTypeTag => UInt8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            (self reinterpretCastTo: UIntPointer) >> 2 castTo: UInt8
        }.
    } else: {
        message __isImmediateValue => Boolean8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            self == nil || (((self reinterpretCastTo: UIntPointer) & 7) ~= 0)
        }.

        message __immediateTypeTag => UInt8 := {
            <notInCompileTime>
            <staticBinding>
            <nogc>
            (self reinterpretCastTo: UIntPointer) >> 3 castTo: UInt8
        }.
    }.

    message class => Behavior := {
        <staticBinding>
        <nogc>
        <intrinsic: #"dynobject.class">
        self __isImmediateValue ifTrue: {
            return: immediateClassTable[self __immediateTypeTag].
        }.

        __vtable[-1] reinterpretCastTo: Behavior
    }.

    message identityHash => UInt32 := {
        <staticBinding>
        <nogc>
        <intrinsic: #"dynobject.identityHash">
        self __isImmediateValue ifTrue: {
            (self reinterpretCastTo: UIntPointer) castTo: UInt32.
        } ifFalse: {
            __identityHash
        }
    }.

    message == (other: ProtoObject) => Boolean8 := {
        <staticBinding>
        <nogc>
		<intrinsic: #"dynobject.identityEquals">
		## Identity equality message is also defined as a macro, so lets just exploit its previous definition.
		self == other
    }.

    message ~~ (other: ProtoObject) => Boolean8 := {
        <staticBinding>
        <nogc>
		<intrinsic: #"dynobject.identityNotEquals">
		## Identity equality message is also defined as a macro, so lets just exploit its previous definition.
		self ~~ other
    }.
}.

##-----------------------------------------------------------------------------
## Compiled method

CompiledMethod definition: {
    field entryPoint type: Void pointer.
    field __literals protected type: ProtoObject array.

    message entryPoint => Void pointer := {
        <staticBinding>
        <nogc>
        return: entryPoint
    }.

    message entryPoint:(newEntryPoint: Void pointer)  ::=> Void pointer := {
        <staticBinding>
        <nogc>
        return: entryPoint
    }.
}.

##-----------------------------------------------------------------------------
## Important collections
Array definition: {
    field __data protected type: ProtoObject array.

    message basicSize => UInt32 := {
        <compileTime>
        <staticBinding>
        <nogc>
        return: __data size
    }.

    message basicAt: (index: UInt32) ::=> ProtoObject := {
        <compileTime>
        <staticBinding>
        <nogc>
        return: (__data at: index)
    }.

    message basicAt: (index: Int32) ::=> ProtoObject := {
        <compileTime>
        <staticBinding>
        <nogc>
        return: (__data at: index)
    }.

    message basicAt: (index: UInt32) put: (value: ProtoObject) ::=> ProtoObject := {
        <compileTime>
        <staticBinding>
        <nogc>
        (__data at: index) := value.
        return: value
    }.

    message basicAt: (index: Int32) put: (value: ProtoObject) ::=> ProtoObject := {
        <compileTime>
        <staticBinding>
        <nogc>
        (__data at: index) := value.
        return: value
    }.

    message subscriptAt: (index: Int32) ::=> ProtoObject ref := {
        <compileTime>
        <staticBinding>
        <nogc>
        return: __data[index]
    }.

    message subscriptAt: (index: UInt32) ::=> ProtoObject ref := {
        <compileTime>
        <staticBinding>
        <nogc>
        return: __data[index]
    }.
}.

HashedCollection definition: {
    field tally protected type: UIntPointer.
    field array protected type: Array.
}.

MethodDictionary definition: {
    field values protected type: Array.

    message initializeForCapacity: (initialCapacity: UInt32) ::=> SelfType := {
        tally := 0.
        array := Array basicNew: initialCapacity.
        values := Array basicNew: initialCapacity.
        return: self
    }.

    message scanFor: (key: ProtoObject) ::=> Int32 := {
        <staticBinding>
        <nogc>

        ## Make sure we at least have a size.
        let keyCount := array basicSize. ## TODO: Fix these casts.
        if: keyCount = 0 then: {
            return: -1
        }.

        ## Find the natural key slot.
        let keySlot := key identityHash % array basicSize.

        ## Perform linear probing.
        let i mutable := keySlot.
        while: i < keyCount do: {
            let slotKey := array[i].
            if: slotKey == key || slotKey == nil then: {
                return: (i castTo: Int32)
            }.
        } continueWith: { i := i + 1 }.

        i := 0.
        while: i < keySlot do: {
            let slotKey := array[i].
            if: slotKey == key || slotKey == nil then: {
                return: (i castTo: Int32)
            }.
        } continueWith: { i := i + 1 }.

        return: -1
    }.

    message at: (key: ProtoObject) putNoSpaceCheck: (value: ProtoObject) ::=> SelfType := {
        <staticBinding>
        let slot := self scanFor: key.
        if: slot < 0 then: {
            return: self
        }.

        array[slot] := key.
        values[slot] := value.
        tally := tally + 1.
        return: self
    }.

    message atOrNil: (key: ProtoObject) ::=> ProtoObject := {
        <staticBinding>
        <nogc>
        ## LibC printf("atOrNil: %p | tally %zu array [%d]%p values [%d]%p\n", key, tally, array basicSize, array, values basicSize, values).
        let slot := self scanFor: key.
        if: slot < 0 then: {
            return: nil
        }.

        ##LibC printf("Found key %p in slot %d\n", array[slot], slot).
        return: values[slot]
    }.
}.

##-----------------------------------------------------------------------------
## Normal message lookup
namespace Runtime definition: {
function messageLookupFromBehavior(behavior: Behavior, object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) => Void pointer := {
    <nogc>
    ##LibC printf("messageLookupFromBehavior behavior %p object %p selector %p\n", behavior, object, selector).
    let method := behavior lookupSelector: selector.

    if: method == nil then: {
        if: selector == #doesNotUnderstand: then: {
            LibC printf("Fatal error: Failed to lookup doesNotUnderstand:\n").
            LibC abort().
        }.

        return: fallbackTrampoline
    }.

    let compiledMethod := method reinterpretCastTo: CompiledMethod.
    ##LibC printf("Found method: %p entryPoint: %p\n", compiledMethod, compiledMethod entryPoint).
    return: compiledMethod entryPoint
}.

function normalMessageLookup(object: ProtoObject, selector: Object, fallbackTrampoline: Void pointer) => Void pointer := {
    <nogc>
    ##LibC printf("normalMessageLookup object %p selector %p fallbackTrampoline %p\n", object, selector, fallbackTrampoline).
    return: messageLookupFromBehavior(object class, object, selector, fallbackTrampoline).
}.

Compiler compilationTarget managedObjectModel
    messageLookupFunction: normalMessageLookup;
    arrayClass: Array;
    byteArrayClass: ByteArray;
    compiledMethodClass: CompiledMethod;
    dictionaryClass: Dictionary;
    methodDictionaryClass: MethodDictionary;
    symbolClass: Symbol;
    stringClass: String;
	integerClass: Integer;
	floatClass: Float;
	boolClass: Boolean;
	trueClass: True;
	falseClass: False;
    yourself
}.

}.
