namespace Smalltalk definition: {
Stream definition: {
    meta definition: {
        method new
            := self error: "Streams are created with on: and with:"
    }.

    method contents
        := self subclassResponsibility.

    method next
        := self subclassResponsibility.

    method next: (elementsToRead: UInt32) := {
        let result := Array new: elementsToRead.
        0 until: elementsToRead do: {:(UInt32)i :: Void |
            result[i] := self next
        }.
        result
    }.

    method nextPut: anObject
        := self subclassResponsibility.

    method nextPutAll: aCollection := {
        aCollection do: {:each :: Void |
            self nextPut: each
        }.
        aCollection
    }.
}.

#**
 * I am a positionable read stream for reading the content of a collection.
 * My implementation is ported from Pharo.
 *#
PositionableStream definition: {
    public field collection.
    protected field position type: UIntPointer.
    protected field readLimit type: UIntPointer.

    meta definition: {
        method on: aCollection
            := self new on: aCollection.
        method on: aCollection from: firstIndex to: lastIndex
            := self new on: aCollection from: firstIndex to: lastIndex.
    }.

    method print: anObject := {
        anObject printOn: self.
        self
    }.

    method on: aCollection := {
        collection := aCollection.
        position := 0.
        readLimit := aCollection size castTo: UIntPointer.
        self reset.
        self
    }.

    method reset := {
        position := 0.
        self
    }.

    method position
        := position.

    method contents := {
        return: (collection copyWithSize: (readLimit castTo: UInt32))
    }.
}.

#**
 * I am a write stream for generating the content of a collection.
 * My implementation is ported from Pharo.
 *#
WriteStream definition: {
    protected field writeLimit type: UIntPointer.

    method on: aCollection := {
        super on: aCollection.
        readLimit := 0.
        writeLimit := aCollection size.
    }.

    method contents := {
        readLimit := readLimit max: position.
        return: (collection copyWithSize: (readLimit castTo: UInt32))
    }.

    method nextPut: anObject := {
        position >= writeLimit ifTrue: {
            self growBy: 1.
        }.

        position := position + 1.
        collection at: position put: anObject.
        return: anObject
    }.

    method nextPutAll: aCollection := {
        aCollection class ~~ collection class ifTrue: {
            return: (super nextPutAll: aCollection)
        }.

        let newPosition := position + aCollection size.
        newPosition > writeLimit ifTrue: {
            self growBy: newPosition - writeLimit
        }.

        collection replaceFrom: position until: newPosition with: aCollection.

        position := newPosition.
        return: aCollection
    }.

    method growBy: (minimumRequired: UIntPointer) := {
        let growSize type: UIntPointer := collection size clampMin: 20 max: 1000000.
        collection := collection grownBy: (growSize max: minimumRequired).
        writeLimit := collection size.
        self
    }.
}.

LimitedWriteStream definition: {
    public field limit type: UIntPointer.
    public field limitBlock.

    meta definition: {
        method on: aCollection limit: anInteger limitBlock: aLimitBlock
            := self basicNew on: aCollection;
                limit: (anInteger castTo: UIntPointer);
                limitBlock: aLimitBlock;
                yourself.
    }.
}.

} ## End of namespace Smalltalk
