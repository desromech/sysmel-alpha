namespace Smalltalk definition: {
Object extend: {
	method isEmptyOrNil
		:= false.
}.

Collection definition: {
	method isEmpty
		:= self size == 0.

	method isNotEmpty
		:= self isEmpty not.

	method isEmptyOrNil
		:= self size == 0.
}.

UndefinedObject extend: {
	method isEmptyOrNil
		:= true.
}.

SequenceableCollection definition: {
	meta definition: {
		method streamSpecies
			:= self.

		method streamContents: unaryBlock
			:= self new: 100 streamContents: unaryBlock.

		method new: initialSize streamContents: unaryBlock := {
			let stream := WriteStream on: (self streamSpecies new: initialSize).
			unaryBlock value: stream.
			stream contents
		}.

		method streamContents: unaryBlock limitedTo: sizeLimit := {
			let stream mutable.
			stream := LimitedWriteStream
				on: (self streamSpecies new: (sizeLimit min: 100))
				limit: sizeLimit
				limitBlock: {:: Void | return: stream contents }.
			unaryBlock value: stream.
			stream contents
		}.
	}.

	method do: aBlock := {
		1 to: self size do: {:i :: Void|
			aBlock value: (self at: i)
		}.
		nil
	}.

	method doWithIndex: aBlock := {
		1 to: self size do: {:i :: Void|
			aBlock value: (self at: i) value: i
		}.
		nil
	}.

	method collect: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void|
			result at: i put: (aBlock value: (self at: i))
		}.
		result
	}.

	method collectWithIndex: aBlock := {
		let result := self species new: self size.
		1 to: self size do: {:i :: Void|
			result at: i put: (aBlock value: (self at: i) value: i)
		}.
		result
	}.

	method select: aPredicate := {
		self class new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifTrue: {
					stream nextPut: element
				}
			}
		}
	}.

	method reject: aPredicate := {
		self class new: self size streamContents: {:stream :: Void |
			1 to: self size do: {:i :: Void|
				let element := self at: i.
				(aPredicate value: element) ifFalse: {
					stream nextPut: element
				}
			}
		}
	}.

	method copyWithSize: (newSize: UInt32) := {
		let result := self species new: newSize.
		let copySize := newSize min: self size.
		1 to: copySize + 1 do: {:(UInt32)i :: Void |
			result at: i put: (self at: i)
		}.
		result
	}.

	method grownBy: (extraSize: UInt32)
		:= self copyWithSize: self size + extraSize.

	method replaceFrom: (startIndex: UInt32) until: (endIndex: UInt32) with: other := {
		startIndex until: endIndex do: {:(UInt32)i :: Void |
			self at: i + 1 put: (other at: i - startIndex + 1)
		}.
		self
	}.

	method -- other := {
		let mySize := self size.
		let otherSize := other size.
		let result := self copyWithSize: mySize + otherSize.
		result replaceFrom: mySize until: mySize + otherSize with: other.
		result
	}.
}.

String definition: {
	method beginsWith: prefix := {
		prefix class == String || prefix class == Symbol ifTrue: {
			let prefixString := prefix reinterpretCastTo: String.
			let mySize := __data size.
			let prefixSize := prefixString __private __data size.
			mySize < prefixSize ifTrue: {
				return: false.
			}.

			return: (StdNative memcmp(__data[0] address, prefixString __private __data [0] address, prefixSize) == 0)
		}.
		return: (super beginsWith: prefix)
	}.

	method endsWith: suffix := {
		suffix class == String || suffix class == Symbol ifTrue: {
			let suffixString := suffix reinterpretCastTo: String.
			let mySize := __data size.
			let suffixSize := suffixString __private __data size.
			mySize < suffixSize ifTrue: {
				return: false.
			}.

			return: (StdNative memcmp(__data[mySize - suffixSize] address, suffixString __private __data [0] address, suffixSize) == 0)
		}.
		return: (super endsWith: suffix)
	}.
}.

Symbol definition: {
	meta definition: {
		method streamSpecies
			:= String.
	}.

	method species := String.
}.

Behavior definition: {
	method subclasses := #().

	method subclassesDo: aBlock
		:= self subclasses do: aBlock.

	method allSubclassesDo: aBlock := {
		self subclassesDo: {:cls :: Void |
			aBlock value: cls.
			cls allSubclassesDo: aBlock
		}.
		self
	}.

	method withAllSubclassesDo: aBlock := {
		aBlock value: self.
		self allSubclassesDo: aBlock
	}.
}.

Class definition: {
	method classSide
		:= self class.

	method instanceSide
		:= self.
}.

Metaclass definition: {
	method classSide
		:= self.

	method instanceSide
		:= thisClass.

	method isMetaclassOfClassOrNil := {
		thisClass ifNil: { true }
			ifNotNil: {thisClass == Class }
	}.

	method subclassesDo: aBlock := {
		## Method taken from Pharo
		## Evaluate aBlock for each of the receiver's immediate subclasses.

		self isMetaclassOfClassOrNil ifFalse: {
			self instanceSide subclassesDo: { :each :: Void | aBlock value: each classSide }
		}.

		self
	}.
}.

}.
