Compiler topLevelScope useNamespace: namespace SysmelKernel.

namespace SysmelKernel definition: {

// Create and set the basic types. Some of these types are used everywhere by the
// compiler, so their declaration must be the first thing done.
Compiler compilationTarget
    metaType: type _MetaType;
    anyValueTrait: trait AnyValue;
    typeTrait: trait Type;
    tupleTypeTrait: trait TupleType;
    functionTypeTrait: trait FunctionType;
    structureTypeTrait: trait StructureType;
    unionTypeTrait: trait UnionType;
    classTypeTrait: trait ClassType;

    apsgNodeType: type _APSGNodeType;
    compilerObjectType: type _CompilerObjectType;
    dynamicObjectType: type _DynamicObject;
    incompleteType: type _IncompleteType;

    literalArrayType: type _LiteralArray;
    literalSymbolType: type _LiteralSymbol;
    literalStringType: type _LiteralString;
    literalIntegerType: type _LiteralInteger;
    literalFractionType: type _LiteralFraction;
    literalFloatType: type _LiteralFloat;

    voidType: type Void;
    booleanType: type Boolean;

    // Integer types
    int8Type: type Int8;
    uint8Type: type UInt8;

    int16Type: type Int16;
    uint16Type: type UInt16;

    int32Type: type Int32;
    uint32Type: type UInt32;

    int64Type: type Int64;
    uint64Type: type UInt64;

    charType: UInt8;

    // Floating point types
    float32Type: type Float32;
    float64Type: type Float64;

    yourself.

// The return macro is used extensively by the language.
macro selector: #return: doOn: {
    evaluation: $$Pharo {
        evaluateMessage: message inEnvironment: anEnvironment
        	| result convertedResult |
        	result := message arguments first evaluateInEnvironment: anEnvironment.
        	convertedResult := result coercedWithRule: message coercionRule intoType: message coercionType at: message.
        	SYMLValueReturnException new
        		value: convertedResult;
        		signal
    }.

    semanticAnalysis: $$Pharo {
        semanticAnalyzeMessage: message inEnvironment: environment at: aPosition
        	| expectedReturnType returnValue returnValueType coercionRule |
        	message arguments size ~= 1 ifTrue: [
        		self error: '#return: meta-method requires at least one argument.' at: aPosition
        	].

        	"Get the expected return type."
        	expectedReturnType := environment returnType.

        	"Get the return value"
        	returnValue := message arguments first semanticAnalysisInEnvironment: environment.
        	returnValue hasIncompleteSemanticAnalysis ifTrue: [
        		^ message copy
        			arguments: { returnValue };
        			metaMethod: self;
        			hasIncompleteSemanticAnalysis: true;
        			yourself
        	].

        	returnValueType := returnValue evaluateTypeInEnvironment: environment.

        	"Check the type of the return value."
        	coercionRule := returnValueType node: returnValue coercedImplicitlyInto: expectedReturnType at: aPosition.
        	^ message copy
        		arguments: { returnValue };
        		metaMethod: self;
        		coercionType: expectedReturnType;
        		coercionRule: coercionRule;
        		valueType: environment compilationTarget voidType;
        		yourself
    }.

    codeGeneration: $$Pharo {
        generateMessage: messageNode ssaCodeWith: builder
        	| value valueNode valueType returnType rawValue |
        	valueNode := messageNode arguments first.
        	valueType := valueNode type.

        	returnType := messageNode coercionType.
        	rawValue := valueNode generateSSACodeWith: builder.

        	^ returnType isVoidType ifTrue: [
        		builder returnVoid
        	] ifFalse: [
        		value := messageNode coercionRule convertSSAValue: rawValue to: returnType with: builder at: messageNode.
        		builder return: value
        	]
    }.
}.

// A generic type
trait AnyValue
definition: {
    // Add the yourself macro to rewrite to the receiver by default.
    macro selector: #yourself doOn: {
        semanticAnalysis: $$Pharo {
            semanticAnalyzeMessage: message inEnvironment: environment at: aPosition
                ^ message receiver semanticAnalysisInEnvironment: environment
        }.
    }.
}.

// The type meta type
trait Type definition: {
    message asReceiverType -> SelfType := {
        return: self
    }.

    message isType -> Boolean := {
        return: true
    }.

    message isCompilerObjectType -> Boolean := {
        return: false
    }.

    message isLiteralType -> Boolean := {
        return: false
    }.

    message isPrimitiveType -> Boolean := {
        return: false
    }.

    message isOpaqueType -> Boolean := {
        return: false
    }.

    message isBooleanType -> Boolean := {
        return: false
    }.

    message isNumericalType -> Boolean := {
        return: false
    }.

    message isIntegerType -> Boolean := {
        return: false
    }.

    message isFractionalType -> Boolean := {
        return: false
    }.

    message isFloatingPointType -> Boolean := {
        return: false
    }.

    message isPointerType -> Boolean := {
        return: false
    }.

    message isReferenceType -> Boolean := {
        return: false
    }.

    message isPointerOrReferenceType -> Boolean := {
        return: false
    }.

    message isTupleType -> Boolean := {
        return: false
    }.

    message isFunctionType -> Boolean := {
        return: false
    }.

    message isConstantType -> Boolean := {
        return: false
    }.

    message isVolatileType -> Boolean := {
        return: false
    }.

    message size -> _LiteralInteger := {
        return: 0
    }.

    message alignment -> _LiteralInteger := {
        return: 1
    }.

    message cleanType -> SelfType := {
        return: self
    }.

    message valueType -> SelfType := {
        return: self
    }.

    message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        self error: "Cannot generate default value of {1}" format: (self,self)
    }.

    message isReturnedThroughFirstArgument ::-> Boolean := {
        return: false
    }.
}.

AnyValue type uses: Type.

// Meta type
_MetaType uses: AnyValue type;
definition: {
    message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: Compiler compilationTarget int8Type ssaType)
    }.

    message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: value ssaValue
    }.
}.

// A literal type
trait LiteralType
    uses: AnyValue;
definition: {
    meta message isLiteralType -> Boolean := {
        return: true
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: value
    }.
}.

// A primitive type
trait PrimitiveType
    uses: AnyValue;
definition: {
    meta message isPrimitiveType -> Boolean := {
        return: true
    }.

    meta message alignment -> _LiteralInteger := {
        return: self size
    }.

}.

// An opaque type
trait OpaqueType
    uses: AnyValue;
definition: {
    meta message isOpaqueType -> Boolean := {
        return: true
    }
}.

// A numerical type
trait NumericalType uses: AnyValue;
definition: {
    meta message isNumericalType -> Boolean := {
        return: true
    }
}.

// An integer type
trait IntegerType uses: NumericalType;
definition: {
    meta message isIntegerType -> Boolean := {
        return: true
    }.

    meta message isSigned -> Boolean := {
        return: false
    }.

    meta message isUnsigned -> Boolean := {
        return: false
    }.
}.

trait SignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned -> Boolean := {
        return: true
    }.

    meta message isUnsigned -> Boolean := {
        return: false
    }.
}.

trait UnsignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned -> Boolean := {
        return: false
    }.

    meta message isUnsigned -> Boolean := {
        return: true
    }.
}.

trait PrimitiveIntegerType uses: (PrimitiveType, IntegerType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: 0 type: self ssaType)
    }.

    meta message defaultValue -> _CompilerObjectType := {
        return: 0
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: value unwrapSysmelValue type: self ssaType)
    }.
}.

trait PrimitiveUnsignedIntegerType uses: (PrimitiveIntegerType, UnsignedIntegerType).
trait PrimitiveSignedIntegerType uses: (PrimitiveIntegerType, SignedIntegerType).

// A boolean type
trait BooleanType uses: AnyValue;
definition: {
    meta message isBooleanType -> Boolean := {
        return: true
    }.
}.

// A fraction type
trait FractionalType uses: NumericalType;
definition: {
    meta message isFractionalType -> Boolean := {
        return: true
    }
}.

// A floating point type
trait FloatingPointType uses: NumericalType;
definition: {
    meta message isFloatingPointType -> Boolean := {
        return: true
    }
}.

// Primitive floating point
trait PrimitiveFloatingPointType uses: (PrimitiveType, FloatingPointType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: 0.0 type: self ssaType)
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: value unwrapSysmelValue type: self ssaType)
    }.

    meta message defaultValue -> _CompilerObjectType := {
        return: 0.0
    }.
}.

// Pointer type
trait PointerType
    uses: AnyValue;
definition: {
    meta message isPointerType -> Boolean := {
        return: true
    }.

    meta message isPointerOrReferenceType -> Boolean := {
        return: true
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.
}.

// Reference type
trait ReferenceType
    uses: AnyValue;
definition: {
    meta message isReferenceType -> Boolean := {
        return: true
    }.

    meta message isPointerOrReferenceType -> Boolean := {
        return: true
    }.
}.

// AnyValue composition

// Pointer type
template PointerTypeTemplate(P: Type)
    := type uses: PointerType;
definition: {
    meta message pointed -> _CompilerObjectType := {
        return: P
    }.

    meta message alignment -> _LiteralInteger := {
        return: Compiler compilationTarget pointerAlignment
    }.

    meta message size -> _LiteralInteger := {
        return: Compiler compilationTarget pointerSize
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: P ssaType)
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: P cleanType pointer
    }.

    meta message asPointerType ->_CompilerObjectType := {
        return: self
    }.

    meta message asReferenceType ->_CompilerObjectType := {
        return: P ref
    }.

    meta message sysmelMangledValue -> _CompilerObjectType := {
        return: P sysmelMangledValue -- #p
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (P printingName -- " pointer")
    }.
}.

AnyValue extend: {
    meta message pointer -> _CompilerObjectType := {
        return: PointerTypeTemplate(self)
    }
}.

// Reference type
template ReferenceTypeTemplate(R: Type)
    := type uses: ReferenceType;
definition: {
    meta message referenced -> _CompilerObjectType := {
        return: R
    }.

    meta message alignment -> _LiteralInteger := {
        return: Compiler compilationTarget pointerAlignment
    }.

    meta message size -> _LiteralInteger := {
        return: Compiler compilationTarget pointerSize
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: R ssaType)
    }.

    meta message valueType -> _CompilerObjectType := {
        return: R
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: R cleanType ref
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: R cvariadicCoercionType
    }.

    meta message lookReceiver: (receiver: _CompilerObjectType) symbol: (symbol: _CompilerObjectType) ifPresent: (ifPresentBlock: _CompilerObjectType)
        ::-> _CompilerObjectType := {
        return: (R lookReceiver: receiver symbol: symbol ifPresent: ifPresentBlock)
    }.

    meta message asPointerType ->_CompilerObjectType := {
        return: R pointer
    }.

    meta message asReferenceType -> _CompilerObjectType := {
        return: self
    }.

    meta message sysmelMangledValue -> _CompilerObjectType := {
        return: R sysmelMangledValue -- #r
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (R printingName -- " ref")
    }.

    // Reference evaluation
    SelfType conversionTo: R cleanType doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                "Reference evaluation"
                ^ value value value sysmelValueWithType: targetType inEnvironment: value environment
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                targetType isFunctionType ifTrue: [
                    ^ sourceValue
                ].

                ^ builder load: sourceValue
        }.
    }.

    SelfType conversionTo: R doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                "Reference evaluation"
                ^ value value value sysmelValueWithType: targetType inEnvironment: value environment
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                targetType isFunctionType ifTrue: [
                    ^ sourceValue
                ].

                ^ builder load: sourceValue
        }.
    }.
}.

AnyValue extend: {
    meta message ref -> _CompilerObjectType := {
        return: ReferenceTypeTemplate(self)
    }
}.

// Constant type type
template ConstantTypeTemplate(D: Type)
    := type uses: D;
definition: {
    meta message isConstantType -> Boolean := {
        return: true
    }.

    meta message undecoratedType -> _CompilerObjectType := {
        return: D
    }.

    meta message const -> _CompilerObjectType := {
        return: self
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: D ssaType
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: D cleanType
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: D cvariadicCoercionType
    }.

    meta message sysmelMangledValue -> _CompilerObjectType := {
        return: D sysmelMangledValue -- #c
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (D printingName -- " const")
    }.

    // Allow automatic conversion from const -> non-const values.
    SelfType conversionTo: D doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                ^ value sameValueButWithType: targetType
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                ^ sourceValue
        }.
    }.
}.

AnyValue extend: {
    meta message const -> _CompilerObjectType := {
        return: ConstantTypeTemplate(self)
    }
}.

// Volatile type type
template VolatileTypeTemplate(D: Type)
    := type uses: D;
definition: {
    meta message isVolatileType -> Boolean := {
        return: true
    }.

    meta message undecoratedType -> _CompilerObjectType := {
        return: D
    }.

    meta message const -> _CompilerObjectType := {
        return: D volatile const
    }.

    meta message volatile -> _CompilerObjectType := {
        return: self
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: D ssaType
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: D cleanType
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: D cvariadicCoercionType
    }.

    meta message sysmelMangledValue -> _CompilerObjectType := {
        return: D sysmelMangledValue -- #v
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (D printingName -- " volatile")
    }.

    // Perform a bidirectional identity conversion for volatile types.
    D conversionTo: SelfType doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                ^ value sameValueButWithType: targetType
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                ^ sourceValue
        }.
    }.

    SelfType conversionTo: D doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                ^ value sameValueButWithType: targetType
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                ^ sourceValue
        }.
    }.
}.

AnyValue extend: {
    meta message volatile -> _CompilerObjectType := {
        return: VolatileTypeTemplate(self)
    }
}.

// Tuple type
TupleType uses: AnyValue;
definition: {
    meta message isTupleType -> Boolean := {
        return: true
    }
}.

// Function type
FunctionType uses: AnyValue;
definition: {
    meta message isFunctionType -> Boolean := {
        return: true
    }.

    macro selector: #applyWithArguments: doOn: {
        semanticAnalysis: $$Pharo {
            node: node environment: environment at: aPosition
                | function argumentsTuple functionType argumentsType functionCoercionRule argument coercionType coercionTypes coercionRules |
                function := node receiver.
                argumentsTuple := node arguments first semanticAnalysisInEnvironment: environment.

                functionType := function evaluateCleanValueTypeInEnvironment: environment.
                argumentsType := argumentsTuple evaluateCleanValueTypeInEnvironment: environment.

                "Check the receiver type"
            	functionType isFunctionType ifFalse: [
            		self error: 'Expected a function type instead of {1}.' format: { functionType asString }
            	].

                functionCoercionRule := function type node: function coercedImplicitlyInto: functionType at: node.

            	"Check the arguments type"
            	argumentsType isTupleType ifFalse: [
            		self error: 'Expected a tuple for the function application arguments.'
            	].

            	argumentsType types size < functionType arguments size ifTrue: [
            		self error: 'Fewer arguments than the required ones for function application.'
            	].

            	(argumentsType types size > functionType arguments size and: [functionType variadic not]) ifTrue: [
            		self error: 'More arguments than the required ones for function application.'
            	].

                coercionRules := Array new: argumentsType types size.
                coercionTypes := Array new: argumentsType types size.
            	argumentsType types doWithIndex: [:argumentType :index |
                    argument := argumentsTuple elements at: index.

                    index > functionType arguments size ifTrue: [
                        coercionType := argumentType cvariadicCoercionType.
                    ] ifFalse: [
                        coercionType := functionType arguments at: index.
                    ].

                    coercionTypes at: index put: coercionType.
                    coercionRules at: index put: (argumentType node: argument coercedImplicitlyInto: coercionType at: argument).
            	].

                ^ node copy
                    metaMethod: self;
                    receiver: function;
                    arguments: {argumentsTuple};
                    coercionRule: {functionCoercionRule . coercionRules};
                    coercionType: {functionType . coercionTypes};
                    valueType: functionType returnType;
                    yourself
        }.

        codeGeneration: $$Pharo {
            node: messageNode builder: builder
            | function rawFunctionType functionType argumentsTuple expectedArgumentTypes functionType argumentValues argumentType coercionRules coercionTypes |

			"Get the function"
			rawFunctionType := messageNode receiver type.
			functionType := messageNode coercionType first.
            function := messageNode coercionRule first
                convertSSAValue: (messageNode receiver generateSSACodeWith: builder)
                to: functionType
                with: builder at: messageNode.

            "Convert the arguments"
            argumentsTuple := messageNode arguments first.
            expectedArgumentTypes := functionType arguments.

            coercionRules := messageNode coercionRule second.
            coercionTypes := messageNode coercionType second.
            argumentValues := argumentsTuple elements collectWithIndex: [:argumentNode :index |
                argumentType := argumentNode type.
                (coercionRules at: index) convertSSAValue: (argumentNode generateSSACodeWith: builder)
                    to: (coercionTypes at: index)
                    with: builder at: messageNode.

            ].

            "Call the function"
            ^ builder call: function arguments: argumentValues
        }
    }.
}.

// Structure type
StructureType uses: AnyValue;
definition: {
    meta message asReceiverType -> _CompilerObjectType := {
        return: self ref
    }.
}.

UnionType uses: StructureType.
ClassType uses: StructureType.

// Definition of some types
_LiteralArray uses: LiteralType.
_LiteralSymbol uses: LiteralType.
_LiteralString uses: LiteralType.

_LiteralInteger uses: (LiteralType, IntegerType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Int32
    }.

}.

_LiteralFraction uses: (LiteralType, FractionalType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Float64
    }.
}.

_LiteralFloat uses: (LiteralType, FloatingPointType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Float64
    }.
}.

_CompilerObjectType uses: AnyValue.
_APSGNodeType uses: AnyValue.

Boolean uses: (BooleanType, PrimitiveType);
definition: {
    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaBoolType
    }.

    SelfType sysmelMangledValue: #b.
}.

Void uses: OpaqueType;
definition: {
    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaVoidType
    }.

    SelfType sysmelMangledValue: #v.
}.

// Int8
Int8 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 1
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt8
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #s1.
}.

UInt8 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 1
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt8
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #u1.
}.

// Int16
Int16 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 2
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt16
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #s2.
}.

UInt16 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 2
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt16
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #u2.
}.

// Int32
Int32 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #s8.
}.

UInt32 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #u4.
}.

// Int64
Int64 uses: PrimitiveSignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #s8.
}.

UInt64 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #u8.
}.

Float32 uses: PrimitiveFloatingPointType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaFloat32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    SelfType sysmelMangledValue: #f4.
}.

Float64 uses: PrimitiveFloatingPointType;
definition: {
    meta message size -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaFloat64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    SelfType sysmelMangledValue: #f8.
}.

alias Char := UInt8.

} // End of namespace SysmelKernel
