Compiler topLevelScope useNamespace: namespace SysmelKernel.

namespace SysmelKernel definition: {

// Create and set the basic types. Some of these types are used everywhere by the
// compiler, so their declaration must be the first thing done.
Compiler compilationTarget
    metaType: type _MetaType;
    anyValueTrait: trait AnyValue;
    typeTrait: trait Type;
    tupleTypeTrait: trait TupleType;
    functionTypeTrait: trait FunctionType;
    variantTypeTrait: trait VariantType;
    structureTypeTrait: trait StructureType;
    unionTypeTrait: trait UnionType;
    classTypeTrait: trait ClassType;

    undefinedType: type UndefinedType;
    functionGroupType: type _FunctionGroupType;
    apsgNodeType: type _APSGNodeType;
    compilerObjectType: type _CompilerObjectType;
    incompleteType: type _IncompleteType;

    literalArrayType: type _LiteralArray;
    literalSymbolType: type _LiteralSymbol;
    literalStringType: type _LiteralString;
    literalIntegerType: type _LiteralInteger;
    literalFractionType: type _LiteralFraction;
    literalFloatType: type _LiteralFloat;

    voidType: type Void;
    booleanType: type BooleanBit;

    // Integer types
    int8Type: type Int8;
    uint8Type: type UInt8;

    int16Type: type Int16;
    uint16Type: type UInt16;

    int32Type: type Int32;
    uint32Type: type UInt32;

    int64Type: type Int64;
    uint64Type: type UInt64;

    charType: UInt8;

    // Floating point types
    float32Type: type Float32;
    float64Type: type Float64;

    yourself.

// The return macro is used extensively by the language.
macro selector: #return: doOn: {
    evaluation: $$Pharo {
        evaluateMessage: message inEnvironment: anEnvironment
        	| result convertedResult |
        	result := message arguments first evaluateInEnvironment: anEnvironment.
        	convertedResult := result coercedWithRule: message coercionRule intoType: message coercionType at: message.
        	SYMLValueReturnException new
        		value: convertedResult;
        		signal
    }.

    semanticAnalysis: $$Pharo {
        semanticAnalyzeMessage: message inEnvironment: environment at: aPosition
        	| expectedReturnType returnValue returnValueType coercionRule |
        	message arguments size ~= 1 ifTrue: [
        		self error: '#return: meta-method requires at least one argument.' at: aPosition
        	].

        	"Get the expected return type."
        	expectedReturnType := environment returnType.

        	"Get the return value"
        	returnValue := message arguments first semanticAnalysisInEnvironment: environment.
        	returnValue hasIncompleteSemanticAnalysis ifTrue: [
        		^ message copy
        			arguments: { returnValue };
        			metaMethod: self;
        			hasIncompleteSemanticAnalysis: true;
        			yourself
        	].

        	returnValueType := returnValue evaluateTypeInEnvironment: environment.

        	"Check the type of the return value."
        	coercionRule := returnValueType node: returnValue coercedImplicitlyInto: expectedReturnType at: aPosition.
        	^ message copy
        		arguments: { returnValue };
        		metaMethod: self;
        		coercionType: expectedReturnType;
        		coercionRule: coercionRule;
        		valueType: environment compilationTarget voidType;
        		yourself
    }.

    codeGeneration: $$Pharo {
        generateMessage: messageNode ssaCodeWith: builder
        	| value valueNode valueType returnType rawValue |
        	valueNode := messageNode arguments first.
        	valueType := valueNode type.

        	returnType := messageNode coercionType.
        	rawValue := valueNode generateSSACodeWith: builder.

        	^ returnType isVoidType ifTrue: [
        		builder returnVoid
        	] ifFalse: [
        		value := messageNode coercionRule convertSSAValue: rawValue to: returnType with: builder at: messageNode.
        		builder return: value
        	]
    }.
}.

// A generic type
trait AnyValue
definition: {
    // Add the yourself macro to rewrite to the receiver by default.
    macro selector: #yourself doOn: {
        semanticAnalysis: $$Pharo {
            semanticAnalyzeMessage: message inEnvironment: environment at: aPosition
                ^ message receiver semanticAnalysisInEnvironment: environment
        }.
    }.
}.

// The type meta type
trait Type definition: {
    message asConcreteTypeForFunctionAnalysis -> SelfType := {
        return: self
    }.

    message asReceiverType -> SelfType := {
        return: self
    }.

    message asVariableValueType -> SelfType := {
        return: self
    }.

    message asGCClassFieldType -> SelfType := {
        return: self
    }.

    message isType -> BooleanBit := {
        return: true
    }.

    message isCompilerObjectType -> BooleanBit := {
        return: false
    }.

    message isDynamicObjectType -> BooleanBit := {
        return: false
    }.

    message isAnyDynamicObjectType -> BooleanBit := {
        return: false
    }.

    message isArrayType -> BooleanBit := {
        return: false
    }.

    message isGCClassVariableDataArrayType -> BooleanBit := {
        return: false
    }.

    message isUndeterminedArrayType -> BooleanBit := {
        return: false
    }.

    message isUndefinedType -> BooleanBit := {
        return: false
    }.

    message isLiteralType -> BooleanBit := {
        return: false
    }.

    message isPrimitiveType -> BooleanBit := {
        return: false
    }.

    message isPrimitiveLiteralType -> BooleanBit := {
        return: false
    }.

    message isPrimitiveOrPrimitiveLiteralType -> BooleanBit := {
        return: false
    }.

    message isOpaqueType -> BooleanBit := {
        return: false
    }.

    message isBooleanType -> BooleanBit := {
        return: false
    }.

    message isNumericalType -> BooleanBit := {
        return: false
    }.

    message isIntegerType -> BooleanBit := {
        return: false
    }.

    message isFractionalType -> BooleanBit := {
        return: false
    }.

    message isFloatingPointType -> BooleanBit := {
        return: false
    }.

    message isPointerType -> BooleanBit := {
        return: false
    }.

    message isReferenceType -> BooleanBit := {
        return: false
    }.

    message isPointerOrReferenceType -> BooleanBit := {
        return: false
    }.

    message isTupleType -> BooleanBit := {
        return: false
    }.

    message isFunctionType -> BooleanBit := {
        return: false
    }.

    message isFunctionGroupType -> BooleanBit := {
        return: false
    }.

    message isConstantType -> BooleanBit := {
        return: false
    }.

    message isVolatileType -> BooleanBit := {
        return: false
    }.

    message instanceSize -> _LiteralInteger := {
        return: 0
    }.

    message instanceAlignment -> _LiteralInteger := {
        return: 1
    }.

    message cleanType -> SelfType := {
        return: self
    }.

    message valueType -> SelfType := {
        return: self
    }.

    message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        self error: "Cannot generate default value of {1}" format: (self,self)
    }.

    message isReturnedThroughFirstArgument ::-> BooleanBit := {
        return: false
    }.
}.

AnyValue type uses: Type.

// Meta type
_MetaType uses: AnyValue type;
definition: {
    message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: Compiler compilationTarget int8Type ssaType forAddressSpace: #generic)
    }.

    message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: value ssaValue
    }.
}.

// A literal type
trait LiteralType
    uses: AnyValue;
definition: {
    meta message isLiteralType -> BooleanBit := {
        return: true
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: value
    }.
}.

// Primitive literal type
trait PrimitiveLiteralType
    uses: LiteralType;
definition: {
    meta message isPrimitiveLiteralType -> BooleanBit := {
        return: true
    }.

    meta message isPrimitiveOrPrimitiveLiteralType -> BooleanBit := {
        return: true
    }.
}.

// A primitive type
trait PrimitiveType
    uses: AnyValue;
definition: {
    meta message isPrimitiveType -> BooleanBit := {
        return: true
    }.

    meta message isPrimitiveOrPrimitiveLiteralType -> BooleanBit := {
        return: true
    }.

    meta message instanceAlignment -> _LiteralInteger := {
        return: self instanceSize
    }.

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (module ssaConstantPrimitiveValue: value type: self)
    }.
}.

// An opaque type
trait OpaqueType
    uses: AnyValue;
definition: {
    meta message isOpaqueType -> BooleanBit := {
        return: true
    }
}.

// A numerical type
trait NumericalType uses: AnyValue;
definition: {
    meta message isNumericalType -> BooleanBit := {
        return: true
    }
}.

// An integer type
trait IntegerType uses: NumericalType;
definition: {
    meta message isIntegerType -> BooleanBit := {
        return: true
    }.

    meta message isSigned -> BooleanBit := {
        return: false
    }.

    meta message isUnsigned -> BooleanBit := {
        return: false
    }.
}.

trait SignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned -> BooleanBit := {
        return: true
    }.

    meta message isUnsigned -> BooleanBit := {
        return: false
    }.
}.

trait UnsignedIntegerType uses: IntegerType;
definition: {
    meta message isSigned -> BooleanBit := {
        return: false
    }.

    meta message isUnsigned -> BooleanBit := {
        return: true
    }.
}.

trait PrimitiveIntegerType uses: (PrimitiveType, IntegerType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: 0 type: self ssaType)
    }.

    meta message defaultValue -> _CompilerObjectType := {
        return: 0
    }.

    meta message one -> _CompilerObjectType := {
        return: 1
    }.

    meta message zero -> _CompilerObjectType := {
        return: 0
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: value unwrapSysmelValue type: self ssaType)
    }.
}.

trait PrimitiveUnsignedIntegerType uses: (PrimitiveIntegerType, UnsignedIntegerType).
trait PrimitiveSignedIntegerType uses: (PrimitiveIntegerType, SignedIntegerType).

// A boolean type
trait BooleanType uses: AnyValue;
definition: {
    meta message isBooleanType -> BooleanBit := {
        return: true
    }.
}.

// A fraction type
trait FractionalType uses: NumericalType;
definition: {
    meta message isFractionalType -> BooleanBit := {
        return: true
    }
}.

// A floating point type
trait FloatingPointType uses: NumericalType;
definition: {
    meta message isFloatingPointType -> BooleanBit := {
        return: true
    }
}.

// Primitive floating point
trait PrimitiveFloatingPointType uses: (PrimitiveType, FloatingPointType);
definition: {
    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: 0.0 type: self ssaType)
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: value unwrapSysmelValue type: self ssaType)
    }.

    meta message defaultValue -> _CompilerObjectType := {
        return: 0.0
    }.

    meta message one -> _CompilerObjectType := {
        return: 1.0
    }.

    meta message zero -> _CompilerObjectType := {
        return: 0.0
    }.
}.

// Pointer type
trait PointerType
    uses: AnyValue;
definition: {
    meta message defaultValue -> _CompilerObjectType := {
        return: 0
    }.

    meta message isPointerType -> BooleanBit := {
        return: true
    }.

    meta message isPointerOrReferenceType -> BooleanBit := {
        return: true
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.
}.

// Reference type
trait ReferenceType
    uses: AnyValue;
definition: {
    meta message isReferenceType -> BooleanBit := {
        return: true
    }.

    meta message isPointerOrReferenceType -> BooleanBit := {
        return: true
    }.
}.

// Array type
trait ArrayType
    uses: AnyValue;
definition: {
    meta message isArrayType -> BooleanBit := {
        return: true
    }.
}.

trait GCClassVariableDataArrayType
    uses: AnyValue;
definition: {
    meta message isGCClassVariableDataArrayType -> BooleanBit := {
        return: true
    }.
}.

// AnyValue composition

// Pointer type
template PointerTypeTemplate(P: Type, AS: _LiteralSymbol)
    := type uses: PointerType;
definition: {
    alias PointedType := P.
    alias AddressSpaceName := AS.

    meta message pointed -> _CompilerObjectType := {
        return: PointedType
    }.

    meta message addressSpaceName -> _LiteralSymbol := {
        return: AddressSpaceName
    }.

    meta message instanceAlignment -> _LiteralInteger := {
        return: Compiler compilationTarget pointerAlignment
    }.

    meta message instanceSize -> _LiteralInteger := {
        return: Compiler compilationTarget pointerSize
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: P ssaType forAddressSpace: AddressSpaceName)
    }.

    meta message defaultSSAValueWith: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: 0 type: self ssaType)
    }.

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (module ssaConstantPointer: value type: self)
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: (P cleanType pointerFor: AddressSpaceName)
    }.

    meta message asPointerType ->_CompilerObjectType := {
        return: self
    }.

    meta message asReferenceType ->_CompilerObjectType := {
        return: (P refFor: AddressSpaceName)
    }.

    meta message createSysmelMangledValue -> _CompilerObjectType := {
        return: P sysmelMangledValue -- #p
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (P printingName -- " pointer")
    }.

    // Address space conversion.
    if: (#(function workgroup crossWorkgroup) includes: AddressSpaceName) then: {
        SelfType conversionTo: (P cleanType pointerFor: #generic) | (P pointerFor: #generic) doOn: {
            evaluation: $$Pharo {
                value: value targetType: targetType at: position
                    ^ value
            }.
            codeGeneration: $$Pharo {
                convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                    ^ sourceValue
            }.
        }.
    }.

    meta message lookReceiver: (receiver: _CompilerObjectType) symbol: (symbol: _CompilerObjectType) ifPresent: (ifPresentBlock: _CompilerObjectType)
        ::-> _CompilerObjectType := {
        return: (P lookReceiver: receiver symbol: symbol ifPresent: ifPresentBlock)
    }.
}.

Type extend: {
    message pointer -> _CompilerObjectType := {
        return: PointerTypeTemplate(self, #generic)
    }.

    message pointerFor: (addressSpace: _LiteralSymbol) ::-> _CompilerObjectType := {
        return: PointerTypeTemplate(self, addressSpace)
    }.
}.

// Reference type
template ReferenceTypeTemplate(R: Type, AS: _LiteralSymbol)
    := type uses: ReferenceType;
definition: {
    alias ReferencedType := R.
    alias AddressSpaceName := AS.

    meta message referenced -> _CompilerObjectType := {
        return: ReferencedType
    }.

    meta message addressSpaceName -> _LiteralSymbol := {
        return: AddressSpaceName
    }.

    meta message instanceAlignment -> _LiteralInteger := {
        return: Compiler compilationTarget pointerAlignment
    }.

    meta message instanceSize -> _LiteralInteger := {
        return: Compiler compilationTarget pointerSize
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaPointerTo: R ssaType forAddressSpace: AddressSpaceName)
    }.

    meta message valueType -> _CompilerObjectType := {
        return: R
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: (R cleanType refFor: AddressSpaceName)
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: R cvariadicCoercionType
    }.

    meta message lookReceiver: (receiver: _CompilerObjectType) symbol: (symbol: _CompilerObjectType) ifPresent: (ifPresentBlock: _CompilerObjectType)
        ::-> _CompilerObjectType := {
        return: (R lookReceiver: receiver symbol: symbol ifPresent: ifPresentBlock)
    }.

    meta message asPointerType ->_CompilerObjectType := {
        return: (R pointerFor: AddressSpaceName)
    }.

    meta message asReferenceType -> _CompilerObjectType := {
        return: self
    }.

    meta message createSysmelMangledValue -> _CompilerObjectType := {
        return: R sysmelMangledValue -- #r
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (R printingName -- " ref")
    }.

    // Reference evaluation
    let referenceEvaluationAction := `'{
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                "Reference evaluation"
                ^ value value sysmelEvaluateReference sysmelValueWithType: targetType inEnvironment: value environment
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                targetType isFunctionType ifTrue: [
                    ^ sourceValue
                ].

                ^ builder load: sourceValue
        }.
    }.

    SelfType conversionTo: R cleanType doOn: referenceEvaluationAction.
    SelfType conversionTo: R doOn: referenceEvaluationAction.

    // Address space conversion.
    if: (#(function workgroup crossWorkgroup) includes: AddressSpaceName) then: {
        SelfType conversionTo: (R cleanType refFor: #generic) | (R refFor: #generic) doOn: {
            evaluation: $$Pharo {
                value: value targetType: targetType at: position
                    "Reference evaluation"
                    ^ value
            }.
            codeGeneration: $$Pharo {
                convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                    ^ sourceValue
            }.
        }.
    }.
}.

Type extend: {
    message ref -> _CompilerObjectType := {
        return: ReferenceTypeTemplate(self, #generic)
    }.

    message refFor: (addressSpaceName: _LiteralSymbol) ::-> _CompilerObjectType := {
        return: ReferenceTypeTemplate(self, addressSpaceName)
    }.
}.

// Constant type type
template ConstantTypeTemplate(D: Type)
    := type uses: D;
definition: {
    meta message isConstantType -> BooleanBit := {
        return: true
    }.

    meta message undecoratedType -> _CompilerObjectType := {
        return: D
    }.

    meta message const -> _CompilerObjectType := {
        return: self
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: D ssaType
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: D cleanType
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: D cvariadicCoercionType
    }.

    meta message createSysmelMangledValue -> _CompilerObjectType := {
        return: D sysmelMangledValue -- #c
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (D printingName -- " const")
    }.

    // Allow automatic conversion from const -> non-const values.
    SelfType conversionTo: D doOn: {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                ^ value sameValueButWithType: targetType
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                ^ sourceValue
        }.
    }.
}.

Type extend: {
    message const -> _CompilerObjectType := {
        return: ConstantTypeTemplate(self)
    }
}.

// Volatile type type
template VolatileTypeTemplate(D: Type)
    := type uses: D;
definition: {
    meta message isVolatileType -> BooleanBit := {
        return: true
    }.

    meta message undecoratedType -> _CompilerObjectType := {
        return: D
    }.

    meta message const -> _CompilerObjectType := {
        return: D volatile const
    }.

    meta message volatile -> _CompilerObjectType := {
        return: self
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: D ssaType
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: D cleanType
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: D cvariadicCoercionType
    }.

    meta message createSysmelMangledValue -> _CompilerObjectType := {
        return: D sysmelMangledValue -- #v
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (D printingName -- " volatile")
    }.

    // Perform a bidirectional identity conversion for volatile types.
    let decorationIdentityAction := {
        evaluation: $$Pharo {
            value: value targetType: targetType at: position
                ^ value sameValueButWithType: targetType
        }.
        codeGeneration: $$Pharo {
            convertSSAValue: sourceValue to: targetType with: builder at: messageNode
                ^ sourceValue
        }.
    }.

    D conversionTo: SelfType doOn: decorationIdentityAction.
    SelfType conversionTo: D doOn: decorationIdentityAction.
}.

Type extend: {
    message volatile -> _CompilerObjectType := {
        return: VolatileTypeTemplate(self)
    }
}.

// GCClass variable data array type
template GCClassVariableDataArrayTypeTemplate(E: Type)
    := type uses: GCClassVariableDataArrayType;
definition: {
    alias ElementType := E.
    alias InstanceAlignment := ElementType instanceAlignment.
    alias InstanceSize := ElementType instanceSize * Size.

    meta message instanceSize -> Int32 := {
        return: 0
    }.

    meta message instanceAlignment -> _LiteralInteger := {
        return: 1
    }.

    meta message elementType -> Type := {
        return: ElementType
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaArrayOf: ElementType concreteSSAType size: 0)
    }.

    meta message valueType -> _CompilerObjectType := {
        return: GCClassVariableDataArrayTypeTemplate(ElementType valueType)
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: GCClassVariableDataArrayTypeTemplate(ElementType cleanType)
    }.

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (module ssaConstantVariableArrayValue: value type: self)
    }.

    meta message createSysmelMangledValue -> _CompilerObjectType := {
        return: ElementType sysmelMangledValue -- #d -- Size asString
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (ElementType printingName -- " gcClassVariableDataArray")
    }.
}.

// Array type
template ArrayTypeTemplate(E: Type, N: _LiteralInteger)
    := type uses: ArrayType;
definition: {
    alias ElementType := E.
    alias Size := N.
    alias InstanceAlignment := ElementType instanceAlignment.
    alias InstanceSize := ElementType instanceSize * Size.

    if: N = 0 then: {
        meta message isUndeterminedArrayType -> BooleanBit := {
            return: true
        }.

        meta message asGCClassFieldType -> Type := {
            return: GCClassVariableDataArrayTypeTemplate(ElementType)
        }.
    }.

    meta message size -> _LiteralInteger := {
        return: Size
    }.

    meta message elementType -> Type := {
        return: ElementType
    }.

    meta message instanceSize -> Int32 := {
        return: InstanceSize
    }.

    meta message instanceAlignment -> _LiteralInteger := {
        return: InstanceAlignment
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: (Compiler compilationTarget ssaArrayOf: ElementType concreteSSAType size: Size)
    }.

    meta message valueType -> _CompilerObjectType := {
        return: (ElementType valueType array: Size)
    }.

    meta message cleanType -> _CompilerObjectType := {
        return: (ElementType cleanType array: Size)
    }.

    meta message generateSSAConstant: (value: _CompilerObjectType) forModule: (module: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (module ssaConstantArrayValue: value type: self)
    }.

    meta message createSysmelMangledValue -> _CompilerObjectType := {
        return: ElementType sysmelMangledValue -- #A -- Size asString
    }.

    meta message createPrintingName -> _CompilerObjectType := {
        return: (D printingName -- " array:" -- Size asString)
    }.
}.

Type extend: {
    message array -> _CompilerObjectType := {
        return: ArrayTypeTemplate(self, 0)
    }.

    message array: (N: _LiteralInteger) ::-> _CompilerObjectType := {
        return: ArrayTypeTemplate(self, N)
    }.
}.

// Tuple type
TupleType uses: AnyValue;
definition: {
    meta message isTupleType -> BooleanBit := {
        return: true
    }
}.

// Function group type
_FunctionGroupType uses: AnyValue;
definition: {
    meta message isFunctionGroupType -> BooleanBit := {
        return: true
    }.

    macro selector: #applyWithArguments: doOn: {
        semanticAnalysis: $$Pharo {
            node: node environment: environment at: aPosition
                | functionGroup |
                functionGroup := node receiver analyzeAndEvaluateInEnvironment: environment.
                ^ functionGroup value
                    semanticAnalyzeApplication: node inEnvironment: environment at: aPosition
        }
    }.
}.

// Function type
FunctionType uses: AnyValue;
definition: {
    meta message isFunctionType -> BooleanBit := {
        return: true
    }.

    macro selector: #applyWithArguments: doOn: {
        semanticAnalysis: $$Pharo {
            node: node environment: environment at: aPosition
                | function argumentsTuple functionType argumentsType functionCoercionRule argument coercionType coercionTypes coercionRules |
                function := node receiver.
                argumentsTuple := node arguments first semanticAnalysisInEnvironment: environment.

                functionType := function evaluateCleanValueTypeInEnvironment: environment.
                argumentsType := argumentsTuple evaluateCleanValueTypeInEnvironment: environment.

                "Check the receiver type"
            	functionType isFunctionType ifFalse: [
            		self error: 'Expected a function type instead of {1}.' format: { functionType asString }
            	].

                functionCoercionRule := function type node: function coercedImplicitlyInto: functionType at: node.

            	"Check the arguments type"
            	argumentsType isTupleType ifFalse: [
            		self error: 'Expected a tuple for the function application arguments.'
            	].

            	argumentsType types size < functionType arguments size ifTrue: [
            		self error: 'Fewer arguments than the required ones for function application.'
            	].

            	(argumentsType types size > functionType arguments size and: [functionType variadic not]) ifTrue: [
            		self error: 'More arguments than the required ones for function application.'
            	].

                coercionRules := Array new: argumentsType types size.
                coercionTypes := Array new: argumentsType types size.
            	argumentsType types doWithIndex: [:argumentType :index |
                    argument := argumentsTuple elements at: index.

                    index > functionType arguments size ifTrue: [
                        coercionType := argumentType cvariadicCoercionType.
                    ] ifFalse: [
                        coercionType := functionType arguments at: index.
                    ].

                    coercionTypes at: index put: coercionType.
                    coercionRules at: index put: (argumentType node: argument coercedImplicitlyInto: coercionType at: argument).
            	].

                ^ node copy
                    metaMethod: self;
                    receiver: function;
                    arguments: {argumentsTuple};
                    coercionRule: {functionCoercionRule . coercionRules};
                    coercionType: {functionType . coercionTypes};
                    valueType: functionType returnType;
                    yourself
        }.

        codeGeneration: $$Pharo {
            node: messageNode builder: builder
            | function rawFunctionType functionType argumentsTuple expectedArgumentTypes functionType argumentValues argumentType coercionRules coercionTypes |

			"Get the function"
			rawFunctionType := messageNode receiver type.
			functionType := messageNode coercionType first.
            function := messageNode coercionRule first
                convertSSAValue: (messageNode receiver generateSSACodeWith: builder)
                to: functionType
                with: builder at: messageNode.

            "Convert the arguments"
            argumentsTuple := messageNode arguments first.
            expectedArgumentTypes := functionType arguments.

            coercionRules := messageNode coercionRule second.
            coercionTypes := messageNode coercionType second.
            argumentValues := argumentsTuple elements collectWithIndex: [:argumentNode :index |
                argumentType := argumentNode type.
                (coercionRules at: index) convertSSAValue: (argumentNode generateSSACodeWith: builder)
                    to: (coercionTypes at: index)
                    with: builder at: messageNode.

            ].

            "Call the function"
            ^ builder call: function arguments: argumentValues
        }
    }.
}.

// Structure type
StructureType uses: AnyValue;
definition: {
    meta message asReceiverType -> _CompilerObjectType := {
        return: self ref
    }.
}.

UnionType uses: StructureType.
ClassType uses: StructureType.

// Definition of some types
_LiteralArray uses: LiteralType.
_LiteralSymbol uses: LiteralType.
_LiteralString uses: LiteralType.

_LiteralInteger uses: (PrimitiveLiteralType, IntegerType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Int32
    }.

}.

_LiteralFraction uses: (PrimitiveLiteralType, FractionalType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Float64
    }.
}.

_LiteralFloat uses: (PrimitiveLiteralType, FloatingPointType);
definition: {
    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    meta message valueType -> _CompilerObjectType := {
        return: Float64
    }.
}.

_CompilerObjectType uses: AnyValue.
_APSGNodeType uses: AnyValue.

BooleanBit uses: (BooleanType, PrimitiveType);
definition: {
    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaBoolType
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: (builder const: value unwrapSysmelValue type: self ssaType)
    }.

    SelfType sysmelMangledValue: #b.
}.

// Undefined type. For nil
UndefinedType uses: OpaqueType;
definition: {
    message isUndefinedType -> BooleanBit := {
        return: true
    }.

    meta message generateSSAValue: (value: _CompilerObjectType) withBuilder: (builder: _CompilerObjectType) ::-> _CompilerObjectType := {
        return: value
    }.

    SelfType sysmelMangledValue: #u.
}.

Void uses: OpaqueType;
definition: {
    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaVoidType
    }.

    meta message defaultValue -> _CompilerObjectType := {
        return: nil
    }.

    SelfType sysmelMangledValue: #v.
}.

// Int8
Int8 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 1
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt8
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #s1.
}.

UInt8 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 1
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt8
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #u1.
}.

// Int16
Int16 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 2
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt16
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #s2.
}.

UInt16 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 2
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt16
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Int32
    }.

    SelfType sysmelMangledValue: #u2.
}.

// Int32
Int32 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #s4.
}.

UInt32 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #u4.
}.

// Int64
Int64 uses: PrimitiveSignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaInt64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #s8.
}.

UInt64 uses: PrimitiveUnsignedIntegerType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaUInt64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: self
    }.

    SelfType sysmelMangledValue: #u8.
}.

Float32 uses: PrimitiveFloatingPointType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 4
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaFloat32
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    SelfType sysmelMangledValue: #f4.
}.

Float64 uses: PrimitiveFloatingPointType;
definition: {
    meta message instanceSize -> _LiteralInteger := {
        return: 8
    }.

    meta message buildSSAType -> _CompilerObjectType := {
        return: Compiler compilationTarget ssaFloat64
    }.

    meta message cvariadicCoercionType -> _CompilerObjectType := {
        return: Float64
    }.

    SelfType sysmelMangledValue: #f8.
}.

alias Char := UInt8.

} // End of namespace SysmelKernel
