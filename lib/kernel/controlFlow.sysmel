namespace SysmelKernel definition: {

macro selectors: #(if:then: if:then:else:) doOn: {
    evaluation: $$Pharo {
        node: node environment: environment
            self halt.
    }.

    analysisAndEvaluation: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
            | conditionNode conditionCoercionType conditionValue |

            "Check the condition type"
            conditionNode := messageNode arguments first.
            conditionCoercionType := environment compilationTarget booleanType.
            conditionValue := (conditionNode analyzeAndEvaluateInEnvironment: environment) coercedIntoType: conditionCoercionType at: aSourcePosition.

            ^ conditionValue value ifTrue: [
                messageNode arguments second inlineBlockAnalyzeAndEvaluateInEnvironment: environment
            ] ifFalse: [
                messageNode arguments size >= 3 ifTrue: [
                    messageNode arguments third inlineBlockAnalyzeAndEvaluateInEnvironment: environment
                ] ifFalse: [
                    nil asSysmelValueInEnvironment: environment
                ]
            ]
	}.

    semanticAnalysis: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
            | conditionNode conditionValue thenNode thenType elseNode elseType analyzedArguments conditionCoercionType conditionCoercionRule thenCoercionRule elseCoercionRule resultType |

            "Check the condition type"
            conditionNode := messageNode arguments first semanticAnalysisInEnvironment: environment.
            conditionCoercionType := environment compilationTarget booleanType.
            conditionCoercionRule := (conditionNode evaluateTypeInEnvironment: environment) node: conditionNode coercedImplicitlyInto: conditionCoercionType at: aSourcePosition.

            "This should not be used on an immediate environment."
            self assert: environment isImmediateEnvironment not.

            "Check the rest of the message."
            thenNode := messageNode arguments second inlineBlockSemanticAnalysisInEnvironment: environment.
            thenType := thenNode evaluateCleanValueTypeInEnvironment: environment.
            analyzedArguments := {conditionNode . thenNode}.

            elseNode := nil.
            elseType := nil.
            messageNode arguments size >= 3 ifTrue: [
                elseNode := messageNode arguments third inlineBlockSemanticAnalysisInEnvironment: environment.
                elseType := elseNode evaluateCleanValueTypeInEnvironment: environment.
                analyzedArguments := analyzedArguments , { elseNode }.
            ].


            "Try to select a proper result type instead of void"
            resultType := nil.
            elseType ifNotNil: [
                resultType := thenType arithmeticCoerceWith: elseType at: aSourcePosition.
            ].

            thenCoercionRule := nil.
            elseCoercionRule := nil.
            resultType ifNil: [
                resultType := environment compilationTarget voidType.
            ] ifNotNil: [
                thenCoercionRule := (thenNode evaluateTypeInEnvironment: environment) node: thenNode coercedImplicitlyInto: resultType at: aSourcePosition.
                elseCoercionRule := (elseNode evaluateTypeInEnvironment: environment) node: elseNode coercedImplicitlyInto: resultType at: aSourcePosition.
            ].

	        ^ messageNode copy
		        metaMethod: self;
		        arguments: analyzedArguments;
		        coercionType: {conditionCoercionType . resultType . resultType };
                coercionRule: {conditionCoercionRule . thenCoercionRule . elseCoercionRule };
		        valueType: resultType;
		        yourself
	}.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | conditionNode thenNode elseNode  resultType condition result thenBlock elseBlock mergeBlock thenValue elseValue branchInstruction |
            conditionNode := messageNode arguments first.
            thenNode := messageNode arguments second.

            resultType := messageNode valueType.

            elseNode := nil.
            messageNode arguments size >= 3 ifTrue: [
                elseNode := messageNode arguments third.
            ].

            "Blocks"
            thenBlock := builder newBasicBlock: #ifThen.
            mergeBlock := builder newBasicBlock: #ifMerge.
            elseBlock := elseNode ifNil: [mergeBlock] ifNotNil: [ builder newBasicBlock: #ifElse ].

            "Generate the condition."
            condition := messageNode coercionRule first convertSSAValue: (conditionNode generateSSACodeWith: builder) to: messageNode coercionType first with: builder at: messageNode.
            branchInstruction := builder branch: condition ifTrue: thenBlock ifFalse: elseBlock.
            branchInstruction mergeBlock: mergeBlock.

            "Generate the result."
            result := nil.
            resultType isVoidType ifFalse: [
                builder currentBlock: mergeBlock.
                result := builder phi: resultType ssaType
            ].

            "Then block"
            builder currentBlock: thenBlock.
            thenValue := thenNode generateSSACodeWith: builder.
            builder isLastTerminator ifFalse: [
                resultType isVoidType ifFalse: [
                    result addValue: (messageNode coercionRule second convertSSAValue: thenValue to: messageNode coercionType second with: builder at: messageNode)
                        from: builder currentBlock
                ].
                builder jump: mergeBlock
            ].

            "Else block"
            elseNode ifNotNil: [
                builder currentBlock: elseBlock.
                elseValue := elseNode generateSSACodeWith: builder.
                builder isLastTerminator ifFalse: [
                    resultType isVoidType ifFalse: [
                        result addValue: (messageNode coercionRule third convertSSAValue: elseValue to: messageNode coercionType third with: builder at: messageNode)
                            from: builder currentBlock
                    ].
                    builder jump: mergeBlock
                ].
            ].

            builder currentBlock: mergeBlock.
            mergeBlock predecessors ifEmpty: [
                builder unreachable.
                branchInstruction addUnreachableSuccessors.
            ].

            ^ result.
    }.

}.

// while:do:continueWith:
macro selectors: #(while:do: while:do:continueWith: ) doOn: {
    // Compile time evaluation
    evaluation: $$Pharo {
        node: node environment: environment
            self halt.
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
            | conditionNode bodyNode continueNode analyzedArguments coercionType coercionRule |
            conditionNode := messageNode arguments first semanticAnalysisInEnvironment: environment.
            bodyNode := messageNode arguments second inlineBlockSemanticAnalysisInEnvironment: environment.
            analyzedArguments := {conditionNode . bodyNode}.

            continueNode := nil.
            messageNode arguments size >= 3 ifTrue: [
                continueNode := messageNode arguments third inlineBlockSemanticAnalysisInEnvironment: environment.
                analyzedArguments := analyzedArguments , { continueNode }.
            ].

            "Check the condition type"
            coercionType := environment compilationTarget booleanType.
            coercionRule := (conditionNode evaluateTypeInEnvironment: environment) node: conditionNode coercedImplicitlyInto: coercionType at: aSourcePosition.

	        ^ messageNode copy
		        metaMethod: self;
		        arguments: analyzedArguments;
		        coercionType: coercionType;
                coercionRule: coercionRule;
		        valueType: environment compilationTarget voidType;
		        yourself
	}.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | conditionNode bodyNode continueNode coercionType conditionBlock bodyBlock continueBlock mergeBlock condition |
            conditionNode := messageNode arguments first.
            bodyNode := messageNode arguments second.

            coercionType := messageNode coercionType.

            continueNode := nil.
            messageNode arguments size >= 3 ifTrue: [
                continueNode := messageNode arguments third.
            ].

            "Loop block"
            conditionBlock := builder newBasicBlock: #loopCondition.
            bodyBlock := builder newBasicBlock: #loopBody.
            mergeBlock := builder newBasicBlock: #loopMerge.

            continueBlock := continueNode ifNil: [ conditionBlock ] ifNotNil: [ builder newBasicBlock: #loopContinue ].

            "Enter into the loop"
            builder
                jump: conditionBlock;
                currentBlock: conditionBlock.

            "Generate the condition."
            condition := messageNode coercionRule convertSSAValue: (conditionNode generateSSACodeWith: builder) to: messageNode coercionType with: builder at: messageNode.
            builder
                branch: condition ifTrue: bodyBlock ifFalse: mergeBlock.

            builder withBreak: mergeBlock continue: continueBlock do: [
                builder
                    currentBlock: bodyBlock.

                bodyNode generateSSACodeWith: builder.

                builder isLastTerminator ifFalse: [
                    builder jump: continueBlock
                ]
            ].

            "Generate the continue block, if it exists."
            continueNode ifNotNil: [
                builder
                    currentBlock: continueBlock.

                continueNode generateSSACodeWith: builder.

                builder isLastTerminator ifFalse: [
                    builder jump: conditionBlock
                ]
            ].

            "Continue with the normal control flow."
            builder currentBlock: mergeBlock.
            ^ nil
    }.
}.

// until:do:continueWith:
macro expansionRule until: condition do: body := {
	while: condition macroExpand not do: body macroExpand
}.

macro expansionRule until: condition do: body continueWith: continueAction := {
	while: condition macroExpand not do: body macroExpand continueWith: continueAction macroExpand
}.

// Do:while:continueWith:
macro selectors: #(do:while: do:while:continueWith:) doOn: {
    // Compile time evaluation
    evaluation: $$Pharo {
        node: node environment: environment
            self halt.
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
			self halt
	}.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
			self halt
    }.
}.

}. // End of namespace SysmelKernel
