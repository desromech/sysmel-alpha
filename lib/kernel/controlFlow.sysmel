namespace SysmelKernel definition: {

macro selectors: #(if:then: if:then:else:) doOn: {
    evaluation: $$Pharo {
        node: node environment: environment
            self halt.
    }.

    semanticAnalysis: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
            | conditionNode conditionValue thenNode thenType elseNode elseType analyzedArguments conditionCoercionType conditionCoercionRule thenCoercionRule elseCoercionRule resultType |

            "Check the condition type"
            conditionNode := messageNode arguments first semanticAnalysisInEnvironment: environment.
            conditionCoercionType := environment compilationTarget booleanType.
            conditionCoercionRule := (conditionNode evaluateTypeInEnvironment: environment) node: conditionNode coercedImplicitlyInto: conditionCoercionType at: aSourcePosition.

            "On immediate environment we have to evaluate as soon as possible."
            environment isImmediateEnvironment ifTrue: [
                conditionValue := conditionCoercionRule convertValue: (conditionNode evaluateInEnvironment: environment) into: conditionCoercionType at: messageNode.
                ^ conditionValue value ifTrue: [
                    messageNode arguments second inlineSemanticAnalysisInEnvironment: environment
                ] ifFalse: [
                    messageNode arguments size >= 3 ifTrue: [
                        messageNode arguments third inlineSemanticAnalysisInEnvironment: environment
                    ] ifFalse: [
                        self halt
                    ]
                ].
            ].

            "Check the rest of the message."
            thenNode := messageNode arguments second inlineBlockSemanticAnalysisInEnvironment: environment.
            thenType := thenNode evaluateCleanValueTypeInEnvironment: environment.
            analyzedArguments := {conditionNode . thenNode}.

            elseNode := nil.
            elseType := nil.
            messageNode arguments size >= 3 ifTrue: [
                elseNode := messageNode arguments third inlineBlockSemanticAnalysisInEnvironment: environment.
                elseType := elseNode evaluateCleanValueTypeInEnvironment: environment.
                analyzedArguments := analyzedArguments , { elseNode }.
            ].


            "Try to select a proper result type instead of void"
            resultType := nil.
            elseType ifNotNil: [
                resultType := thenType arithmeticCoerceWith: elseType at: aSourcePosition.
            ].

            thenCoercionRule := nil.
            elseCoercionRule := nil.
            resultType ifNil: [
                resultType := environment compilationTarget voidType.
            ] ifNotNil: [
                thenCoercionRule := (thenNode evaluateTypeInEnvironment: environment) node: thenNode coercedImplicitlyInto: resultType at: aSourcePosition.
                elseCoercionRule := (elseNode evaluateTypeInEnvironment: environment) node: elseNode coercedImplicitlyInto: resultType at: aSourcePosition.
            ].

	        ^ messageNode copy
		        metaMethod: self;
		        arguments: analyzedArguments;
		        coercionType: {conditionCoercionType . resultType . resultType };
                coercionRule: {conditionCoercionRule . thenCoercionRule . elseCoercionRule };
		        valueType: resultType;
		        yourself
	}.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | conditionNode thenNode elseNode  resultType condition result thenBlock elseBlock mergeBlock thenValue elseValue |
            conditionNode := messageNode arguments first.
            thenNode := messageNode arguments second.

            resultType := messageNode valueType.

            elseNode := nil.
            messageNode arguments size >= 3 ifTrue: [
                elseNode := messageNode arguments third.
            ].

            "Blocks"
            thenBlock := builder newBasicBlock: #ifThen.
            mergeBlock := builder newBasicBlock: #ifMerge.
            elseBlock := elseNode ifNil: [mergeBlock] ifNotNil: [ builder newBasicBlock: #ifElse ].

            "Generate the condition."
            condition := messageNode coercionRule first convertSSAValue: (conditionNode generateSSACodeWith: builder) to: messageNode coercionType first with: builder at: messageNode.
            builder branch: condition ifTrue: thenBlock ifFalse: elseBlock.

            "Generate the result."
            result := nil.
            resultType isVoidType ifFalse: [
                builder currentBlock: mergeBlock.
                result := builder phi: resultType ssaType
            ].

            "Then block"
            builder currentBlock: thenBlock.
            thenValue := thenNode generateSSACodeWith: builder.
            builder isLastTerminator ifFalse: [
                resultType isVoidType ifFalse: [
                    result addValue: (messageNode coercionRule second convertSSAValue: thenValue to: messageNode coercionType second with: builder at: messageNode)
                        from: builder currentBlock
                ].
                builder jump: mergeBlock
            ].

            "Else block"
            elseNode ifNotNil: [
                builder currentBlock: elseBlock.
                elseValue := elseNode generateSSACodeWith: builder.
                builder isLastTerminator ifFalse: [
                    resultType isVoidType ifFalse: [
                        result addValue: (messageNode coercionRule third convertSSAValue: elseValue to: messageNode coercionType third with: builder at: messageNode)
                            from: builder currentBlock
                    ].
                    builder jump: mergeBlock
                ].
            ].

            builder currentBlock: mergeBlock.
            ^ result.
    }.

}.

// while:do:continueWith:
macro selectors: #(while:do: while:do:continueWith: ) doOn: {
    // Compile time evaluation
    evaluation: $$Pharo {
        node: node environment: environment
            self halt.
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
            | conditionNode bodyNode continueNode analyzedArguments coercionType coercionRule |
            conditionNode := messageNode arguments first semanticAnalysisInEnvironment: environment.
            bodyNode := messageNode arguments second inlineBlockSemanticAnalysisInEnvironment: environment.
            analyzedArguments := {conditionNode . bodyNode}.

            continueNode := nil.
            messageNode arguments size >= 3 ifTrue: [
                continueNode := messageNode arguments third inlineBlockSemanticAnalysisInEnvironment: environment.
                analyzedArguments := analyzedArguments , { continueNode }.
            ].

            "Check the condition type"
            coercionType := environment compilationTarget booleanType.
            coercionRule := (conditionNode evaluateTypeInEnvironment: environment) node: conditionNode coercedImplicitlyInto: coercionType at: aSourcePosition.

	        ^ messageNode copy
		        metaMethod: self;
		        arguments: analyzedArguments;
		        coercionType: coercionType;
                coercionRule: coercionRule;
		        valueType: environment compilationTarget voidType;
		        yourself
	}.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
            | conditionNode bodyNode continueNode coercionType conditionBlock bodyBlock continueBlock mergeBlock condition |
            conditionNode := messageNode arguments first.
            bodyNode := messageNode arguments second.

            coercionType := messageNode coercionType.

            continueNode := nil.
            messageNode arguments size >= 3 ifTrue: [
                continueNode := messageNode arguments third.
            ].

            "Loop block"
            conditionBlock := builder newBasicBlock: #loopCondition.
            bodyBlock := builder newBasicBlock: #loopBody.
            mergeBlock := builder newBasicBlock: #loopMerge.

            continueBlock := continueNode ifNil: [ conditionBlock ] ifNotNil: [ builder newBasicBlock: #loopContinue ].

            "Enter into the loop"
            builder
                jump: conditionBlock;
                currentBlock: conditionBlock.

            "Generate the condition."
            condition := messageNode coercionRule convertSSAValue: (conditionNode generateSSACodeWith: builder) to: messageNode coercionType with: builder at: messageNode.
            builder
                branch: condition ifTrue: bodyBlock ifFalse: mergeBlock.

            builder withBreak: mergeBlock continue: continueBlock do: [
                builder
                    currentBlock: bodyBlock.

                bodyNode generateSSACodeWith: builder.

                builder isLastTerminator ifFalse: [
                    builder jump: continueBlock
                ]
            ].

            "Generate the continue block, if it exists."
            continueNode ifNotNil: [
                builder
                    currentBlock: continueBlock.

                continueNode generateSSACodeWith: builder.

                builder isLastTerminator ifFalse: [
                    builder jump: conditionBlock
                ]
            ].

            "Continue with the normal control flow."
            builder currentBlock: mergeBlock.
            ^ nil
    }.
}.

// until:do:continueWith:
macro selectors: #(until:do: until:do:continueWith: ) doOn: {
    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
            | newArguments |
            newArguments := messageNode arguments copy.
            newArguments at: 1 put:
                ((environment apsgBuilder send: #not to: newArguments first withArguments: #())
                    position: aSourcePosition).

            ^ (messageNode copy
                selector: (messageNode arguments size = 3 ifTrue: [#while:do:continueWith:] ifFalse: [#while:do:]);
                arguments: newArguments;
                yourself) semanticAnalysisInEnvironment: environment

	}.
}.

// Do:while:continueWith:
macro selectors: #(do:while: do:while:continueWith:) doOn: {
    // Compile time evaluation
    evaluation: $$Pharo {
        node: node environment: environment
            self halt.
    }.

    // Semantic analysis
    semanticAnalysis: $$Pharo {
        node: messageNode environment: environment position: aSourcePosition
			self halt
	}.

    // Code generation
    codeGeneration: $$Pharo {
        node: messageNode builder: builder
			self halt
    }.
}.

}. // End of namespace SysmelKernel
